"format register";
(function(global) {

  var defined = {};

  // indexOf polyfill for IE8
  var indexOf = Array.prototype.indexOf || function(item) {
    for (var i = 0, l = this.length; i < l; i++)
      if (this[i] === item)
        return i;
    return -1;
  }

  function dedupe(deps) {
    var newDeps = [];
    for (var i = 0, l = deps.length; i < l; i++)
      if (indexOf.call(newDeps, deps[i]) == -1)
        newDeps.push(deps[i])
    return newDeps;
  }

  function register(name, deps, declare, execute) {
    if (typeof name != 'string')
      throw "System.register provided no module name";
    
    var entry;

    // dynamic
    if (typeof declare == 'boolean') {
      entry = {
        declarative: false,
        deps: deps,
        execute: execute,
        executingRequire: declare
      };
    }
    else {
      // ES6 declarative
      entry = {
        declarative: true,
        deps: deps,
        declare: declare
      };
    }

    entry.name = name;
    
    // we never overwrite an existing define
    if (!defined[name])
      defined[name] = entry; 

    entry.deps = dedupe(entry.deps);

    // we have to normalize dependencies
    // (assume dependencies are normalized for now)
    // entry.normalizedDeps = entry.deps.map(normalize);
    entry.normalizedDeps = entry.deps;
  }

  function buildGroups(entry, groups) {
    groups[entry.groupIndex] = groups[entry.groupIndex] || [];

    if (indexOf.call(groups[entry.groupIndex], entry) != -1)
      return;

    groups[entry.groupIndex].push(entry);

    for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
      var depName = entry.normalizedDeps[i];
      var depEntry = defined[depName];
      
      // not in the registry means already linked / ES6
      if (!depEntry || depEntry.evaluated)
        continue;
      
      // now we know the entry is in our unlinked linkage group
      var depGroupIndex = entry.groupIndex + (depEntry.declarative != entry.declarative);

      // the group index of an entry is always the maximum
      if (depEntry.groupIndex === undefined || depEntry.groupIndex < depGroupIndex) {
        
        // if already in a group, remove from the old group
        if (depEntry.groupIndex !== undefined) {
          groups[depEntry.groupIndex].splice(indexOf.call(groups[depEntry.groupIndex], depEntry), 1);

          // if the old group is empty, then we have a mixed depndency cycle
          if (groups[depEntry.groupIndex].length == 0)
            throw new TypeError("Mixed dependency cycle detected");
        }

        depEntry.groupIndex = depGroupIndex;
      }

      buildGroups(depEntry, groups);
    }
  }

  function link(name) {
    var startEntry = defined[name];

    startEntry.groupIndex = 0;

    var groups = [];

    buildGroups(startEntry, groups);

    var curGroupDeclarative = !!startEntry.declarative == groups.length % 2;
    for (var i = groups.length - 1; i >= 0; i--) {
      var group = groups[i];
      for (var j = 0; j < group.length; j++) {
        var entry = group[j];

        // link each group
        if (curGroupDeclarative)
          linkDeclarativeModule(entry);
        else
          linkDynamicModule(entry);
      }
      curGroupDeclarative = !curGroupDeclarative; 
    }
  }

  // module binding records
  var moduleRecords = {};
  function getOrCreateModuleRecord(name) {
    return moduleRecords[name] || (moduleRecords[name] = {
      name: name,
      dependencies: [],
      exports: {}, // start from an empty module and extend
      importers: []
    })
  }

  function linkDeclarativeModule(entry) {
    // only link if already not already started linking (stops at circular)
    if (entry.module)
      return;

    var module = entry.module = getOrCreateModuleRecord(entry.name);
    var exports = entry.module.exports;

    var declaration = entry.declare.call(global, function(name, value) {
      module.locked = true;
      exports[name] = value;

      for (var i = 0, l = module.importers.length; i < l; i++) {
        var importerModule = module.importers[i];
        if (!importerModule.locked) {
          var importerIndex = indexOf.call(importerModule.dependencies, module);
          importerModule.setters[importerIndex](exports);
        }
      }

      module.locked = false;
      return value;
    });
    
    module.setters = declaration.setters;
    module.execute = declaration.execute;

    if (!module.setters || !module.execute)
      throw new TypeError("Invalid System.register form for " + entry.name);

    // now link all the module dependencies
    for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
      var depName = entry.normalizedDeps[i];
      var depEntry = defined[depName];
      var depModule = moduleRecords[depName];

      // work out how to set depExports based on scenarios...
      var depExports;

      if (depModule) {
        depExports = depModule.exports;
      }
      else if (depEntry && !depEntry.declarative) {
        depExports = { 'default': depEntry.module.exports, __useDefault: true };
      }
      // in the module registry
      else if (!depEntry) {
        depExports = load(depName);
      }
      // we have an entry -> link
      else {
        linkDeclarativeModule(depEntry);
        depModule = depEntry.module;
        depExports = depModule.exports;
      }

      // only declarative modules have dynamic bindings
      if (depModule && depModule.importers) {
        depModule.importers.push(module);
        module.dependencies.push(depModule);
      }
      else
        module.dependencies.push(null);

      // run the setter for this dependency
      if (module.setters[i])
        module.setters[i](depExports);
    }
  }

  // An analog to loader.get covering execution of all three layers (real declarative, simulated declarative, simulated dynamic)
  function getModule(name) {
    var exports;
    var entry = defined[name];

    if (!entry) {
      exports = load(name);
      if (!exports)
        throw new Error("Unable to load dependency " + name + ".");
    }

    else {
      if (entry.declarative)
        ensureEvaluated(name, []);
    
      else if (!entry.evaluated)
        linkDynamicModule(entry);

      exports = entry.module.exports;
    }

    if ((!entry || entry.declarative) && exports && exports.__useDefault)
      return exports['default'];

    return exports;
  }

  function linkDynamicModule(entry) {
    if (entry.module)
      return;

    var exports = {};

    var module = entry.module = { exports: exports, id: entry.name };

    // AMD requires execute the tree first
    if (!entry.executingRequire) {
      for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
        var depName = entry.normalizedDeps[i];
        var depEntry = defined[depName];
        if (depEntry)
          linkDynamicModule(depEntry);
      }
    }

    // now execute
    entry.evaluated = true;
    var output = entry.execute.call(global, function(name) {
      for (var i = 0, l = entry.deps.length; i < l; i++) {
        if (entry.deps[i] != name)
          continue;
        return getModule(entry.normalizedDeps[i]);
      }
      throw new TypeError('Module ' + name + ' not declared as a dependency.');
    }, exports, module);
    
    if (output)
      module.exports = output;
  }

  /*
   * Given a module, and the list of modules for this current branch,
   *  ensure that each of the dependencies of this module is evaluated
   *  (unless one is a circular dependency already in the list of seen
   *  modules, in which case we execute it)
   *
   * Then we evaluate the module itself depth-first left to right 
   * execution to match ES6 modules
   */
  function ensureEvaluated(moduleName, seen) {
    var entry = defined[moduleName];

    // if already seen, that means it's an already-evaluated non circular dependency
    if (entry.evaluated || !entry.declarative)
      return;

    // this only applies to declarative modules which late-execute

    seen.push(moduleName);

    for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
      var depName = entry.normalizedDeps[i];
      if (indexOf.call(seen, depName) == -1) {
        if (!defined[depName])
          load(depName);
        else
          ensureEvaluated(depName, seen);
      }
    }

    if (entry.evaluated)
      return;

    entry.evaluated = true;
    entry.module.execute.call(global);
  }

  // magical execution function
  var modules = {};
  function load(name) {
    if (modules[name])
      return modules[name];

    var entry = defined[name];

    // first we check if this module has already been defined in the registry
    if (!entry)
      throw "Module " + name + " not present.";

    // recursively ensure that the module and all its 
    // dependencies are linked (with dependency group handling)
    link(name);

    // now handle dependency execution in correct order
    ensureEvaluated(name, []);

    // remove from the registry
    defined[name] = undefined;

    var module = entry.declarative ? entry.module.exports : { 'default': entry.module.exports, '__useDefault': true };

    // return the defined module object
    return modules[name] = module;
  };

  return function(main, declare) {

    var System;

    // if there's a system loader, define onto it
    if (typeof System != 'undefined' && System.register) {
      declare(System);
      System['import'](main);
    }
    // otherwise, self execute
    else {
      declare(System = {
        register: register, 
        get: load, 
        set: function(name, module) {
          modules[name] = module; 
        },
        newModule: function(module) {
          return module;
        },
        global: global 
      });
      System.set('@empty', System.newModule({}));
      load(main);
    }
  };

})(typeof window != 'undefined' ? window : global)
/* ('mainModule', function(System) {
  System.register(...);
}); */

('javascripts/app-view', function(System) {

System.register("npm:process@0.10.0/browser", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var process = module.exports = {};
  var queue = [];
  var draining = false;
  function drainQueue() {
    if (draining) {
      return ;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      var i = -1;
      while (++i < len) {
        currentQueue[i]();
      }
      len = queue.length;
    }
    draining = false;
  }
  process.nextTick = function(fun) {
    queue.push(fun);
    if (!draining) {
      setTimeout(drainQueue, 0);
    }
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = '';
  function noop() {}
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.binding = function(name) {
    throw new Error('process.binding is not supported');
  };
  process.cwd = function() {
    return '/';
  };
  process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
  };
  process.umask = function() {
    return 0;
  };
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/escapeTextForBrowser", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var ESCAPE_LOOKUP = {
    "&": "&amp;",
    ">": "&gt;",
    "<": "&lt;",
    "\"": "&quot;",
    "'": "&#x27;"
  };
  var ESCAPE_REGEX = /[&><"']/g;
  function escaper(match) {
    return ESCAPE_LOOKUP[match];
  }
  function escapeTextForBrowser(text) {
    return ('' + text).replace(ESCAPE_REGEX, escaper);
  }
  module.exports = escapeTextForBrowser;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/memoizeStringOnly", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  function memoizeStringOnly(callback) {
    var cache = {};
    return function(string) {
      if (cache.hasOwnProperty(string)) {
        return cache[string];
      } else {
        return cache[string] = callback.call(this, string);
      }
    };
  }
  module.exports = memoizeStringOnly;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/emptyFunction", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  function makeEmptyFunction(arg) {
    return function() {
      return arg;
    };
  }
  function emptyFunction() {}
  emptyFunction.thatReturns = makeEmptyFunction;
  emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
  emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
  emptyFunction.thatReturnsNull = makeEmptyFunction(null);
  emptyFunction.thatReturnsThis = function() {
    return this;
  };
  emptyFunction.thatReturnsArgument = function(arg) {
    return arg;
  };
  module.exports = emptyFunction;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/keyMirror", ["npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var keyMirror = function(obj) {
      var ret = {};
      var key;
      ("production" !== process.env.NODE_ENV ? invariant(obj instanceof Object && !Array.isArray(obj), 'keyMirror(...): Argument must be an object.') : invariant(obj instanceof Object && !Array.isArray(obj)));
      for (key in obj) {
        if (!obj.hasOwnProperty(key)) {
          continue;
        }
        ret[key] = key;
      }
      return ret;
    };
    module.exports = keyMirror;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/PooledClass", ["npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var oneArgumentPooler = function(copyFieldsFrom) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, copyFieldsFrom);
        return instance;
      } else {
        return new Klass(copyFieldsFrom);
      }
    };
    var twoArgumentPooler = function(a1, a2) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2);
        return instance;
      } else {
        return new Klass(a1, a2);
      }
    };
    var threeArgumentPooler = function(a1, a2, a3) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2, a3);
        return instance;
      } else {
        return new Klass(a1, a2, a3);
      }
    };
    var fiveArgumentPooler = function(a1, a2, a3, a4, a5) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2, a3, a4, a5);
        return instance;
      } else {
        return new Klass(a1, a2, a3, a4, a5);
      }
    };
    var standardReleaser = function(instance) {
      var Klass = this;
      ("production" !== process.env.NODE_ENV ? invariant(instance instanceof Klass, 'Trying to release an instance into a pool of a different type.') : invariant(instance instanceof Klass));
      if (instance.destructor) {
        instance.destructor();
      }
      if (Klass.instancePool.length < Klass.poolSize) {
        Klass.instancePool.push(instance);
      }
    };
    var DEFAULT_POOL_SIZE = 10;
    var DEFAULT_POOLER = oneArgumentPooler;
    var addPoolingTo = function(CopyConstructor, pooler) {
      var NewKlass = CopyConstructor;
      NewKlass.instancePool = [];
      NewKlass.getPooled = pooler || DEFAULT_POOLER;
      if (!NewKlass.poolSize) {
        NewKlass.poolSize = DEFAULT_POOL_SIZE;
      }
      NewKlass.release = standardReleaser;
      return NewKlass;
    };
    var PooledClass = {
      addPoolingTo: addPoolingTo,
      oneArgumentPooler: oneArgumentPooler,
      twoArgumentPooler: twoArgumentPooler,
      threeArgumentPooler: threeArgumentPooler,
      fiveArgumentPooler: fiveArgumentPooler
    };
    module.exports = PooledClass;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/Object.assign", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  function assign(target, sources) {
    if (target == null) {
      throw new TypeError('Object.assign target cannot be null or undefined');
    }
    var to = Object(target);
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
      var nextSource = arguments[nextIndex];
      if (nextSource == null) {
        continue;
      }
      var from = Object(nextSource);
      for (var key in from) {
        if (hasOwnProperty.call(from, key)) {
          to[key] = from[key];
        }
      }
    }
    return to;
  }
  ;
  module.exports = assign;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactCurrentOwner", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var ReactCurrentOwner = {current: null};
  module.exports = ReactCurrentOwner;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactRootIndex", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var ReactRootIndexInjection = {injectCreateReactRootIndex: function(_createReactRootIndex) {
      ReactRootIndex.createReactRootIndex = _createReactRootIndex;
    }};
  var ReactRootIndex = {
    createReactRootIndex: null,
    injection: ReactRootIndexInjection
  };
  module.exports = ReactRootIndex;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/emptyObject", ["github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var emptyObject = {};
    if ("production" !== process.env.NODE_ENV) {
      Object.freeze(emptyObject);
    }
    module.exports = emptyObject;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/CallbackQueue", ["npm:react@0.12.2/lib/PooledClass", "npm:react@0.12.2/lib/Object.assign", "npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var PooledClass = require("npm:react@0.12.2/lib/PooledClass");
    var assign = require("npm:react@0.12.2/lib/Object.assign");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    function CallbackQueue() {
      this._callbacks = null;
      this._contexts = null;
    }
    assign(CallbackQueue.prototype, {
      enqueue: function(callback, context) {
        this._callbacks = this._callbacks || [];
        this._contexts = this._contexts || [];
        this._callbacks.push(callback);
        this._contexts.push(context);
      },
      notifyAll: function() {
        var callbacks = this._callbacks;
        var contexts = this._contexts;
        if (callbacks) {
          ("production" !== process.env.NODE_ENV ? invariant(callbacks.length === contexts.length, "Mismatched list of contexts in callback queue") : invariant(callbacks.length === contexts.length));
          this._callbacks = null;
          this._contexts = null;
          for (var i = 0,
              l = callbacks.length; i < l; i++) {
            callbacks[i].call(contexts[i]);
          }
          callbacks.length = 0;
          contexts.length = 0;
        }
      },
      reset: function() {
        this._callbacks = null;
        this._contexts = null;
      },
      destructor: function() {
        this.reset();
      }
    });
    PooledClass.addPoolingTo(CallbackQueue);
    module.exports = CallbackQueue;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactPerf", ["github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactPerf = {
      enableMeasure: false,
      storedMeasure: _noMeasure,
      measure: function(objName, fnName, func) {
        if ("production" !== process.env.NODE_ENV) {
          var measuredFunc = null;
          var wrapper = function() {
            if (ReactPerf.enableMeasure) {
              if (!measuredFunc) {
                measuredFunc = ReactPerf.storedMeasure(objName, fnName, func);
              }
              return measuredFunc.apply(this, arguments);
            }
            return func.apply(this, arguments);
          };
          wrapper.displayName = objName + '_' + fnName;
          return wrapper;
        }
        return func;
      },
      injection: {injectMeasure: function(measure) {
          ReactPerf.storedMeasure = measure;
        }}
    };
    function _noMeasure(objName, fnName, func) {
      return func;
    }
    module.exports = ReactPerf;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/Transaction", ["npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var Mixin = {
      reinitializeTransaction: function() {
        this.transactionWrappers = this.getTransactionWrappers();
        if (!this.wrapperInitData) {
          this.wrapperInitData = [];
        } else {
          this.wrapperInitData.length = 0;
        }
        this._isInTransaction = false;
      },
      _isInTransaction: false,
      getTransactionWrappers: null,
      isInTransaction: function() {
        return !!this._isInTransaction;
      },
      perform: function(method, scope, a, b, c, d, e, f) {
        ("production" !== process.env.NODE_ENV ? invariant(!this.isInTransaction(), 'Transaction.perform(...): Cannot initialize a transaction when there ' + 'is already an outstanding transaction.') : invariant(!this.isInTransaction()));
        var errorThrown;
        var ret;
        try {
          this._isInTransaction = true;
          errorThrown = true;
          this.initializeAll(0);
          ret = method.call(scope, a, b, c, d, e, f);
          errorThrown = false;
        } finally {
          try {
            if (errorThrown) {
              try {
                this.closeAll(0);
              } catch (err) {}
            } else {
              this.closeAll(0);
            }
          } finally {
            this._isInTransaction = false;
          }
        }
        return ret;
      },
      initializeAll: function(startIndex) {
        var transactionWrappers = this.transactionWrappers;
        for (var i = startIndex; i < transactionWrappers.length; i++) {
          var wrapper = transactionWrappers[i];
          try {
            this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
            this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
          } finally {
            if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
              try {
                this.initializeAll(i + 1);
              } catch (err) {}
            }
          }
        }
      },
      closeAll: function(startIndex) {
        ("production" !== process.env.NODE_ENV ? invariant(this.isInTransaction(), 'Transaction.closeAll(): Cannot close transaction when none are open.') : invariant(this.isInTransaction()));
        var transactionWrappers = this.transactionWrappers;
        for (var i = startIndex; i < transactionWrappers.length; i++) {
          var wrapper = transactionWrappers[i];
          var initData = this.wrapperInitData[i];
          var errorThrown;
          try {
            errorThrown = true;
            if (initData !== Transaction.OBSERVED_ERROR) {
              wrapper.close && wrapper.close.call(this, initData);
            }
            errorThrown = false;
          } finally {
            if (errorThrown) {
              try {
                this.closeAll(i + 1);
              } catch (e) {}
            }
          }
        }
        this.wrapperInitData.length = 0;
      }
    };
    var Transaction = {
      Mixin: Mixin,
      OBSERVED_ERROR: {}
    };
    module.exports = Transaction;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactPropTypeLocations", ["npm:react@0.12.2/lib/keyMirror"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var keyMirror = require("npm:react@0.12.2/lib/keyMirror");
  var ReactPropTypeLocations = keyMirror({
    prop: null,
    context: null,
    childContext: null
  });
  module.exports = ReactPropTypeLocations;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/monitorCodeUse", ["npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var invariant = require("npm:react@0.12.2/lib/invariant");
    function monitorCodeUse(eventName, data) {
      ("production" !== process.env.NODE_ENV ? invariant(eventName && !/[^a-z0-9_]/.test(eventName), 'You must provide an eventName using only the characters [a-z0-9_]') : invariant(eventName && !/[^a-z0-9_]/.test(eventName)));
    }
    module.exports = monitorCodeUse;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactEmptyComponent", ["npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var component;
    var nullComponentIdsRegistry = {};
    var ReactEmptyComponentInjection = {injectEmptyComponent: function(emptyComponent) {
        component = ReactElement.createFactory(emptyComponent);
      }};
    function getEmptyComponent() {
      ("production" !== process.env.NODE_ENV ? invariant(component, 'Trying to return null from a render, but no null placeholder component ' + 'was injected.') : invariant(component));
      return component();
    }
    function registerNullComponentID(id) {
      nullComponentIdsRegistry[id] = true;
    }
    function deregisterNullComponentID(id) {
      delete nullComponentIdsRegistry[id];
    }
    function isNullComponentID(id) {
      return nullComponentIdsRegistry[id];
    }
    var ReactEmptyComponent = {
      deregisterNullComponentID: deregisterNullComponentID,
      getEmptyComponent: getEmptyComponent,
      injection: ReactEmptyComponentInjection,
      isNullComponentID: isNullComponentID,
      registerNullComponentID: registerNullComponentID
    };
    module.exports = ReactEmptyComponent;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactErrorUtils", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var ReactErrorUtils = {guard: function(func, name) {
      return func;
    }};
  module.exports = ReactErrorUtils;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactLegacyElement", ["npm:react@0.12.2/lib/ReactCurrentOwner", "npm:react@0.12.2/lib/invariant", "npm:react@0.12.2/lib/monitorCodeUse", "npm:react@0.12.2/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactCurrentOwner = require("npm:react@0.12.2/lib/ReactCurrentOwner");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var monitorCodeUse = require("npm:react@0.12.2/lib/monitorCodeUse");
    var warning = require("npm:react@0.12.2/lib/warning");
    var legacyFactoryLogs = {};
    function warnForLegacyFactoryCall() {
      if (!ReactLegacyElementFactory._isLegacyCallWarningEnabled) {
        return ;
      }
      var owner = ReactCurrentOwner.current;
      var name = owner && owner.constructor ? owner.constructor.displayName : '';
      if (!name) {
        name = 'Something';
      }
      if (legacyFactoryLogs.hasOwnProperty(name)) {
        return ;
      }
      legacyFactoryLogs[name] = true;
      ("production" !== process.env.NODE_ENV ? warning(false, name + ' is calling a React component directly. ' + 'Use a factory or JSX instead. See: http://fb.me/react-legacyfactory') : null);
      monitorCodeUse('react_legacy_factory_call', {
        version: 3,
        name: name
      });
    }
    function warnForPlainFunctionType(type) {
      var isReactClass = type.prototype && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
      if (isReactClass) {
        ("production" !== process.env.NODE_ENV ? warning(false, 'Did not expect to get a React class here. Use `Component` instead ' + 'of `Component.type` or `this.constructor`.') : null);
      } else {
        if (!type._reactWarnedForThisType) {
          try {
            type._reactWarnedForThisType = true;
          } catch (x) {}
          monitorCodeUse('react_non_component_in_jsx', {
            version: 3,
            name: type.name
          });
        }
        ("production" !== process.env.NODE_ENV ? warning(false, 'This JSX uses a plain function. Only React components are ' + 'valid in React\'s JSX transform.') : null);
      }
    }
    function warnForNonLegacyFactory(type) {
      ("production" !== process.env.NODE_ENV ? warning(false, 'Do not pass React.DOM.' + type.type + ' to JSX or createFactory. ' + 'Use the string "' + type.type + '" instead.') : null);
    }
    function proxyStaticMethods(target, source) {
      if (typeof source !== 'function') {
        return ;
      }
      for (var key in source) {
        if (source.hasOwnProperty(key)) {
          var value = source[key];
          if (typeof value === 'function') {
            var bound = value.bind(source);
            for (var k in value) {
              if (value.hasOwnProperty(k)) {
                bound[k] = value[k];
              }
            }
            target[key] = bound;
          } else {
            target[key] = value;
          }
        }
      }
    }
    var LEGACY_MARKER = {};
    var NON_LEGACY_MARKER = {};
    var ReactLegacyElementFactory = {};
    ReactLegacyElementFactory.wrapCreateFactory = function(createFactory) {
      var legacyCreateFactory = function(type) {
        if (typeof type !== 'function') {
          return createFactory(type);
        }
        if (type.isReactNonLegacyFactory) {
          if ("production" !== process.env.NODE_ENV) {
            warnForNonLegacyFactory(type);
          }
          return createFactory(type.type);
        }
        if (type.isReactLegacyFactory) {
          return createFactory(type.type);
        }
        if ("production" !== process.env.NODE_ENV) {
          warnForPlainFunctionType(type);
        }
        return type;
      };
      return legacyCreateFactory;
    };
    ReactLegacyElementFactory.wrapCreateElement = function(createElement) {
      var legacyCreateElement = function(type, props, children) {
        if (typeof type !== 'function') {
          return createElement.apply(this, arguments);
        }
        var args;
        if (type.isReactNonLegacyFactory) {
          if ("production" !== process.env.NODE_ENV) {
            warnForNonLegacyFactory(type);
          }
          args = Array.prototype.slice.call(arguments, 0);
          args[0] = type.type;
          return createElement.apply(this, args);
        }
        if (type.isReactLegacyFactory) {
          if (type._isMockFunction) {
            type.type._mockedReactClassConstructor = type;
          }
          args = Array.prototype.slice.call(arguments, 0);
          args[0] = type.type;
          return createElement.apply(this, args);
        }
        if ("production" !== process.env.NODE_ENV) {
          warnForPlainFunctionType(type);
        }
        return type.apply(null, Array.prototype.slice.call(arguments, 1));
      };
      return legacyCreateElement;
    };
    ReactLegacyElementFactory.wrapFactory = function(factory) {
      ("production" !== process.env.NODE_ENV ? invariant(typeof factory === 'function', 'This is suppose to accept a element factory') : invariant(typeof factory === 'function'));
      var legacyElementFactory = function(config, children) {
        if ("production" !== process.env.NODE_ENV) {
          warnForLegacyFactoryCall();
        }
        return factory.apply(this, arguments);
      };
      proxyStaticMethods(legacyElementFactory, factory.type);
      legacyElementFactory.isReactLegacyFactory = LEGACY_MARKER;
      legacyElementFactory.type = factory.type;
      return legacyElementFactory;
    };
    ReactLegacyElementFactory.markNonLegacyFactory = function(factory) {
      factory.isReactNonLegacyFactory = NON_LEGACY_MARKER;
      return factory;
    };
    ReactLegacyElementFactory.isValidFactory = function(factory) {
      return typeof factory === 'function' && factory.isReactLegacyFactory === LEGACY_MARKER;
    };
    ReactLegacyElementFactory.isValidClass = function(factory) {
      if ("production" !== process.env.NODE_ENV) {
        ("production" !== process.env.NODE_ENV ? warning(false, 'isValidClass is deprecated and will be removed in a future release. ' + 'Use a more specific validator instead.') : null);
      }
      return ReactLegacyElementFactory.isValidFactory(factory);
    };
    ReactLegacyElementFactory._isLegacyCallWarningEnabled = true;
    module.exports = ReactLegacyElementFactory;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/joinClasses", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  function joinClasses(className) {
    if (!className) {
      className = '';
    }
    var nextClass;
    var argLength = arguments.length;
    if (argLength > 1) {
      for (var ii = 1; ii < argLength; ii++) {
        nextClass = arguments[ii];
        if (nextClass) {
          className = (className ? className + ' ' : '') + nextClass;
        }
      }
    }
    return className;
  }
  module.exports = joinClasses;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactPropTypeLocationNames", ["github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactPropTypeLocationNames = {};
    if ("production" !== process.env.NODE_ENV) {
      ReactPropTypeLocationNames = {
        prop: 'prop',
        context: 'context',
        childContext: 'child context'
      };
    }
    module.exports = ReactPropTypeLocationNames;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactNativeComponent", ["npm:react@0.12.2/lib/Object.assign", "npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var assign = require("npm:react@0.12.2/lib/Object.assign");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var genericComponentClass = null;
    var tagToComponentClass = {};
    var ReactNativeComponentInjection = {
      injectGenericComponentClass: function(componentClass) {
        genericComponentClass = componentClass;
      },
      injectComponentClasses: function(componentClasses) {
        assign(tagToComponentClass, componentClasses);
      }
    };
    function createInstanceForTag(tag, props, parentType) {
      var componentClass = tagToComponentClass[tag];
      if (componentClass == null) {
        ("production" !== process.env.NODE_ENV ? invariant(genericComponentClass, 'There is no registered component for the tag %s', tag) : invariant(genericComponentClass));
        return new genericComponentClass(tag, props);
      }
      if (parentType === tag) {
        ("production" !== process.env.NODE_ENV ? invariant(genericComponentClass, 'There is no registered component for the tag %s', tag) : invariant(genericComponentClass));
        return new genericComponentClass(tag, props);
      }
      return new componentClass.type(props);
    }
    var ReactNativeComponent = {
      createInstanceForTag: createInstanceForTag,
      injection: ReactNativeComponentInjection
    };
    module.exports = ReactNativeComponent;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/keyOf", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var keyOf = function(oneKeyObj) {
    var key;
    for (key in oneKeyObj) {
      if (!oneKeyObj.hasOwnProperty(key)) {
        continue;
      }
      return key;
    }
    return null;
  };
  module.exports = keyOf;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/mapObject", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function mapObject(object, callback, context) {
    if (!object) {
      return null;
    }
    var result = {};
    for (var name in object) {
      if (hasOwnProperty.call(object, name)) {
        result[name] = callback.call(context, object[name], name, object);
      }
    }
    return result;
  }
  module.exports = mapObject;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/shouldUpdateReactComponent", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  function shouldUpdateReactComponent(prevElement, nextElement) {
    if (prevElement && nextElement && prevElement.type === nextElement.type && prevElement.key === nextElement.key && prevElement._owner === nextElement._owner) {
      return true;
    }
    return false;
  }
  module.exports = shouldUpdateReactComponent;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDOM", ["npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/ReactElementValidator", "npm:react@0.12.2/lib/ReactLegacyElement", "npm:react@0.12.2/lib/mapObject", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
    var ReactElementValidator = require("npm:react@0.12.2/lib/ReactElementValidator");
    var ReactLegacyElement = require("npm:react@0.12.2/lib/ReactLegacyElement");
    var mapObject = require("npm:react@0.12.2/lib/mapObject");
    function createDOMFactory(tag) {
      if ("production" !== process.env.NODE_ENV) {
        return ReactLegacyElement.markNonLegacyFactory(ReactElementValidator.createFactory(tag));
      }
      return ReactLegacyElement.markNonLegacyFactory(ReactElement.createFactory(tag));
    }
    var ReactDOM = mapObject({
      a: 'a',
      abbr: 'abbr',
      address: 'address',
      area: 'area',
      article: 'article',
      aside: 'aside',
      audio: 'audio',
      b: 'b',
      base: 'base',
      bdi: 'bdi',
      bdo: 'bdo',
      big: 'big',
      blockquote: 'blockquote',
      body: 'body',
      br: 'br',
      button: 'button',
      canvas: 'canvas',
      caption: 'caption',
      cite: 'cite',
      code: 'code',
      col: 'col',
      colgroup: 'colgroup',
      data: 'data',
      datalist: 'datalist',
      dd: 'dd',
      del: 'del',
      details: 'details',
      dfn: 'dfn',
      dialog: 'dialog',
      div: 'div',
      dl: 'dl',
      dt: 'dt',
      em: 'em',
      embed: 'embed',
      fieldset: 'fieldset',
      figcaption: 'figcaption',
      figure: 'figure',
      footer: 'footer',
      form: 'form',
      h1: 'h1',
      h2: 'h2',
      h3: 'h3',
      h4: 'h4',
      h5: 'h5',
      h6: 'h6',
      head: 'head',
      header: 'header',
      hr: 'hr',
      html: 'html',
      i: 'i',
      iframe: 'iframe',
      img: 'img',
      input: 'input',
      ins: 'ins',
      kbd: 'kbd',
      keygen: 'keygen',
      label: 'label',
      legend: 'legend',
      li: 'li',
      link: 'link',
      main: 'main',
      map: 'map',
      mark: 'mark',
      menu: 'menu',
      menuitem: 'menuitem',
      meta: 'meta',
      meter: 'meter',
      nav: 'nav',
      noscript: 'noscript',
      object: 'object',
      ol: 'ol',
      optgroup: 'optgroup',
      option: 'option',
      output: 'output',
      p: 'p',
      param: 'param',
      picture: 'picture',
      pre: 'pre',
      progress: 'progress',
      q: 'q',
      rp: 'rp',
      rt: 'rt',
      ruby: 'ruby',
      s: 's',
      samp: 'samp',
      script: 'script',
      section: 'section',
      select: 'select',
      small: 'small',
      source: 'source',
      span: 'span',
      strong: 'strong',
      style: 'style',
      sub: 'sub',
      summary: 'summary',
      sup: 'sup',
      table: 'table',
      tbody: 'tbody',
      td: 'td',
      textarea: 'textarea',
      tfoot: 'tfoot',
      th: 'th',
      thead: 'thead',
      time: 'time',
      title: 'title',
      tr: 'tr',
      track: 'track',
      u: 'u',
      ul: 'ul',
      'var': 'var',
      video: 'video',
      wbr: 'wbr',
      circle: 'circle',
      defs: 'defs',
      ellipse: 'ellipse',
      g: 'g',
      line: 'line',
      linearGradient: 'linearGradient',
      mask: 'mask',
      path: 'path',
      pattern: 'pattern',
      polygon: 'polygon',
      polyline: 'polyline',
      radialGradient: 'radialGradient',
      rect: 'rect',
      stop: 'stop',
      svg: 'svg',
      text: 'text',
      tspan: 'tspan'
    }, createDOMFactory);
    module.exports = ReactDOM;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/CSSProperty", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var isUnitlessNumber = {
    columnCount: true,
    flex: true,
    flexGrow: true,
    flexShrink: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    strokeOpacity: true
  };
  function prefixKey(prefix, key) {
    return prefix + key.charAt(0).toUpperCase() + key.substring(1);
  }
  var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
  Object.keys(isUnitlessNumber).forEach(function(prop) {
    prefixes.forEach(function(prefix) {
      isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
    });
  });
  var shorthandPropertyExpansions = {
    background: {
      backgroundImage: true,
      backgroundPosition: true,
      backgroundRepeat: true,
      backgroundColor: true
    },
    border: {
      borderWidth: true,
      borderStyle: true,
      borderColor: true
    },
    borderBottom: {
      borderBottomWidth: true,
      borderBottomStyle: true,
      borderBottomColor: true
    },
    borderLeft: {
      borderLeftWidth: true,
      borderLeftStyle: true,
      borderLeftColor: true
    },
    borderRight: {
      borderRightWidth: true,
      borderRightStyle: true,
      borderRightColor: true
    },
    borderTop: {
      borderTopWidth: true,
      borderTopStyle: true,
      borderTopColor: true
    },
    font: {
      fontStyle: true,
      fontVariant: true,
      fontWeight: true,
      fontSize: true,
      lineHeight: true,
      fontFamily: true
    }
  };
  var CSSProperty = {
    isUnitlessNumber: isUnitlessNumber,
    shorthandPropertyExpansions: shorthandPropertyExpansions
  };
  module.exports = CSSProperty;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ExecutionEnvironment", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
  var ExecutionEnvironment = {
    canUseDOM: canUseDOM,
    canUseWorkers: typeof Worker !== 'undefined',
    canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
    canUseViewport: canUseDOM && !!window.screen,
    isInWorker: !canUseDOM
  };
  module.exports = ExecutionEnvironment;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/camelize", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var _hyphenPattern = /-(.)/g;
  function camelize(string) {
    return string.replace(_hyphenPattern, function(_, character) {
      return character.toUpperCase();
    });
  }
  module.exports = camelize;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/dangerousStyleValue", ["npm:react@0.12.2/lib/CSSProperty"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var CSSProperty = require("npm:react@0.12.2/lib/CSSProperty");
  var isUnitlessNumber = CSSProperty.isUnitlessNumber;
  function dangerousStyleValue(name, value) {
    var isEmpty = value == null || typeof value === 'boolean' || value === '';
    if (isEmpty) {
      return '';
    }
    var isNonNumeric = isNaN(value);
    if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
      return '' + value;
    }
    if (typeof value === 'string') {
      value = value.trim();
    }
    return value + 'px';
  }
  module.exports = dangerousStyleValue;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/hyphenate", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var _uppercasePattern = /([A-Z])/g;
  function hyphenate(string) {
    return string.replace(_uppercasePattern, '-$1').toLowerCase();
  }
  module.exports = hyphenate;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/EventPluginRegistry", ["npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var EventPluginOrder = null;
    var namesToPlugins = {};
    function recomputePluginOrdering() {
      if (!EventPluginOrder) {
        return ;
      }
      for (var pluginName in namesToPlugins) {
        var PluginModule = namesToPlugins[pluginName];
        var pluginIndex = EventPluginOrder.indexOf(pluginName);
        ("production" !== process.env.NODE_ENV ? invariant(pluginIndex > -1, 'EventPluginRegistry: Cannot inject event plugins that do not exist in ' + 'the plugin ordering, `%s`.', pluginName) : invariant(pluginIndex > -1));
        if (EventPluginRegistry.plugins[pluginIndex]) {
          continue;
        }
        ("production" !== process.env.NODE_ENV ? invariant(PluginModule.extractEvents, 'EventPluginRegistry: Event plugins must implement an `extractEvents` ' + 'method, but `%s` does not.', pluginName) : invariant(PluginModule.extractEvents));
        EventPluginRegistry.plugins[pluginIndex] = PluginModule;
        var publishedEvents = PluginModule.eventTypes;
        for (var eventName in publishedEvents) {
          ("production" !== process.env.NODE_ENV ? invariant(publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName), 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : invariant(publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName)));
        }
      }
    }
    function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
      ("production" !== process.env.NODE_ENV ? invariant(!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName), 'EventPluginHub: More than one plugin attempted to publish the same ' + 'event name, `%s`.', eventName) : invariant(!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName)));
      EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;
      var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
      if (phasedRegistrationNames) {
        for (var phaseName in phasedRegistrationNames) {
          if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
            var phasedRegistrationName = phasedRegistrationNames[phaseName];
            publishRegistrationName(phasedRegistrationName, PluginModule, eventName);
          }
        }
        return true;
      } else if (dispatchConfig.registrationName) {
        publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);
        return true;
      }
      return false;
    }
    function publishRegistrationName(registrationName, PluginModule, eventName) {
      ("production" !== process.env.NODE_ENV ? invariant(!EventPluginRegistry.registrationNameModules[registrationName], 'EventPluginHub: More than one plugin attempted to publish the same ' + 'registration name, `%s`.', registrationName) : invariant(!EventPluginRegistry.registrationNameModules[registrationName]));
      EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
      EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;
    }
    var EventPluginRegistry = {
      plugins: [],
      eventNameDispatchConfigs: {},
      registrationNameModules: {},
      registrationNameDependencies: {},
      injectEventPluginOrder: function(InjectedEventPluginOrder) {
        ("production" !== process.env.NODE_ENV ? invariant(!EventPluginOrder, 'EventPluginRegistry: Cannot inject event plugin ordering more than ' + 'once. You are likely trying to load more than one copy of React.') : invariant(!EventPluginOrder));
        EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
        recomputePluginOrdering();
      },
      injectEventPluginsByName: function(injectedNamesToPlugins) {
        var isOrderingDirty = false;
        for (var pluginName in injectedNamesToPlugins) {
          if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
            continue;
          }
          var PluginModule = injectedNamesToPlugins[pluginName];
          if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {
            ("production" !== process.env.NODE_ENV ? invariant(!namesToPlugins[pluginName], 'EventPluginRegistry: Cannot inject two different event plugins ' + 'using the same name, `%s`.', pluginName) : invariant(!namesToPlugins[pluginName]));
            namesToPlugins[pluginName] = PluginModule;
            isOrderingDirty = true;
          }
        }
        if (isOrderingDirty) {
          recomputePluginOrdering();
        }
      },
      getPluginModuleForEvent: function(event) {
        var dispatchConfig = event.dispatchConfig;
        if (dispatchConfig.registrationName) {
          return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
        }
        for (var phase in dispatchConfig.phasedRegistrationNames) {
          if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
            continue;
          }
          var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];
          if (PluginModule) {
            return PluginModule;
          }
        }
        return null;
      },
      _resetEventPlugins: function() {
        EventPluginOrder = null;
        for (var pluginName in namesToPlugins) {
          if (namesToPlugins.hasOwnProperty(pluginName)) {
            delete namesToPlugins[pluginName];
          }
        }
        EventPluginRegistry.plugins.length = 0;
        var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
        for (var eventName in eventNameDispatchConfigs) {
          if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
            delete eventNameDispatchConfigs[eventName];
          }
        }
        var registrationNameModules = EventPluginRegistry.registrationNameModules;
        for (var registrationName in registrationNameModules) {
          if (registrationNameModules.hasOwnProperty(registrationName)) {
            delete registrationNameModules[registrationName];
          }
        }
      }
    };
    module.exports = EventPluginRegistry;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/accumulateInto", ["npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var invariant = require("npm:react@0.12.2/lib/invariant");
    function accumulateInto(current, next) {
      ("production" !== process.env.NODE_ENV ? invariant(next != null, 'accumulateInto(...): Accumulated items must not be null or undefined.') : invariant(next != null));
      if (current == null) {
        return next;
      }
      var currentIsArray = Array.isArray(current);
      var nextIsArray = Array.isArray(next);
      if (currentIsArray && nextIsArray) {
        current.push.apply(current, next);
        return current;
      }
      if (currentIsArray) {
        current.push(next);
        return current;
      }
      if (nextIsArray) {
        return [current].concat(next);
      }
      return [current, next];
    }
    module.exports = accumulateInto;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/forEachAccumulated", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var forEachAccumulated = function(arr, cb, scope) {
    if (Array.isArray(arr)) {
      arr.forEach(cb, scope);
    } else if (arr) {
      cb.call(scope, arr);
    }
  };
  module.exports = forEachAccumulated;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactEventEmitterMixin", ["npm:react@0.12.2/lib/EventPluginHub"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var EventPluginHub = require("npm:react@0.12.2/lib/EventPluginHub");
  function runEventQueueInBatch(events) {
    EventPluginHub.enqueueEvents(events);
    EventPluginHub.processEventQueue();
  }
  var ReactEventEmitterMixin = {handleTopLevel: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
      var events = EventPluginHub.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent);
      runEventQueueInBatch(events);
    }};
  module.exports = ReactEventEmitterMixin;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/getUnboundedScrollPosition", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  function getUnboundedScrollPosition(scrollable) {
    if (scrollable === window) {
      return {
        x: window.pageXOffset || document.documentElement.scrollLeft,
        y: window.pageYOffset || document.documentElement.scrollTop
      };
    }
    return {
      x: scrollable.scrollLeft,
      y: scrollable.scrollTop
    };
  }
  module.exports = getUnboundedScrollPosition;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/isEventSupported", ["npm:react@0.12.2/lib/ExecutionEnvironment"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var ExecutionEnvironment = require("npm:react@0.12.2/lib/ExecutionEnvironment");
  var useHasFeature;
  if (ExecutionEnvironment.canUseDOM) {
    useHasFeature = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature('', '') !== true;
  }
  function isEventSupported(eventNameSuffix, capture) {
    if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
      return false;
    }
    var eventName = 'on' + eventNameSuffix;
    var isSupported = eventName in document;
    if (!isSupported) {
      var element = document.createElement('div');
      element.setAttribute(eventName, 'return;');
      isSupported = typeof element[eventName] === 'function';
    }
    if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
      isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
    }
    return isSupported;
  }
  module.exports = isEventSupported;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/isNode", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  function isNode(object) {
    return !!(object && (typeof Node === 'function' ? object instanceof Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
  }
  module.exports = isNode;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/deprecated", ["npm:react@0.12.2/lib/Object.assign", "npm:react@0.12.2/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var assign = require("npm:react@0.12.2/lib/Object.assign");
    var warning = require("npm:react@0.12.2/lib/warning");
    function deprecated(namespace, oldName, newName, ctx, fn) {
      var warned = false;
      if ("production" !== process.env.NODE_ENV) {
        var newFn = function() {
          ("production" !== process.env.NODE_ENV ? warning(warned, (namespace + "." + oldName + " will be deprecated in a future version. ") + ("Use " + namespace + "." + newName + " instead.")) : null);
          warned = true;
          return fn.apply(ctx, arguments);
        };
        newFn.displayName = (namespace + "_" + oldName);
        return assign(newFn, fn);
      }
      return fn;
    }
    module.exports = deprecated;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/getReactRootElementInContainer", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var DOC_NODE_TYPE = 9;
  function getReactRootElementInContainer(container) {
    if (!container) {
      return null;
    }
    if (container.nodeType === DOC_NODE_TYPE) {
      return container.documentElement;
    } else {
      return container.firstChild;
    }
  }
  module.exports = getReactRootElementInContainer;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactMultiChildUpdateTypes", ["npm:react@0.12.2/lib/keyMirror"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var keyMirror = require("npm:react@0.12.2/lib/keyMirror");
  var ReactMultiChildUpdateTypes = keyMirror({
    INSERT_MARKUP: null,
    MOVE_EXISTING: null,
    REMOVE_NODE: null,
    TEXT_CONTENT: null
  });
  module.exports = ReactMultiChildUpdateTypes;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactTextComponent", ["npm:react@0.12.2/lib/DOMPropertyOperations", "npm:react@0.12.2/lib/ReactComponent", "npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/Object.assign", "npm:react@0.12.2/lib/escapeTextForBrowser"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var DOMPropertyOperations = require("npm:react@0.12.2/lib/DOMPropertyOperations");
  var ReactComponent = require("npm:react@0.12.2/lib/ReactComponent");
  var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
  var assign = require("npm:react@0.12.2/lib/Object.assign");
  var escapeTextForBrowser = require("npm:react@0.12.2/lib/escapeTextForBrowser");
  var ReactTextComponent = function(props) {};
  assign(ReactTextComponent.prototype, ReactComponent.Mixin, {
    mountComponent: function(rootID, transaction, mountDepth) {
      ReactComponent.Mixin.mountComponent.call(this, rootID, transaction, mountDepth);
      var escapedText = escapeTextForBrowser(this.props);
      if (transaction.renderToStaticMarkup) {
        return escapedText;
      }
      return ('<span ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' + escapedText + '</span>');
    },
    receiveComponent: function(nextComponent, transaction) {
      var nextProps = nextComponent.props;
      if (nextProps !== this.props) {
        this.props = nextProps;
        ReactComponent.BackendIDOperations.updateTextContentByID(this._rootNodeID, nextProps);
      }
    }
  });
  var ReactTextComponentFactory = function(text) {
    return new ReactElement(ReactTextComponent, null, null, null, null, text);
  };
  ReactTextComponentFactory.type = ReactTextComponent;
  module.exports = ReactTextComponentFactory;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/EventPropagators", ["npm:react@0.12.2/lib/EventConstants", "npm:react@0.12.2/lib/EventPluginHub", "npm:react@0.12.2/lib/accumulateInto", "npm:react@0.12.2/lib/forEachAccumulated", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var EventConstants = require("npm:react@0.12.2/lib/EventConstants");
    var EventPluginHub = require("npm:react@0.12.2/lib/EventPluginHub");
    var accumulateInto = require("npm:react@0.12.2/lib/accumulateInto");
    var forEachAccumulated = require("npm:react@0.12.2/lib/forEachAccumulated");
    var PropagationPhases = EventConstants.PropagationPhases;
    var getListener = EventPluginHub.getListener;
    function listenerAtPhase(id, event, propagationPhase) {
      var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
      return getListener(id, registrationName);
    }
    function accumulateDirectionalDispatches(domID, upwards, event) {
      if ("production" !== process.env.NODE_ENV) {
        if (!domID) {
          throw new Error('Dispatching id must not be null');
        }
      }
      var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
      var listener = listenerAtPhase(domID, event, phase);
      if (listener) {
        event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
        event._dispatchIDs = accumulateInto(event._dispatchIDs, domID);
      }
    }
    function accumulateTwoPhaseDispatchesSingle(event) {
      if (event && event.dispatchConfig.phasedRegistrationNames) {
        EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(event.dispatchMarker, accumulateDirectionalDispatches, event);
      }
    }
    function accumulateDispatches(id, ignoredDirection, event) {
      if (event && event.dispatchConfig.registrationName) {
        var registrationName = event.dispatchConfig.registrationName;
        var listener = getListener(id, registrationName);
        if (listener) {
          event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
          event._dispatchIDs = accumulateInto(event._dispatchIDs, id);
        }
      }
    }
    function accumulateDirectDispatchesSingle(event) {
      if (event && event.dispatchConfig.registrationName) {
        accumulateDispatches(event.dispatchMarker, null, event);
      }
    }
    function accumulateTwoPhaseDispatches(events) {
      forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
    }
    function accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {
      EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(fromID, toID, accumulateDispatches, leave, enter);
    }
    function accumulateDirectDispatches(events) {
      forEachAccumulated(events, accumulateDirectDispatchesSingle);
    }
    var EventPropagators = {
      accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
      accumulateDirectDispatches: accumulateDirectDispatches,
      accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
    };
    module.exports = EventPropagators;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/getEventTarget", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  function getEventTarget(nativeEvent) {
    var target = nativeEvent.target || nativeEvent.srcElement || window;
    return target.nodeType === 3 ? target.parentNode : target;
  }
  module.exports = getEventTarget;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/isTextInputElement", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var supportedInputTypes = {
    'color': true,
    'date': true,
    'datetime': true,
    'datetime-local': true,
    'email': true,
    'month': true,
    'number': true,
    'password': true,
    'range': true,
    'search': true,
    'tel': true,
    'text': true,
    'time': true,
    'url': true,
    'week': true
  };
  function isTextInputElement(elem) {
    return elem && ((elem.nodeName === 'INPUT' && supportedInputTypes[elem.type]) || elem.nodeName === 'TEXTAREA');
  }
  module.exports = isTextInputElement;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ClientReactRootIndex", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var nextReactRootIndex = 0;
  var ClientReactRootIndex = {createReactRootIndex: function() {
      return nextReactRootIndex++;
    }};
  module.exports = ClientReactRootIndex;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/getNodeForCharacterOffset", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  function getLeafNode(node) {
    while (node && node.firstChild) {
      node = node.firstChild;
    }
    return node;
  }
  function getSiblingNode(node) {
    while (node) {
      if (node.nextSibling) {
        return node.nextSibling;
      }
      node = node.parentNode;
    }
  }
  function getNodeForCharacterOffset(root, offset) {
    var node = getLeafNode(root);
    var nodeStart = 0;
    var nodeEnd = 0;
    while (node) {
      if (node.nodeType == 3) {
        nodeEnd = nodeStart + node.textContent.length;
        if (nodeStart <= offset && nodeEnd >= offset) {
          return {
            node: node,
            offset: offset - nodeStart
          };
        }
        nodeStart = nodeEnd;
      }
      node = getLeafNode(getSiblingNode(node));
    }
  }
  module.exports = getNodeForCharacterOffset;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/getTextContentAccessor", ["npm:react@0.12.2/lib/ExecutionEnvironment"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var ExecutionEnvironment = require("npm:react@0.12.2/lib/ExecutionEnvironment");
  var contentKey = null;
  function getTextContentAccessor() {
    if (!contentKey && ExecutionEnvironment.canUseDOM) {
      contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
    }
    return contentKey;
  }
  module.exports = getTextContentAccessor;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/focusNode", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  function focusNode(node) {
    try {
      node.focus();
    } catch (e) {}
  }
  module.exports = focusNode;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/getActiveElement", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  function getActiveElement() {
    try {
      return document.activeElement || document.body;
    } catch (e) {
      return document.body;
    }
  }
  module.exports = getActiveElement;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SyntheticCompositionEvent", ["npm:react@0.12.2/lib/SyntheticEvent"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var SyntheticEvent = require("npm:react@0.12.2/lib/SyntheticEvent");
  var CompositionEventInterface = {data: null};
  function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);
  module.exports = SyntheticCompositionEvent;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/DefaultEventPluginOrder", ["npm:react@0.12.2/lib/keyOf"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var keyOf = require("npm:react@0.12.2/lib/keyOf");
  var DefaultEventPluginOrder = [keyOf({ResponderEventPlugin: null}), keyOf({SimpleEventPlugin: null}), keyOf({TapEventPlugin: null}), keyOf({EnterLeaveEventPlugin: null}), keyOf({ChangeEventPlugin: null}), keyOf({SelectEventPlugin: null}), keyOf({CompositionEventPlugin: null}), keyOf({BeforeInputEventPlugin: null}), keyOf({AnalyticsEventPlugin: null}), keyOf({MobileSafariClickEventPlugin: null})];
  module.exports = DefaultEventPluginOrder;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SyntheticUIEvent", ["npm:react@0.12.2/lib/SyntheticEvent", "npm:react@0.12.2/lib/getEventTarget"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var SyntheticEvent = require("npm:react@0.12.2/lib/SyntheticEvent");
  var getEventTarget = require("npm:react@0.12.2/lib/getEventTarget");
  var UIEventInterface = {
    view: function(event) {
      if (event.view) {
        return event.view;
      }
      var target = getEventTarget(event);
      if (target != null && target.window === target) {
        return target;
      }
      var doc = target.ownerDocument;
      if (doc) {
        return doc.defaultView || doc.parentWindow;
      } else {
        return window;
      }
    },
    detail: function(event) {
      return event.detail || 0;
    }
  };
  function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);
  module.exports = SyntheticUIEvent;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/getEventModifierState", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var modifierKeyToProp = {
    'Alt': 'altKey',
    'Control': 'ctrlKey',
    'Meta': 'metaKey',
    'Shift': 'shiftKey'
  };
  function modifierStateGetter(keyArg) {
    var syntheticEvent = this;
    var nativeEvent = syntheticEvent.nativeEvent;
    if (nativeEvent.getModifierState) {
      return nativeEvent.getModifierState(keyArg);
    }
    var keyProp = modifierKeyToProp[keyArg];
    return keyProp ? !!nativeEvent[keyProp] : false;
  }
  function getEventModifierState(nativeEvent) {
    return modifierStateGetter;
  }
  module.exports = getEventModifierState;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/HTMLDOMPropertyConfig", ["npm:react@0.12.2/lib/DOMProperty", "npm:react@0.12.2/lib/ExecutionEnvironment"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var DOMProperty = require("npm:react@0.12.2/lib/DOMProperty");
  var ExecutionEnvironment = require("npm:react@0.12.2/lib/ExecutionEnvironment");
  var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
  var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
  var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
  var HAS_SIDE_EFFECTS = DOMProperty.injection.HAS_SIDE_EFFECTS;
  var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
  var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
  var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;
  var hasSVG;
  if (ExecutionEnvironment.canUseDOM) {
    var implementation = document.implementation;
    hasSVG = (implementation && implementation.hasFeature && implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1'));
  }
  var HTMLDOMPropertyConfig = {
    isCustomAttribute: RegExp.prototype.test.bind(/^(data|aria)-[a-z_][a-z\d_.\-]*$/),
    Properties: {
      accept: null,
      acceptCharset: null,
      accessKey: null,
      action: null,
      allowFullScreen: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      allowTransparency: MUST_USE_ATTRIBUTE,
      alt: null,
      async: HAS_BOOLEAN_VALUE,
      autoComplete: null,
      autoPlay: HAS_BOOLEAN_VALUE,
      cellPadding: null,
      cellSpacing: null,
      charSet: MUST_USE_ATTRIBUTE,
      checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      classID: MUST_USE_ATTRIBUTE,
      className: hasSVG ? MUST_USE_ATTRIBUTE : MUST_USE_PROPERTY,
      cols: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
      colSpan: null,
      content: null,
      contentEditable: null,
      contextMenu: MUST_USE_ATTRIBUTE,
      controls: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      coords: null,
      crossOrigin: null,
      data: null,
      dateTime: MUST_USE_ATTRIBUTE,
      defer: HAS_BOOLEAN_VALUE,
      dir: null,
      disabled: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      download: HAS_OVERLOADED_BOOLEAN_VALUE,
      draggable: null,
      encType: null,
      form: MUST_USE_ATTRIBUTE,
      formAction: MUST_USE_ATTRIBUTE,
      formEncType: MUST_USE_ATTRIBUTE,
      formMethod: MUST_USE_ATTRIBUTE,
      formNoValidate: HAS_BOOLEAN_VALUE,
      formTarget: MUST_USE_ATTRIBUTE,
      frameBorder: MUST_USE_ATTRIBUTE,
      height: MUST_USE_ATTRIBUTE,
      hidden: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      href: null,
      hrefLang: null,
      htmlFor: null,
      httpEquiv: null,
      icon: null,
      id: MUST_USE_PROPERTY,
      label: null,
      lang: null,
      list: MUST_USE_ATTRIBUTE,
      loop: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      manifest: MUST_USE_ATTRIBUTE,
      marginHeight: null,
      marginWidth: null,
      max: null,
      maxLength: MUST_USE_ATTRIBUTE,
      media: MUST_USE_ATTRIBUTE,
      mediaGroup: null,
      method: null,
      min: null,
      multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      name: null,
      noValidate: HAS_BOOLEAN_VALUE,
      open: null,
      pattern: null,
      placeholder: null,
      poster: null,
      preload: null,
      radioGroup: null,
      readOnly: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      rel: null,
      required: HAS_BOOLEAN_VALUE,
      role: MUST_USE_ATTRIBUTE,
      rows: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
      rowSpan: null,
      sandbox: null,
      scope: null,
      scrolling: null,
      seamless: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      shape: null,
      size: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
      sizes: MUST_USE_ATTRIBUTE,
      span: HAS_POSITIVE_NUMERIC_VALUE,
      spellCheck: null,
      src: null,
      srcDoc: MUST_USE_PROPERTY,
      srcSet: MUST_USE_ATTRIBUTE,
      start: HAS_NUMERIC_VALUE,
      step: null,
      style: null,
      tabIndex: null,
      target: null,
      title: null,
      type: null,
      useMap: null,
      value: MUST_USE_PROPERTY | HAS_SIDE_EFFECTS,
      width: MUST_USE_ATTRIBUTE,
      wmode: MUST_USE_ATTRIBUTE,
      autoCapitalize: null,
      autoCorrect: null,
      itemProp: MUST_USE_ATTRIBUTE,
      itemScope: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      itemType: MUST_USE_ATTRIBUTE,
      property: null
    },
    DOMAttributeNames: {
      acceptCharset: 'accept-charset',
      className: 'class',
      htmlFor: 'for',
      httpEquiv: 'http-equiv'
    },
    DOMPropertyNames: {
      autoCapitalize: 'autocapitalize',
      autoComplete: 'autocomplete',
      autoCorrect: 'autocorrect',
      autoFocus: 'autofocus',
      autoPlay: 'autoplay',
      encType: 'enctype',
      hrefLang: 'hreflang',
      radioGroup: 'radiogroup',
      spellCheck: 'spellcheck',
      srcDoc: 'srcdoc',
      srcSet: 'srcset'
    }
  };
  module.exports = HTMLDOMPropertyConfig;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/MobileSafariClickEventPlugin", ["npm:react@0.12.2/lib/EventConstants", "npm:react@0.12.2/lib/emptyFunction"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var EventConstants = require("npm:react@0.12.2/lib/EventConstants");
  var emptyFunction = require("npm:react@0.12.2/lib/emptyFunction");
  var topLevelTypes = EventConstants.topLevelTypes;
  var MobileSafariClickEventPlugin = {
    eventTypes: null,
    extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
      if (topLevelType === topLevelTypes.topTouchStart) {
        var target = nativeEvent.target;
        if (target && !target.onclick) {
          target.onclick = emptyFunction;
        }
      }
    }
  };
  module.exports = MobileSafariClickEventPlugin;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/toArray", ["npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var invariant = require("npm:react@0.12.2/lib/invariant");
    function toArray(obj) {
      var length = obj.length;
      ("production" !== process.env.NODE_ENV ? invariant(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function'), 'toArray: Array-like object expected') : invariant(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')));
      ("production" !== process.env.NODE_ENV ? invariant(typeof length === 'number', 'toArray: Object needs a length property') : invariant(typeof length === 'number'));
      ("production" !== process.env.NODE_ENV ? invariant(length === 0 || (length - 1) in obj, 'toArray: Object should have keys for indices') : invariant(length === 0 || (length - 1) in obj));
      if (obj.hasOwnProperty) {
        try {
          return Array.prototype.slice.call(obj);
        } catch (e) {}
      }
      var ret = Array(length);
      for (var ii = 0; ii < length; ii++) {
        ret[ii] = obj[ii];
      }
      return ret;
    }
    module.exports = toArray;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/getMarkupWrap", ["npm:react@0.12.2/lib/ExecutionEnvironment", "npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var ExecutionEnvironment = require("npm:react@0.12.2/lib/ExecutionEnvironment");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
    var shouldWrap = {
      'circle': true,
      'defs': true,
      'ellipse': true,
      'g': true,
      'line': true,
      'linearGradient': true,
      'path': true,
      'polygon': true,
      'polyline': true,
      'radialGradient': true,
      'rect': true,
      'stop': true,
      'text': true
    };
    var selectWrap = [1, '<select multiple="true">', '</select>'];
    var tableWrap = [1, '<table>', '</table>'];
    var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
    var svgWrap = [1, '<svg>', '</svg>'];
    var markupWrap = {
      '*': [1, '?<div>', '</div>'],
      'area': [1, '<map>', '</map>'],
      'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
      'legend': [1, '<fieldset>', '</fieldset>'],
      'param': [1, '<object>', '</object>'],
      'tr': [2, '<table><tbody>', '</tbody></table>'],
      'optgroup': selectWrap,
      'option': selectWrap,
      'caption': tableWrap,
      'colgroup': tableWrap,
      'tbody': tableWrap,
      'tfoot': tableWrap,
      'thead': tableWrap,
      'td': trWrap,
      'th': trWrap,
      'circle': svgWrap,
      'defs': svgWrap,
      'ellipse': svgWrap,
      'g': svgWrap,
      'line': svgWrap,
      'linearGradient': svgWrap,
      'path': svgWrap,
      'polygon': svgWrap,
      'polyline': svgWrap,
      'radialGradient': svgWrap,
      'rect': svgWrap,
      'stop': svgWrap,
      'text': svgWrap
    };
    function getMarkupWrap(nodeName) {
      ("production" !== process.env.NODE_ENV ? invariant(!!dummyNode, 'Markup wrapping node not initialized') : invariant(!!dummyNode));
      if (!markupWrap.hasOwnProperty(nodeName)) {
        nodeName = '*';
      }
      if (!shouldWrap.hasOwnProperty(nodeName)) {
        if (nodeName === '*') {
          dummyNode.innerHTML = '<link />';
        } else {
          dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
        }
        shouldWrap[nodeName] = !dummyNode.firstChild;
      }
      return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
    }
    module.exports = getMarkupWrap;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/setInnerHTML", ["npm:react@0.12.2/lib/ExecutionEnvironment", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ExecutionEnvironment = require("npm:react@0.12.2/lib/ExecutionEnvironment");
    var WHITESPACE_TEST = /^[ \r\n\t\f]/;
    var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;
    var setInnerHTML = function(node, html) {
      node.innerHTML = html;
    };
    if (ExecutionEnvironment.canUseDOM) {
      var testElement = document.createElement('div');
      testElement.innerHTML = ' ';
      if (testElement.innerHTML === '') {
        setInnerHTML = function(node, html) {
          if (node.parentNode) {
            node.parentNode.replaceChild(node, node);
          }
          if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
            node.innerHTML = '\uFEFF' + html;
            var textNode = node.firstChild;
            if (textNode.data.length === 1) {
              node.removeChild(textNode);
            } else {
              textNode.deleteData(0, 1);
            }
          } else {
            node.innerHTML = html;
          }
        };
      }
    }
    module.exports = setInnerHTML;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/adler32", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var MOD = 65521;
  function adler32(data) {
    var a = 1;
    var b = 0;
    for (var i = 0; i < data.length; i++) {
      a = (a + data.charCodeAt(i)) % MOD;
      b = (b + a) % MOD;
    }
    return a | (b << 16);
  }
  module.exports = adler32;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactPutListenerQueue", ["npm:react@0.12.2/lib/PooledClass", "npm:react@0.12.2/lib/ReactBrowserEventEmitter", "npm:react@0.12.2/lib/Object.assign"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var PooledClass = require("npm:react@0.12.2/lib/PooledClass");
  var ReactBrowserEventEmitter = require("npm:react@0.12.2/lib/ReactBrowserEventEmitter");
  var assign = require("npm:react@0.12.2/lib/Object.assign");
  function ReactPutListenerQueue() {
    this.listenersToPut = [];
  }
  assign(ReactPutListenerQueue.prototype, {
    enqueuePutListener: function(rootNodeID, propKey, propValue) {
      this.listenersToPut.push({
        rootNodeID: rootNodeID,
        propKey: propKey,
        propValue: propValue
      });
    },
    putListeners: function() {
      for (var i = 0; i < this.listenersToPut.length; i++) {
        var listenerToPut = this.listenersToPut[i];
        ReactBrowserEventEmitter.putListener(listenerToPut.rootNodeID, listenerToPut.propKey, listenerToPut.propValue);
      }
    },
    reset: function() {
      this.listenersToPut.length = 0;
    },
    destructor: function() {
      this.reset();
    }
  });
  PooledClass.addPoolingTo(ReactPutListenerQueue);
  module.exports = ReactPutListenerQueue;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDefaultBatchingStrategy", ["npm:react@0.12.2/lib/ReactUpdates", "npm:react@0.12.2/lib/Transaction", "npm:react@0.12.2/lib/Object.assign", "npm:react@0.12.2/lib/emptyFunction"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var ReactUpdates = require("npm:react@0.12.2/lib/ReactUpdates");
  var Transaction = require("npm:react@0.12.2/lib/Transaction");
  var assign = require("npm:react@0.12.2/lib/Object.assign");
  var emptyFunction = require("npm:react@0.12.2/lib/emptyFunction");
  var RESET_BATCHED_UPDATES = {
    initialize: emptyFunction,
    close: function() {
      ReactDefaultBatchingStrategy.isBatchingUpdates = false;
    }
  };
  var FLUSH_BATCHED_UPDATES = {
    initialize: emptyFunction,
    close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
  };
  var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];
  function ReactDefaultBatchingStrategyTransaction() {
    this.reinitializeTransaction();
  }
  assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction.Mixin, {getTransactionWrappers: function() {
      return TRANSACTION_WRAPPERS;
    }});
  var transaction = new ReactDefaultBatchingStrategyTransaction();
  var ReactDefaultBatchingStrategy = {
    isBatchingUpdates: false,
    batchedUpdates: function(callback, a, b) {
      var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;
      ReactDefaultBatchingStrategy.isBatchingUpdates = true;
      if (alreadyBatchingUpdates) {
        callback(a, b);
      } else {
        transaction.perform(callback, null, a, b);
      }
    }
  };
  module.exports = ReactDefaultBatchingStrategy;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/AutoFocusMixin", ["npm:react@0.12.2/lib/focusNode"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var focusNode = require("npm:react@0.12.2/lib/focusNode");
  var AutoFocusMixin = {componentDidMount: function() {
      if (this.props.autoFocus) {
        focusNode(this.getDOMNode());
      }
    }};
  module.exports = AutoFocusMixin;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/LocalEventTrapMixin", ["npm:react@0.12.2/lib/ReactBrowserEventEmitter", "npm:react@0.12.2/lib/accumulateInto", "npm:react@0.12.2/lib/forEachAccumulated", "npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactBrowserEventEmitter = require("npm:react@0.12.2/lib/ReactBrowserEventEmitter");
    var accumulateInto = require("npm:react@0.12.2/lib/accumulateInto");
    var forEachAccumulated = require("npm:react@0.12.2/lib/forEachAccumulated");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    function remove(event) {
      event.remove();
    }
    var LocalEventTrapMixin = {
      trapBubbledEvent: function(topLevelType, handlerBaseName) {
        ("production" !== process.env.NODE_ENV ? invariant(this.isMounted(), 'Must be mounted to trap events') : invariant(this.isMounted()));
        var listener = ReactBrowserEventEmitter.trapBubbledEvent(topLevelType, handlerBaseName, this.getDOMNode());
        this._localEventListeners = accumulateInto(this._localEventListeners, listener);
      },
      componentWillUnmount: function() {
        if (this._localEventListeners) {
          forEachAccumulated(this._localEventListeners, remove);
        }
      }
    };
    module.exports = LocalEventTrapMixin;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDOMImg", ["npm:react@0.12.2/lib/EventConstants", "npm:react@0.12.2/lib/LocalEventTrapMixin", "npm:react@0.12.2/lib/ReactBrowserComponentMixin", "npm:react@0.12.2/lib/ReactCompositeComponent", "npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/ReactDOM"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var EventConstants = require("npm:react@0.12.2/lib/EventConstants");
  var LocalEventTrapMixin = require("npm:react@0.12.2/lib/LocalEventTrapMixin");
  var ReactBrowserComponentMixin = require("npm:react@0.12.2/lib/ReactBrowserComponentMixin");
  var ReactCompositeComponent = require("npm:react@0.12.2/lib/ReactCompositeComponent");
  var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
  var ReactDOM = require("npm:react@0.12.2/lib/ReactDOM");
  var img = ReactElement.createFactory(ReactDOM.img.type);
  var ReactDOMImg = ReactCompositeComponent.createClass({
    displayName: 'ReactDOMImg',
    tagName: 'IMG',
    mixins: [ReactBrowserComponentMixin, LocalEventTrapMixin],
    render: function() {
      return img(this.props);
    },
    componentDidMount: function() {
      this.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load');
      this.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error');
    }
  });
  module.exports = ReactDOMImg;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactPropTypes", ["npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/ReactPropTypeLocationNames", "npm:react@0.12.2/lib/deprecated", "npm:react@0.12.2/lib/emptyFunction"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
  var ReactPropTypeLocationNames = require("npm:react@0.12.2/lib/ReactPropTypeLocationNames");
  var deprecated = require("npm:react@0.12.2/lib/deprecated");
  var emptyFunction = require("npm:react@0.12.2/lib/emptyFunction");
  var ANONYMOUS = '<<anonymous>>';
  var elementTypeChecker = createElementTypeChecker();
  var nodeTypeChecker = createNodeChecker();
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: elementTypeChecker,
    instanceOf: createInstanceTypeChecker,
    node: nodeTypeChecker,
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    component: deprecated('React.PropTypes', 'component', 'element', this, elementTypeChecker),
    renderable: deprecated('React.PropTypes', 'renderable', 'node', this, nodeTypeChecker)
  };
  function createChainableTypeChecker(validate) {
    function checkType(isRequired, props, propName, componentName, location) {
      componentName = componentName || ANONYMOUS;
      if (props[propName] == null) {
        var locationName = ReactPropTypeLocationNames[location];
        if (isRequired) {
          return new Error(("Required " + locationName + " `" + propName + "` was not specified in ") + ("`" + componentName + "`."));
        }
      } else {
        return validate(props, propName, componentName, location);
      }
    }
    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);
    return chainedCheckType;
  }
  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        var locationName = ReactPropTypeLocationNames[location];
        var preciseType = getPreciseType(propValue);
        return new Error(("Invalid " + locationName + " `" + propName + "` of type `" + preciseType + "` ") + ("supplied to `" + componentName + "`, expected `" + expectedType + "`."));
      }
    }
    return createChainableTypeChecker(validate);
  }
  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunction.thatReturns());
  }
  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location) {
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var locationName = ReactPropTypeLocationNames[location];
        var propType = getPropType(propValue);
        return new Error(("Invalid " + locationName + " `" + propName + "` of type ") + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location);
        if (error instanceof Error) {
          return error;
        }
      }
    }
    return createChainableTypeChecker(validate);
  }
  function createElementTypeChecker() {
    function validate(props, propName, componentName, location) {
      if (!ReactElement.isValidElement(props[propName])) {
        var locationName = ReactPropTypeLocationNames[location];
        return new Error(("Invalid " + locationName + " `" + propName + "` supplied to ") + ("`" + componentName + "`, expected a ReactElement."));
      }
    }
    return createChainableTypeChecker(validate);
  }
  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location) {
      if (!(props[propName] instanceof expectedClass)) {
        var locationName = ReactPropTypeLocationNames[location];
        var expectedClassName = expectedClass.name || ANONYMOUS;
        return new Error(("Invalid " + locationName + " `" + propName + "` supplied to ") + ("`" + componentName + "`, expected instance of `" + expectedClassName + "`."));
      }
    }
    return createChainableTypeChecker(validate);
  }
  function createEnumTypeChecker(expectedValues) {
    function validate(props, propName, componentName, location) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (propValue === expectedValues[i]) {
          return ;
        }
      }
      var locationName = ReactPropTypeLocationNames[location];
      var valuesString = JSON.stringify(expectedValues);
      return new Error(("Invalid " + locationName + " `" + propName + "` of value `" + propValue + "` ") + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
    }
    return createChainableTypeChecker(validate);
  }
  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        var locationName = ReactPropTypeLocationNames[location];
        return new Error(("Invalid " + locationName + " `" + propName + "` of type ") + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location);
          if (error instanceof Error) {
            return error;
          }
        }
      }
    }
    return createChainableTypeChecker(validate);
  }
  function createUnionTypeChecker(arrayOfTypeCheckers) {
    function validate(props, propName, componentName, location) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location) == null) {
          return ;
        }
      }
      var locationName = ReactPropTypeLocationNames[location];
      return new Error(("Invalid " + locationName + " `" + propName + "` supplied to ") + ("`" + componentName + "`."));
    }
    return createChainableTypeChecker(validate);
  }
  function createNodeChecker() {
    function validate(props, propName, componentName, location) {
      if (!isNode(props[propName])) {
        var locationName = ReactPropTypeLocationNames[location];
        return new Error(("Invalid " + locationName + " `" + propName + "` supplied to ") + ("`" + componentName + "`, expected a ReactNode."));
      }
    }
    return createChainableTypeChecker(validate);
  }
  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        var locationName = ReactPropTypeLocationNames[location];
        return new Error(("Invalid " + locationName + " `" + propName + "` of type `" + propType + "` ") + ("supplied to `" + componentName + "`, expected `object`."));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location);
        if (error) {
          return error;
        }
      }
    }
    return createChainableTypeChecker(validate, 'expected `object`');
  }
  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (ReactElement.isValidElement(propValue)) {
          return true;
        }
        for (var k in propValue) {
          if (!isNode(propValue[k])) {
            return false;
          }
        }
        return true;
      default:
        return false;
    }
  }
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      return 'object';
    }
    return propType;
  }
  function getPreciseType(propValue) {
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }
  module.exports = ReactPropTypes;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDOMOption", ["npm:react@0.12.2/lib/ReactBrowserComponentMixin", "npm:react@0.12.2/lib/ReactCompositeComponent", "npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/ReactDOM", "npm:react@0.12.2/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactBrowserComponentMixin = require("npm:react@0.12.2/lib/ReactBrowserComponentMixin");
    var ReactCompositeComponent = require("npm:react@0.12.2/lib/ReactCompositeComponent");
    var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
    var ReactDOM = require("npm:react@0.12.2/lib/ReactDOM");
    var warning = require("npm:react@0.12.2/lib/warning");
    var option = ReactElement.createFactory(ReactDOM.option.type);
    var ReactDOMOption = ReactCompositeComponent.createClass({
      displayName: 'ReactDOMOption',
      mixins: [ReactBrowserComponentMixin],
      componentWillMount: function() {
        if ("production" !== process.env.NODE_ENV) {
          ("production" !== process.env.NODE_ENV ? warning(this.props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : null);
        }
      },
      render: function() {
        return option(this.props, this.props.children);
      }
    });
    module.exports = ReactDOMOption;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDOMSelect", ["npm:react@0.12.2/lib/AutoFocusMixin", "npm:react@0.12.2/lib/LinkedValueUtils", "npm:react@0.12.2/lib/ReactBrowserComponentMixin", "npm:react@0.12.2/lib/ReactCompositeComponent", "npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/ReactDOM", "npm:react@0.12.2/lib/ReactUpdates", "npm:react@0.12.2/lib/Object.assign"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var AutoFocusMixin = require("npm:react@0.12.2/lib/AutoFocusMixin");
  var LinkedValueUtils = require("npm:react@0.12.2/lib/LinkedValueUtils");
  var ReactBrowserComponentMixin = require("npm:react@0.12.2/lib/ReactBrowserComponentMixin");
  var ReactCompositeComponent = require("npm:react@0.12.2/lib/ReactCompositeComponent");
  var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
  var ReactDOM = require("npm:react@0.12.2/lib/ReactDOM");
  var ReactUpdates = require("npm:react@0.12.2/lib/ReactUpdates");
  var assign = require("npm:react@0.12.2/lib/Object.assign");
  var select = ReactElement.createFactory(ReactDOM.select.type);
  function updateWithPendingValueIfMounted() {
    if (this.isMounted()) {
      this.setState({value: this._pendingValue});
      this._pendingValue = 0;
    }
  }
  function selectValueType(props, propName, componentName) {
    if (props[propName] == null) {
      return ;
    }
    if (props.multiple) {
      if (!Array.isArray(props[propName])) {
        return new Error(("The `" + propName + "` prop supplied to <select> must be an array if ") + ("`multiple` is true."));
      }
    } else {
      if (Array.isArray(props[propName])) {
        return new Error(("The `" + propName + "` prop supplied to <select> must be a scalar ") + ("value if `multiple` is false."));
      }
    }
  }
  function updateOptions(component, propValue) {
    var multiple = component.props.multiple;
    var value = propValue != null ? propValue : component.state.value;
    var options = component.getDOMNode().options;
    var selectedValue,
        i,
        l;
    if (multiple) {
      selectedValue = {};
      for (i = 0, l = value.length; i < l; ++i) {
        selectedValue['' + value[i]] = true;
      }
    } else {
      selectedValue = '' + value;
    }
    for (i = 0, l = options.length; i < l; i++) {
      var selected = multiple ? selectedValue.hasOwnProperty(options[i].value) : options[i].value === selectedValue;
      if (selected !== options[i].selected) {
        options[i].selected = selected;
      }
    }
  }
  var ReactDOMSelect = ReactCompositeComponent.createClass({
    displayName: 'ReactDOMSelect',
    mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],
    propTypes: {
      defaultValue: selectValueType,
      value: selectValueType
    },
    getInitialState: function() {
      return {value: this.props.defaultValue || (this.props.multiple ? [] : '')};
    },
    componentWillMount: function() {
      this._pendingValue = null;
    },
    componentWillReceiveProps: function(nextProps) {
      if (!this.props.multiple && nextProps.multiple) {
        this.setState({value: [this.state.value]});
      } else if (this.props.multiple && !nextProps.multiple) {
        this.setState({value: this.state.value[0]});
      }
    },
    render: function() {
      var props = assign({}, this.props);
      props.onChange = this._handleChange;
      props.value = null;
      return select(props, this.props.children);
    },
    componentDidMount: function() {
      updateOptions(this, LinkedValueUtils.getValue(this));
    },
    componentDidUpdate: function(prevProps) {
      var value = LinkedValueUtils.getValue(this);
      var prevMultiple = !!prevProps.multiple;
      var multiple = !!this.props.multiple;
      if (value != null || prevMultiple !== multiple) {
        updateOptions(this, value);
      }
    },
    _handleChange: function(event) {
      var returnValue;
      var onChange = LinkedValueUtils.getOnChange(this);
      if (onChange) {
        returnValue = onChange.call(this, event);
      }
      var selectedValue;
      if (this.props.multiple) {
        selectedValue = [];
        var options = event.target.options;
        for (var i = 0,
            l = options.length; i < l; i++) {
          if (options[i].selected) {
            selectedValue.push(options[i].value);
          }
        }
      } else {
        selectedValue = event.target.value;
      }
      this._pendingValue = selectedValue;
      ReactUpdates.asap(updateWithPendingValueIfMounted, this);
      return returnValue;
    }
  });
  module.exports = ReactDOMSelect;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDOMTextarea", ["npm:react@0.12.2/lib/AutoFocusMixin", "npm:react@0.12.2/lib/DOMPropertyOperations", "npm:react@0.12.2/lib/LinkedValueUtils", "npm:react@0.12.2/lib/ReactBrowserComponentMixin", "npm:react@0.12.2/lib/ReactCompositeComponent", "npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/ReactDOM", "npm:react@0.12.2/lib/ReactUpdates", "npm:react@0.12.2/lib/Object.assign", "npm:react@0.12.2/lib/invariant", "npm:react@0.12.2/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var AutoFocusMixin = require("npm:react@0.12.2/lib/AutoFocusMixin");
    var DOMPropertyOperations = require("npm:react@0.12.2/lib/DOMPropertyOperations");
    var LinkedValueUtils = require("npm:react@0.12.2/lib/LinkedValueUtils");
    var ReactBrowserComponentMixin = require("npm:react@0.12.2/lib/ReactBrowserComponentMixin");
    var ReactCompositeComponent = require("npm:react@0.12.2/lib/ReactCompositeComponent");
    var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
    var ReactDOM = require("npm:react@0.12.2/lib/ReactDOM");
    var ReactUpdates = require("npm:react@0.12.2/lib/ReactUpdates");
    var assign = require("npm:react@0.12.2/lib/Object.assign");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var warning = require("npm:react@0.12.2/lib/warning");
    var textarea = ReactElement.createFactory(ReactDOM.textarea.type);
    function forceUpdateIfMounted() {
      if (this.isMounted()) {
        this.forceUpdate();
      }
    }
    var ReactDOMTextarea = ReactCompositeComponent.createClass({
      displayName: 'ReactDOMTextarea',
      mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],
      getInitialState: function() {
        var defaultValue = this.props.defaultValue;
        var children = this.props.children;
        if (children != null) {
          if ("production" !== process.env.NODE_ENV) {
            ("production" !== process.env.NODE_ENV ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : null);
          }
          ("production" !== process.env.NODE_ENV ? invariant(defaultValue == null, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : invariant(defaultValue == null));
          if (Array.isArray(children)) {
            ("production" !== process.env.NODE_ENV ? invariant(children.length <= 1, '<textarea> can only have at most one child.') : invariant(children.length <= 1));
            children = children[0];
          }
          defaultValue = '' + children;
        }
        if (defaultValue == null) {
          defaultValue = '';
        }
        var value = LinkedValueUtils.getValue(this);
        return {initialValue: '' + (value != null ? value : defaultValue)};
      },
      render: function() {
        var props = assign({}, this.props);
        ("production" !== process.env.NODE_ENV ? invariant(props.dangerouslySetInnerHTML == null, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : invariant(props.dangerouslySetInnerHTML == null));
        props.defaultValue = null;
        props.value = null;
        props.onChange = this._handleChange;
        return textarea(props, this.state.initialValue);
      },
      componentDidUpdate: function(prevProps, prevState, prevContext) {
        var value = LinkedValueUtils.getValue(this);
        if (value != null) {
          var rootNode = this.getDOMNode();
          DOMPropertyOperations.setValueForProperty(rootNode, 'value', '' + value);
        }
      },
      _handleChange: function(event) {
        var returnValue;
        var onChange = LinkedValueUtils.getOnChange(this);
        if (onChange) {
          returnValue = onChange.call(this, event);
        }
        ReactUpdates.asap(forceUpdateIfMounted, this);
        return returnValue;
      }
    });
    module.exports = ReactDOMTextarea;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/EventListener", ["npm:react@0.12.2/lib/emptyFunction", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var emptyFunction = require("npm:react@0.12.2/lib/emptyFunction");
    var EventListener = {
      listen: function(target, eventType, callback) {
        if (target.addEventListener) {
          target.addEventListener(eventType, callback, false);
          return {remove: function() {
              target.removeEventListener(eventType, callback, false);
            }};
        } else if (target.attachEvent) {
          target.attachEvent('on' + eventType, callback);
          return {remove: function() {
              target.detachEvent('on' + eventType, callback);
            }};
        }
      },
      capture: function(target, eventType, callback) {
        if (!target.addEventListener) {
          if ("production" !== process.env.NODE_ENV) {
            console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
          }
          return {remove: emptyFunction};
        } else {
          target.addEventListener(eventType, callback, true);
          return {remove: function() {
              target.removeEventListener(eventType, callback, true);
            }};
        }
      },
      registerDefault: function() {}
    };
    module.exports = EventListener;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactInjection", ["npm:react@0.12.2/lib/DOMProperty", "npm:react@0.12.2/lib/EventPluginHub", "npm:react@0.12.2/lib/ReactComponent", "npm:react@0.12.2/lib/ReactCompositeComponent", "npm:react@0.12.2/lib/ReactEmptyComponent", "npm:react@0.12.2/lib/ReactBrowserEventEmitter", "npm:react@0.12.2/lib/ReactNativeComponent", "npm:react@0.12.2/lib/ReactPerf", "npm:react@0.12.2/lib/ReactRootIndex", "npm:react@0.12.2/lib/ReactUpdates"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var DOMProperty = require("npm:react@0.12.2/lib/DOMProperty");
  var EventPluginHub = require("npm:react@0.12.2/lib/EventPluginHub");
  var ReactComponent = require("npm:react@0.12.2/lib/ReactComponent");
  var ReactCompositeComponent = require("npm:react@0.12.2/lib/ReactCompositeComponent");
  var ReactEmptyComponent = require("npm:react@0.12.2/lib/ReactEmptyComponent");
  var ReactBrowserEventEmitter = require("npm:react@0.12.2/lib/ReactBrowserEventEmitter");
  var ReactNativeComponent = require("npm:react@0.12.2/lib/ReactNativeComponent");
  var ReactPerf = require("npm:react@0.12.2/lib/ReactPerf");
  var ReactRootIndex = require("npm:react@0.12.2/lib/ReactRootIndex");
  var ReactUpdates = require("npm:react@0.12.2/lib/ReactUpdates");
  var ReactInjection = {
    Component: ReactComponent.injection,
    CompositeComponent: ReactCompositeComponent.injection,
    DOMProperty: DOMProperty.injection,
    EmptyComponent: ReactEmptyComponent.injection,
    EventPluginHub: EventPluginHub.injection,
    EventEmitter: ReactBrowserEventEmitter.injection,
    NativeComponent: ReactNativeComponent.injection,
    Perf: ReactPerf.injection,
    RootIndex: ReactRootIndex.injection,
    Updates: ReactUpdates.injection
  };
  module.exports = ReactInjection;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/shallowEqual", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  function shallowEqual(objA, objB) {
    if (objA === objB) {
      return true;
    }
    var key;
    for (key in objA) {
      if (objA.hasOwnProperty(key) && (!objB.hasOwnProperty(key) || objA[key] !== objB[key])) {
        return false;
      }
    }
    for (key in objB) {
      if (objB.hasOwnProperty(key) && !objA.hasOwnProperty(key)) {
        return false;
      }
    }
    return true;
  }
  module.exports = shallowEqual;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ServerReactRootIndex", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var GLOBAL_MOUNT_POINT_MAX = Math.pow(2, 53);
  var ServerReactRootIndex = {createReactRootIndex: function() {
      return Math.ceil(Math.random() * GLOBAL_MOUNT_POINT_MAX);
    }};
  module.exports = ServerReactRootIndex;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SyntheticClipboardEvent", ["npm:react@0.12.2/lib/SyntheticEvent"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var SyntheticEvent = require("npm:react@0.12.2/lib/SyntheticEvent");
  var ClipboardEventInterface = {clipboardData: function(event) {
      return ('clipboardData' in event ? event.clipboardData : window.clipboardData);
    }};
  function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);
  module.exports = SyntheticClipboardEvent;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SyntheticFocusEvent", ["npm:react@0.12.2/lib/SyntheticUIEvent"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var SyntheticUIEvent = require("npm:react@0.12.2/lib/SyntheticUIEvent");
  var FocusEventInterface = {relatedTarget: null};
  function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);
  module.exports = SyntheticFocusEvent;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/getEventCharCode", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  function getEventCharCode(nativeEvent) {
    var charCode;
    var keyCode = nativeEvent.keyCode;
    if ('charCode' in nativeEvent) {
      charCode = nativeEvent.charCode;
      if (charCode === 0 && keyCode === 13) {
        charCode = 13;
      }
    } else {
      charCode = keyCode;
    }
    if (charCode >= 32 || charCode === 13) {
      return charCode;
    }
    return 0;
  }
  module.exports = getEventCharCode;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/getEventKey", ["npm:react@0.12.2/lib/getEventCharCode"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var getEventCharCode = require("npm:react@0.12.2/lib/getEventCharCode");
  var normalizeKey = {
    'Esc': 'Escape',
    'Spacebar': ' ',
    'Left': 'ArrowLeft',
    'Up': 'ArrowUp',
    'Right': 'ArrowRight',
    'Down': 'ArrowDown',
    'Del': 'Delete',
    'Win': 'OS',
    'Menu': 'ContextMenu',
    'Apps': 'ContextMenu',
    'Scroll': 'ScrollLock',
    'MozPrintableKey': 'Unidentified'
  };
  var translateToKey = {
    8: 'Backspace',
    9: 'Tab',
    12: 'Clear',
    13: 'Enter',
    16: 'Shift',
    17: 'Control',
    18: 'Alt',
    19: 'Pause',
    20: 'CapsLock',
    27: 'Escape',
    32: ' ',
    33: 'PageUp',
    34: 'PageDown',
    35: 'End',
    36: 'Home',
    37: 'ArrowLeft',
    38: 'ArrowUp',
    39: 'ArrowRight',
    40: 'ArrowDown',
    45: 'Insert',
    46: 'Delete',
    112: 'F1',
    113: 'F2',
    114: 'F3',
    115: 'F4',
    116: 'F5',
    117: 'F6',
    118: 'F7',
    119: 'F8',
    120: 'F9',
    121: 'F10',
    122: 'F11',
    123: 'F12',
    144: 'NumLock',
    145: 'ScrollLock',
    224: 'Meta'
  };
  function getEventKey(nativeEvent) {
    if (nativeEvent.key) {
      var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
      if (key !== 'Unidentified') {
        return key;
      }
    }
    if (nativeEvent.type === 'keypress') {
      var charCode = getEventCharCode(nativeEvent);
      return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
    }
    if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
      return translateToKey[nativeEvent.keyCode] || 'Unidentified';
    }
    return '';
  }
  module.exports = getEventKey;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SyntheticDragEvent", ["npm:react@0.12.2/lib/SyntheticMouseEvent"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var SyntheticMouseEvent = require("npm:react@0.12.2/lib/SyntheticMouseEvent");
  var DragEventInterface = {dataTransfer: null};
  function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);
  module.exports = SyntheticDragEvent;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SyntheticTouchEvent", ["npm:react@0.12.2/lib/SyntheticUIEvent", "npm:react@0.12.2/lib/getEventModifierState"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var SyntheticUIEvent = require("npm:react@0.12.2/lib/SyntheticUIEvent");
  var getEventModifierState = require("npm:react@0.12.2/lib/getEventModifierState");
  var TouchEventInterface = {
    touches: null,
    targetTouches: null,
    changedTouches: null,
    altKey: null,
    metaKey: null,
    ctrlKey: null,
    shiftKey: null,
    getModifierState: getEventModifierState
  };
  function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);
  module.exports = SyntheticTouchEvent;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SyntheticWheelEvent", ["npm:react@0.12.2/lib/SyntheticMouseEvent"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var SyntheticMouseEvent = require("npm:react@0.12.2/lib/SyntheticMouseEvent");
  var WheelEventInterface = {
    deltaX: function(event) {
      return ('deltaX' in event ? event.deltaX : 'wheelDeltaX' in event ? -event.wheelDeltaX : 0);
    },
    deltaY: function(event) {
      return ('deltaY' in event ? event.deltaY : 'wheelDeltaY' in event ? -event.wheelDeltaY : 'wheelDelta' in event ? -event.wheelDelta : 0);
    },
    deltaZ: null,
    deltaMode: null
  };
  function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);
  module.exports = SyntheticWheelEvent;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SVGDOMPropertyConfig", ["npm:react@0.12.2/lib/DOMProperty"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var DOMProperty = require("npm:react@0.12.2/lib/DOMProperty");
  var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
  var SVGDOMPropertyConfig = {
    Properties: {
      cx: MUST_USE_ATTRIBUTE,
      cy: MUST_USE_ATTRIBUTE,
      d: MUST_USE_ATTRIBUTE,
      dx: MUST_USE_ATTRIBUTE,
      dy: MUST_USE_ATTRIBUTE,
      fill: MUST_USE_ATTRIBUTE,
      fillOpacity: MUST_USE_ATTRIBUTE,
      fontFamily: MUST_USE_ATTRIBUTE,
      fontSize: MUST_USE_ATTRIBUTE,
      fx: MUST_USE_ATTRIBUTE,
      fy: MUST_USE_ATTRIBUTE,
      gradientTransform: MUST_USE_ATTRIBUTE,
      gradientUnits: MUST_USE_ATTRIBUTE,
      markerEnd: MUST_USE_ATTRIBUTE,
      markerMid: MUST_USE_ATTRIBUTE,
      markerStart: MUST_USE_ATTRIBUTE,
      offset: MUST_USE_ATTRIBUTE,
      opacity: MUST_USE_ATTRIBUTE,
      patternContentUnits: MUST_USE_ATTRIBUTE,
      patternUnits: MUST_USE_ATTRIBUTE,
      points: MUST_USE_ATTRIBUTE,
      preserveAspectRatio: MUST_USE_ATTRIBUTE,
      r: MUST_USE_ATTRIBUTE,
      rx: MUST_USE_ATTRIBUTE,
      ry: MUST_USE_ATTRIBUTE,
      spreadMethod: MUST_USE_ATTRIBUTE,
      stopColor: MUST_USE_ATTRIBUTE,
      stopOpacity: MUST_USE_ATTRIBUTE,
      stroke: MUST_USE_ATTRIBUTE,
      strokeDasharray: MUST_USE_ATTRIBUTE,
      strokeLinecap: MUST_USE_ATTRIBUTE,
      strokeOpacity: MUST_USE_ATTRIBUTE,
      strokeWidth: MUST_USE_ATTRIBUTE,
      textAnchor: MUST_USE_ATTRIBUTE,
      transform: MUST_USE_ATTRIBUTE,
      version: MUST_USE_ATTRIBUTE,
      viewBox: MUST_USE_ATTRIBUTE,
      x1: MUST_USE_ATTRIBUTE,
      x2: MUST_USE_ATTRIBUTE,
      x: MUST_USE_ATTRIBUTE,
      y1: MUST_USE_ATTRIBUTE,
      y2: MUST_USE_ATTRIBUTE,
      y: MUST_USE_ATTRIBUTE
    },
    DOMAttributeNames: {
      fillOpacity: 'fill-opacity',
      fontFamily: 'font-family',
      fontSize: 'font-size',
      gradientTransform: 'gradientTransform',
      gradientUnits: 'gradientUnits',
      markerEnd: 'marker-end',
      markerMid: 'marker-mid',
      markerStart: 'marker-start',
      patternContentUnits: 'patternContentUnits',
      patternUnits: 'patternUnits',
      preserveAspectRatio: 'preserveAspectRatio',
      spreadMethod: 'spreadMethod',
      stopColor: 'stop-color',
      stopOpacity: 'stop-opacity',
      strokeDasharray: 'stroke-dasharray',
      strokeLinecap: 'stroke-linecap',
      strokeOpacity: 'stroke-opacity',
      strokeWidth: 'stroke-width',
      textAnchor: 'text-anchor',
      viewBox: 'viewBox'
    }
  };
  module.exports = SVGDOMPropertyConfig;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/createFullPageComponent", ["npm:react@0.12.2/lib/ReactCompositeComponent", "npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactCompositeComponent = require("npm:react@0.12.2/lib/ReactCompositeComponent");
    var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    function createFullPageComponent(tag) {
      var elementFactory = ReactElement.createFactory(tag);
      var FullPageComponent = ReactCompositeComponent.createClass({
        displayName: 'ReactFullPageComponent' + tag,
        componentWillUnmount: function() {
          ("production" !== process.env.NODE_ENV ? invariant(false, '%s tried to unmount. Because of cross-browser quirks it is ' + 'impossible to unmount some top-level components (eg <html>, <head>, ' + 'and <body>) reliably and efficiently. To fix this, have a single ' + 'top-level component that never unmounts render these elements.', this.constructor.displayName) : invariant(false));
        },
        render: function() {
          return elementFactory(this.props);
        }
      });
      return FullPageComponent;
    }
    module.exports = createFullPageComponent;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDefaultPerfAnalysis", ["npm:react@0.12.2/lib/Object.assign"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var assign = require("npm:react@0.12.2/lib/Object.assign");
  var DONT_CARE_THRESHOLD = 1.2;
  var DOM_OPERATION_TYPES = {
    'mountImageIntoNode': 'set innerHTML',
    INSERT_MARKUP: 'set innerHTML',
    MOVE_EXISTING: 'move',
    REMOVE_NODE: 'remove',
    TEXT_CONTENT: 'set textContent',
    'updatePropertyByID': 'update attribute',
    'deletePropertyByID': 'delete attribute',
    'updateStylesByID': 'update styles',
    'updateInnerHTMLByID': 'set innerHTML',
    'dangerouslyReplaceNodeWithMarkupByID': 'replace'
  };
  function getTotalTime(measurements) {
    var totalTime = 0;
    for (var i = 0; i < measurements.length; i++) {
      var measurement = measurements[i];
      totalTime += measurement.totalTime;
    }
    return totalTime;
  }
  function getDOMSummary(measurements) {
    var items = [];
    for (var i = 0; i < measurements.length; i++) {
      var measurement = measurements[i];
      var id;
      for (id in measurement.writes) {
        measurement.writes[id].forEach(function(write) {
          items.push({
            id: id,
            type: DOM_OPERATION_TYPES[write.type] || write.type,
            args: write.args
          });
        });
      }
    }
    return items;
  }
  function getExclusiveSummary(measurements) {
    var candidates = {};
    var displayName;
    for (var i = 0; i < measurements.length; i++) {
      var measurement = measurements[i];
      var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
      for (var id in allIDs) {
        displayName = measurement.displayNames[id].current;
        candidates[displayName] = candidates[displayName] || {
          componentName: displayName,
          inclusive: 0,
          exclusive: 0,
          render: 0,
          count: 0
        };
        if (measurement.render[id]) {
          candidates[displayName].render += measurement.render[id];
        }
        if (measurement.exclusive[id]) {
          candidates[displayName].exclusive += measurement.exclusive[id];
        }
        if (measurement.inclusive[id]) {
          candidates[displayName].inclusive += measurement.inclusive[id];
        }
        if (measurement.counts[id]) {
          candidates[displayName].count += measurement.counts[id];
        }
      }
    }
    var arr = [];
    for (displayName in candidates) {
      if (candidates[displayName].exclusive >= DONT_CARE_THRESHOLD) {
        arr.push(candidates[displayName]);
      }
    }
    arr.sort(function(a, b) {
      return b.exclusive - a.exclusive;
    });
    return arr;
  }
  function getInclusiveSummary(measurements, onlyClean) {
    var candidates = {};
    var inclusiveKey;
    for (var i = 0; i < measurements.length; i++) {
      var measurement = measurements[i];
      var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
      var cleanComponents;
      if (onlyClean) {
        cleanComponents = getUnchangedComponents(measurement);
      }
      for (var id in allIDs) {
        if (onlyClean && !cleanComponents[id]) {
          continue;
        }
        var displayName = measurement.displayNames[id];
        inclusiveKey = displayName.owner + ' > ' + displayName.current;
        candidates[inclusiveKey] = candidates[inclusiveKey] || {
          componentName: inclusiveKey,
          time: 0,
          count: 0
        };
        if (measurement.inclusive[id]) {
          candidates[inclusiveKey].time += measurement.inclusive[id];
        }
        if (measurement.counts[id]) {
          candidates[inclusiveKey].count += measurement.counts[id];
        }
      }
    }
    var arr = [];
    for (inclusiveKey in candidates) {
      if (candidates[inclusiveKey].time >= DONT_CARE_THRESHOLD) {
        arr.push(candidates[inclusiveKey]);
      }
    }
    arr.sort(function(a, b) {
      return b.time - a.time;
    });
    return arr;
  }
  function getUnchangedComponents(measurement) {
    var cleanComponents = {};
    var dirtyLeafIDs = Object.keys(measurement.writes);
    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
    for (var id in allIDs) {
      var isDirty = false;
      for (var i = 0; i < dirtyLeafIDs.length; i++) {
        if (dirtyLeafIDs[i].indexOf(id) === 0) {
          isDirty = true;
          break;
        }
      }
      if (!isDirty && measurement.counts[id] > 0) {
        cleanComponents[id] = true;
      }
    }
    return cleanComponents;
  }
  var ReactDefaultPerfAnalysis = {
    getExclusiveSummary: getExclusiveSummary,
    getInclusiveSummary: getInclusiveSummary,
    getDOMSummary: getDOMSummary,
    getTotalTime: getTotalTime
  };
  module.exports = ReactDefaultPerfAnalysis;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/performance", ["npm:react@0.12.2/lib/ExecutionEnvironment"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var ExecutionEnvironment = require("npm:react@0.12.2/lib/ExecutionEnvironment");
  var performance;
  if (ExecutionEnvironment.canUseDOM) {
    performance = window.performance || window.msPerformance || window.webkitPerformance;
  }
  module.exports = performance || {};
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactServerRenderingTransaction", ["npm:react@0.12.2/lib/PooledClass", "npm:react@0.12.2/lib/CallbackQueue", "npm:react@0.12.2/lib/ReactPutListenerQueue", "npm:react@0.12.2/lib/Transaction", "npm:react@0.12.2/lib/Object.assign", "npm:react@0.12.2/lib/emptyFunction"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var PooledClass = require("npm:react@0.12.2/lib/PooledClass");
  var CallbackQueue = require("npm:react@0.12.2/lib/CallbackQueue");
  var ReactPutListenerQueue = require("npm:react@0.12.2/lib/ReactPutListenerQueue");
  var Transaction = require("npm:react@0.12.2/lib/Transaction");
  var assign = require("npm:react@0.12.2/lib/Object.assign");
  var emptyFunction = require("npm:react@0.12.2/lib/emptyFunction");
  var ON_DOM_READY_QUEUEING = {
    initialize: function() {
      this.reactMountReady.reset();
    },
    close: emptyFunction
  };
  var PUT_LISTENER_QUEUEING = {
    initialize: function() {
      this.putListenerQueue.reset();
    },
    close: emptyFunction
  };
  var TRANSACTION_WRAPPERS = [PUT_LISTENER_QUEUEING, ON_DOM_READY_QUEUEING];
  function ReactServerRenderingTransaction(renderToStaticMarkup) {
    this.reinitializeTransaction();
    this.renderToStaticMarkup = renderToStaticMarkup;
    this.reactMountReady = CallbackQueue.getPooled(null);
    this.putListenerQueue = ReactPutListenerQueue.getPooled();
  }
  var Mixin = {
    getTransactionWrappers: function() {
      return TRANSACTION_WRAPPERS;
    },
    getReactMountReady: function() {
      return this.reactMountReady;
    },
    getPutListenerQueue: function() {
      return this.putListenerQueue;
    },
    destructor: function() {
      CallbackQueue.release(this.reactMountReady);
      this.reactMountReady = null;
      ReactPutListenerQueue.release(this.putListenerQueue);
      this.putListenerQueue = null;
    }
  };
  assign(ReactServerRenderingTransaction.prototype, Transaction.Mixin, Mixin);
  PooledClass.addPoolingTo(ReactServerRenderingTransaction);
  module.exports = ReactServerRenderingTransaction;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/onlyChild", ["npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    function onlyChild(children) {
      ("production" !== process.env.NODE_ENV ? invariant(ReactElement.isValidElement(children), 'onlyChild must be passed a children with exactly one child.') : invariant(ReactElement.isValidElement(children)));
      return children;
    }
    module.exports = onlyChild;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("javascripts/info-pane", ["npm:react@0.12.2"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var React = require("npm:react@0.12.2");
  var InfoPane = React.createClass({
    displayName: "InfoPane",
    getInitialState: function() {
      return {
        nodes: [],
        links: []
      };
    },
    _find_link: function(link_id) {
      var links = this.props.links.filter(function(link) {
        if (link.key == link_id) {
          return true;
        }
        return false;
      });
      return links[0];
    },
    _find_node: function(node_id) {
      var links = this.props.nodes.filter(function(node) {
        if (node.key == node_id) {
          return true;
        }
        return false;
      });
      return links[0];
    },
    _linked_node: function(link_id) {
      var link = this._find_link(link_id);
      var node_id = link.targetNode;
      var node = this._find_node(node_id);
      return node;
    },
    render: function() {
      var self = this;
      var nodes = self.props.nodes.map(function(_node) {
        var infoString = _node.infoString();
        var x = _node.x;
        var y = _node.y;
        var title = _node.title;
        return (React.createElement("div", {className: "nodePanel"}, React.createElement("div", {
          id: "info-node-{node.key}",
          className: "node-key"
        }, React.createElement("span", {className: "node-name"}, title, " "), "", React.createElement("span", {className: "dimensions"}, "@(", React.createElement("span", {className: "node-location-x"}, x), "x", React.createElement("span", {className: "node-location-y"}, y), ")"), "", infoString)));
      });
      return (React.createElement("div", {className: "info-pane"}, nodes));
    }
  });
  module.exports = InfoPane;
  global.define = __define;
  return module.exports;
});



System.register("npm:loglevel@1.2.0/lib/loglevel", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(root, definition) {
    if (typeof module === 'object' && module.exports && typeof require === 'function') {
      module.exports = definition();
    } else if (typeof define === 'function' && typeof define.amd === 'object') {
      define(definition);
    } else {
      root.log = definition();
    }
  }(this, function() {
    var self = {};
    var noop = function() {};
    var undefinedType = "undefined";
    function realMethod(methodName) {
      if (typeof console === undefinedType) {
        return false;
      } else if (console[methodName] !== undefined) {
        return bindMethod(console, methodName);
      } else if (console.log !== undefined) {
        return bindMethod(console, 'log');
      } else {
        return noop;
      }
    }
    function bindMethod(obj, methodName) {
      var method = obj[methodName];
      if (typeof method.bind === 'function') {
        return method.bind(obj);
      } else {
        try {
          return Function.prototype.bind.call(method, obj);
        } catch (e) {
          return function() {
            return Function.prototype.apply.apply(method, [obj, arguments]);
          };
        }
      }
    }
    function enableLoggingWhenConsoleArrives(methodName, level) {
      return function() {
        if (typeof console !== undefinedType) {
          replaceLoggingMethods(level);
          self[methodName].apply(self, arguments);
        }
      };
    }
    var logMethods = ["trace", "debug", "info", "warn", "error"];
    function replaceLoggingMethods(level) {
      for (var i = 0; i < logMethods.length; i++) {
        var methodName = logMethods[i];
        self[methodName] = (i < level) ? noop : self.methodFactory(methodName, level);
      }
    }
    function persistLevelIfPossible(levelNum) {
      var levelName = (logMethods[levelNum] || 'silent').toUpperCase();
      try {
        window.localStorage['loglevel'] = levelName;
        return ;
      } catch (ignore) {}
      try {
        window.document.cookie = "loglevel=" + levelName + ";";
      } catch (ignore) {}
    }
    function loadPersistedLevel() {
      var storedLevel;
      try {
        storedLevel = window.localStorage['loglevel'];
      } catch (ignore) {}
      if (typeof storedLevel === undefinedType) {
        try {
          storedLevel = /loglevel=([^;]+)/.exec(window.document.cookie)[1];
        } catch (ignore) {}
      }
      if (self.levels[storedLevel] === undefined) {
        storedLevel = "WARN";
      }
      self.setLevel(self.levels[storedLevel]);
    }
    self.levels = {
      "TRACE": 0,
      "DEBUG": 1,
      "INFO": 2,
      "WARN": 3,
      "ERROR": 4,
      "SILENT": 5
    };
    self.methodFactory = function(methodName, level) {
      return realMethod(methodName) || enableLoggingWhenConsoleArrives(methodName, level);
    };
    self.setLevel = function(level) {
      if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
        level = self.levels[level.toUpperCase()];
      }
      if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
        persistLevelIfPossible(level);
        replaceLoggingMethods(level);
        if (typeof console === undefinedType && level < self.levels.SILENT) {
          return "No console available for logging";
        }
      } else {
        throw "log.setLevel() called with invalid level: " + level;
      }
    };
    self.enableAll = function() {
      self.setLevel(self.levels.TRACE);
    };
    self.disableAll = function() {
      self.setLevel(self.levels.SILENT);
    };
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    self.noConflict = function() {
      if (typeof window !== undefinedType && window.log === self) {
        window.log = _log;
      }
      return self;
    };
    loadPersistedLevel();
    return self;
  }));
  global.define = __define;
  return module.exports;
});



(function() {
function define(){};  define.amd = {};
(function(global, factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    module.exports = global.document ? factory(global, true) : function(w) {
      if (!w.document) {
        throw new Error("jQuery requires a window with a document");
      }
      return factory(w);
    };
  } else {
    factory(global);
  }
}(typeof window !== "undefined" ? window : this, function(window, noGlobal) {
  var arr = [];
  var slice = arr.slice;
  var concat = arr.concat;
  var push = arr.push;
  var indexOf = arr.indexOf;
  var class2type = {};
  var toString = class2type.toString;
  var hasOwn = class2type.hasOwnProperty;
  var support = {};
  var document = window.document,
      version = "2.1.3",
      jQuery = function(selector, context) {
        return new jQuery.fn.init(selector, context);
      },
      rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
      rmsPrefix = /^-ms-/,
      rdashAlpha = /-([\da-z])/gi,
      fcamelCase = function(all, letter) {
        return letter.toUpperCase();
      };
  jQuery.fn = jQuery.prototype = {
    jquery: version,
    constructor: jQuery,
    selector: "",
    length: 0,
    toArray: function() {
      return slice.call(this);
    },
    get: function(num) {
      return num != null ? (num < 0 ? this[num + this.length] : this[num]) : slice.call(this);
    },
    pushStack: function(elems) {
      var ret = jQuery.merge(this.constructor(), elems);
      ret.prevObject = this;
      ret.context = this.context;
      return ret;
    },
    each: function(callback, args) {
      return jQuery.each(this, callback, args);
    },
    map: function(callback) {
      return this.pushStack(jQuery.map(this, function(elem, i) {
        return callback.call(elem, i, elem);
      }));
    },
    slice: function() {
      return this.pushStack(slice.apply(this, arguments));
    },
    first: function() {
      return this.eq(0);
    },
    last: function() {
      return this.eq(-1);
    },
    eq: function(i) {
      var len = this.length,
          j = +i + (i < 0 ? len : 0);
      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
    },
    end: function() {
      return this.prevObject || this.constructor(null);
    },
    push: push,
    sort: arr.sort,
    splice: arr.splice
  };
  jQuery.extend = jQuery.fn.extend = function() {
    var options,
        name,
        src,
        copy,
        copyIsArray,
        clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;
    if (typeof target === "boolean") {
      deep = target;
      target = arguments[i] || {};
      i++;
    }
    if (typeof target !== "object" && !jQuery.isFunction(target)) {
      target = {};
    }
    if (i === length) {
      target = this;
      i--;
    }
    for (; i < length; i++) {
      if ((options = arguments[i]) != null) {
        for (name in options) {
          src = target[name];
          copy = options[name];
          if (target === copy) {
            continue;
          }
          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && jQuery.isArray(src) ? src : [];
            } else {
              clone = src && jQuery.isPlainObject(src) ? src : {};
            }
            target[name] = jQuery.extend(deep, clone, copy);
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    }
    return target;
  };
  jQuery.extend({
    expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
    isReady: true,
    error: function(msg) {
      throw new Error(msg);
    },
    noop: function() {},
    isFunction: function(obj) {
      return jQuery.type(obj) === "function";
    },
    isArray: Array.isArray,
    isWindow: function(obj) {
      return obj != null && obj === obj.window;
    },
    isNumeric: function(obj) {
      return !jQuery.isArray(obj) && (obj - parseFloat(obj) + 1) >= 0;
    },
    isPlainObject: function(obj) {
      if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
        return false;
      }
      if (obj.constructor && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
        return false;
      }
      return true;
    },
    isEmptyObject: function(obj) {
      var name;
      for (name in obj) {
        return false;
      }
      return true;
    },
    type: function(obj) {
      if (obj == null) {
        return obj + "";
      }
      return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
    },
    globalEval: function(code) {
      var script,
          indirect = eval;
      code = jQuery.trim(code);
      if (code) {
        if (code.indexOf("use strict") === 1) {
          script = document.createElement("script");
          script.text = code;
          document.head.appendChild(script).parentNode.removeChild(script);
        } else {
          indirect(code);
        }
      }
    },
    camelCase: function(string) {
      return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
    },
    nodeName: function(elem, name) {
      return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    },
    each: function(obj, callback, args) {
      var value,
          i = 0,
          length = obj.length,
          isArray = isArraylike(obj);
      if (args) {
        if (isArray) {
          for (; i < length; i++) {
            value = callback.apply(obj[i], args);
            if (value === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            value = callback.apply(obj[i], args);
            if (value === false) {
              break;
            }
          }
        }
      } else {
        if (isArray) {
          for (; i < length; i++) {
            value = callback.call(obj[i], i, obj[i]);
            if (value === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            value = callback.call(obj[i], i, obj[i]);
            if (value === false) {
              break;
            }
          }
        }
      }
      return obj;
    },
    trim: function(text) {
      return text == null ? "" : (text + "").replace(rtrim, "");
    },
    makeArray: function(arr, results) {
      var ret = results || [];
      if (arr != null) {
        if (isArraylike(Object(arr))) {
          jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
        } else {
          push.call(ret, arr);
        }
      }
      return ret;
    },
    inArray: function(elem, arr, i) {
      return arr == null ? -1 : indexOf.call(arr, elem, i);
    },
    merge: function(first, second) {
      var len = +second.length,
          j = 0,
          i = first.length;
      for (; j < len; j++) {
        first[i++] = second[j];
      }
      first.length = i;
      return first;
    },
    grep: function(elems, callback, invert) {
      var callbackInverse,
          matches = [],
          i = 0,
          length = elems.length,
          callbackExpect = !invert;
      for (; i < length; i++) {
        callbackInverse = !callback(elems[i], i);
        if (callbackInverse !== callbackExpect) {
          matches.push(elems[i]);
        }
      }
      return matches;
    },
    map: function(elems, callback, arg) {
      var value,
          i = 0,
          length = elems.length,
          isArray = isArraylike(elems),
          ret = [];
      if (isArray) {
        for (; i < length; i++) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret.push(value);
          }
        }
      } else {
        for (i in elems) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret.push(value);
          }
        }
      }
      return concat.apply([], ret);
    },
    guid: 1,
    proxy: function(fn, context) {
      var tmp,
          args,
          proxy;
      if (typeof context === "string") {
        tmp = fn[context];
        context = fn;
        fn = tmp;
      }
      if (!jQuery.isFunction(fn)) {
        return undefined;
      }
      args = slice.call(arguments, 2);
      proxy = function() {
        return fn.apply(context || this, args.concat(slice.call(arguments)));
      };
      proxy.guid = fn.guid = fn.guid || jQuery.guid++;
      return proxy;
    },
    now: Date.now,
    support: support
  });
  jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
    class2type["[object " + name + "]"] = name.toLowerCase();
  });
  function isArraylike(obj) {
    var length = obj.length,
        type = jQuery.type(obj);
    if (type === "function" || jQuery.isWindow(obj)) {
      return false;
    }
    if (obj.nodeType === 1 && length) {
      return true;
    }
    return type === "array" || length === 0 || typeof length === "number" && length > 0 && (length - 1) in obj;
  }
  var Sizzle = (function(window) {
    var i,
        support,
        Expr,
        getText,
        isXML,
        tokenize,
        compile,
        select,
        outermostContext,
        sortInput,
        hasDuplicate,
        setDocument,
        document,
        docElem,
        documentIsHTML,
        rbuggyQSA,
        rbuggyMatches,
        matches,
        contains,
        expando = "sizzle" + 1 * new Date(),
        preferredDoc = window.document,
        dirruns = 0,
        done = 0,
        classCache = createCache(),
        tokenCache = createCache(),
        compilerCache = createCache(),
        sortOrder = function(a, b) {
          if (a === b) {
            hasDuplicate = true;
          }
          return 0;
        },
        MAX_NEGATIVE = 1 << 31,
        hasOwn = ({}).hasOwnProperty,
        arr = [],
        pop = arr.pop,
        push_native = arr.push,
        push = arr.push,
        slice = arr.slice,
        indexOf = function(list, elem) {
          var i = 0,
              len = list.length;
          for (; i < len; i++) {
            if (list[i] === elem) {
              return i;
            }
          }
          return -1;
        },
        booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
        whitespace = "[\\x20\\t\\r\\n\\f]",
        characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
        identifier = characterEncoding.replace("w", "w#"),
        attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
        pseudos = ":(" + characterEncoding + ")(?:\\((" + "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + ".*" + ")\\)|)",
        rwhitespace = new RegExp(whitespace + "+", "g"),
        rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
        rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
        rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
        rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
        rpseudo = new RegExp(pseudos),
        ridentifier = new RegExp("^" + identifier + "$"),
        matchExpr = {
          "ID": new RegExp("^#(" + characterEncoding + ")"),
          "CLASS": new RegExp("^\\.(" + characterEncoding + ")"),
          "TAG": new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
          "ATTR": new RegExp("^" + attributes),
          "PSEUDO": new RegExp("^" + pseudos),
          "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
          "bool": new RegExp("^(?:" + booleans + ")$", "i"),
          "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        },
        rinputs = /^(?:input|select|textarea|button)$/i,
        rheader = /^h\d$/i,
        rnative = /^[^{]+\{\s*\[native \w/,
        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
        rsibling = /[+~]/,
        rescape = /'|\\/g,
        runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
        funescape = function(_, escaped, escapedWhitespace) {
          var high = "0x" + escaped - 0x10000;
          return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
        },
        unloadHandler = function() {
          setDocument();
        };
    try {
      push.apply((arr = slice.call(preferredDoc.childNodes)), preferredDoc.childNodes);
      arr[preferredDoc.childNodes.length].nodeType;
    } catch (e) {
      push = {apply: arr.length ? function(target, els) {
          push_native.apply(target, slice.call(els));
        } : function(target, els) {
          var j = target.length,
              i = 0;
          while ((target[j++] = els[i++])) {}
          target.length = j - 1;
        }};
    }
    function Sizzle(selector, context, results, seed) {
      var match,
          elem,
          m,
          nodeType,
          i,
          groups,
          old,
          nid,
          newContext,
          newSelector;
      if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
        setDocument(context);
      }
      context = context || document;
      results = results || [];
      nodeType = context.nodeType;
      if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
        return results;
      }
      if (!seed && documentIsHTML) {
        if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
          if ((m = match[1])) {
            if (nodeType === 9) {
              elem = context.getElementById(m);
              if (elem && elem.parentNode) {
                if (elem.id === m) {
                  results.push(elem);
                  return results;
                }
              } else {
                return results;
              }
            } else {
              if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                results.push(elem);
                return results;
              }
            }
          } else if (match[2]) {
            push.apply(results, context.getElementsByTagName(selector));
            return results;
          } else if ((m = match[3]) && support.getElementsByClassName) {
            push.apply(results, context.getElementsByClassName(m));
            return results;
          }
        }
        if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
          nid = old = expando;
          newContext = context;
          newSelector = nodeType !== 1 && selector;
          if (nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
            groups = tokenize(selector);
            if ((old = context.getAttribute("id"))) {
              nid = old.replace(rescape, "\\$&");
            } else {
              context.setAttribute("id", nid);
            }
            nid = "[id='" + nid + "'] ";
            i = groups.length;
            while (i--) {
              groups[i] = nid + toSelector(groups[i]);
            }
            newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
            newSelector = groups.join(",");
          }
          if (newSelector) {
            try {
              push.apply(results, newContext.querySelectorAll(newSelector));
              return results;
            } catch (qsaError) {} finally {
              if (!old) {
                context.removeAttribute("id");
              }
            }
          }
        }
      }
      return select(selector.replace(rtrim, "$1"), context, results, seed);
    }
    function createCache() {
      var keys = [];
      function cache(key, value) {
        if (keys.push(key + " ") > Expr.cacheLength) {
          delete cache[keys.shift()];
        }
        return (cache[key + " "] = value);
      }
      return cache;
    }
    function markFunction(fn) {
      fn[expando] = true;
      return fn;
    }
    function assert(fn) {
      var div = document.createElement("div");
      try {
        return !!fn(div);
      } catch (e) {
        return false;
      } finally {
        if (div.parentNode) {
          div.parentNode.removeChild(div);
        }
        div = null;
      }
    }
    function addHandle(attrs, handler) {
      var arr = attrs.split("|"),
          i = attrs.length;
      while (i--) {
        Expr.attrHandle[arr[i]] = handler;
      }
    }
    function siblingCheck(a, b) {
      var cur = b && a,
          diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
      if (diff) {
        return diff;
      }
      if (cur) {
        while ((cur = cur.nextSibling)) {
          if (cur === b) {
            return -1;
          }
        }
      }
      return a ? 1 : -1;
    }
    function createInputPseudo(type) {
      return function(elem) {
        var name = elem.nodeName.toLowerCase();
        return name === "input" && elem.type === type;
      };
    }
    function createButtonPseudo(type) {
      return function(elem) {
        var name = elem.nodeName.toLowerCase();
        return (name === "input" || name === "button") && elem.type === type;
      };
    }
    function createPositionalPseudo(fn) {
      return markFunction(function(argument) {
        argument = +argument;
        return markFunction(function(seed, matches) {
          var j,
              matchIndexes = fn([], seed.length, argument),
              i = matchIndexes.length;
          while (i--) {
            if (seed[(j = matchIndexes[i])]) {
              seed[j] = !(matches[j] = seed[j]);
            }
          }
        });
      });
    }
    function testContext(context) {
      return context && typeof context.getElementsByTagName !== "undefined" && context;
    }
    support = Sizzle.support = {};
    isXML = Sizzle.isXML = function(elem) {
      var documentElement = elem && (elem.ownerDocument || elem).documentElement;
      return documentElement ? documentElement.nodeName !== "HTML" : false;
    };
    setDocument = Sizzle.setDocument = function(node) {
      var hasCompare,
          parent,
          doc = node ? node.ownerDocument || node : preferredDoc;
      if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
        return document;
      }
      document = doc;
      docElem = doc.documentElement;
      parent = doc.defaultView;
      if (parent && parent !== parent.top) {
        if (parent.addEventListener) {
          parent.addEventListener("unload", unloadHandler, false);
        } else if (parent.attachEvent) {
          parent.attachEvent("onunload", unloadHandler);
        }
      }
      documentIsHTML = !isXML(doc);
      support.attributes = assert(function(div) {
        div.className = "i";
        return !div.getAttribute("className");
      });
      support.getElementsByTagName = assert(function(div) {
        div.appendChild(doc.createComment(""));
        return !div.getElementsByTagName("*").length;
      });
      support.getElementsByClassName = rnative.test(doc.getElementsByClassName);
      support.getById = assert(function(div) {
        docElem.appendChild(div).id = expando;
        return !doc.getElementsByName || !doc.getElementsByName(expando).length;
      });
      if (support.getById) {
        Expr.find["ID"] = function(id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var m = context.getElementById(id);
            return m && m.parentNode ? [m] : [];
          }
        };
        Expr.filter["ID"] = function(id) {
          var attrId = id.replace(runescape, funescape);
          return function(elem) {
            return elem.getAttribute("id") === attrId;
          };
        };
      } else {
        delete Expr.find["ID"];
        Expr.filter["ID"] = function(id) {
          var attrId = id.replace(runescape, funescape);
          return function(elem) {
            var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
            return node && node.value === attrId;
          };
        };
      }
      Expr.find["TAG"] = support.getElementsByTagName ? function(tag, context) {
        if (typeof context.getElementsByTagName !== "undefined") {
          return context.getElementsByTagName(tag);
        } else if (support.qsa) {
          return context.querySelectorAll(tag);
        }
      } : function(tag, context) {
        var elem,
            tmp = [],
            i = 0,
            results = context.getElementsByTagName(tag);
        if (tag === "*") {
          while ((elem = results[i++])) {
            if (elem.nodeType === 1) {
              tmp.push(elem);
            }
          }
          return tmp;
        }
        return results;
      };
      Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
        if (documentIsHTML) {
          return context.getElementsByClassName(className);
        }
      };
      rbuggyMatches = [];
      rbuggyQSA = [];
      if ((support.qsa = rnative.test(doc.querySelectorAll))) {
        assert(function(div) {
          docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\f]' msallowcapture=''>" + "<option selected=''></option></select>";
          if (div.querySelectorAll("[msallowcapture^='']").length) {
            rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
          }
          if (!div.querySelectorAll("[selected]").length) {
            rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
          }
          if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
            rbuggyQSA.push("~=");
          }
          if (!div.querySelectorAll(":checked").length) {
            rbuggyQSA.push(":checked");
          }
          if (!div.querySelectorAll("a#" + expando + "+*").length) {
            rbuggyQSA.push(".#.+[+~]");
          }
        });
        assert(function(div) {
          var input = doc.createElement("input");
          input.setAttribute("type", "hidden");
          div.appendChild(input).setAttribute("name", "D");
          if (div.querySelectorAll("[name=d]").length) {
            rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
          }
          if (!div.querySelectorAll(":enabled").length) {
            rbuggyQSA.push(":enabled", ":disabled");
          }
          div.querySelectorAll("*,:x");
          rbuggyQSA.push(",.*:");
        });
      }
      if ((support.matchesSelector = rnative.test((matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)))) {
        assert(function(div) {
          support.disconnectedMatch = matches.call(div, "div");
          matches.call(div, "[s!='']:x");
          rbuggyMatches.push("!=", pseudos);
        });
      }
      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
      hasCompare = rnative.test(docElem.compareDocumentPosition);
      contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
        var adown = a.nodeType === 9 ? a.documentElement : a,
            bup = b && b.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
      } : function(a, b) {
        if (b) {
          while ((b = b.parentNode)) {
            if (b === a) {
              return true;
            }
          }
        }
        return false;
      };
      sortOrder = hasCompare ? function(a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
        if (compare) {
          return compare;
        }
        compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
        if (compare & 1 || (!support.sortDetached && b.compareDocumentPosition(a) === compare)) {
          if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
            return -1;
          }
          if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
            return 1;
          }
          return sortInput ? (indexOf(sortInput, a) - indexOf(sortInput, b)) : 0;
        }
        return compare & 4 ? -1 : 1;
      } : function(a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var cur,
            i = 0,
            aup = a.parentNode,
            bup = b.parentNode,
            ap = [a],
            bp = [b];
        if (!aup || !bup) {
          return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? (indexOf(sortInput, a) - indexOf(sortInput, b)) : 0;
        } else if (aup === bup) {
          return siblingCheck(a, b);
        }
        cur = a;
        while ((cur = cur.parentNode)) {
          ap.unshift(cur);
        }
        cur = b;
        while ((cur = cur.parentNode)) {
          bp.unshift(cur);
        }
        while (ap[i] === bp[i]) {
          i++;
        }
        return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
      };
      return doc;
    };
    Sizzle.matches = function(expr, elements) {
      return Sizzle(expr, null, null, elements);
    };
    Sizzle.matchesSelector = function(elem, expr) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      expr = expr.replace(rattributeQuotes, "='$1']");
      if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
        try {
          var ret = matches.call(elem, expr);
          if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
            return ret;
          }
        } catch (e) {}
      }
      return Sizzle(expr, document, null, [elem]).length > 0;
    };
    Sizzle.contains = function(context, elem) {
      if ((context.ownerDocument || context) !== document) {
        setDocument(context);
      }
      return contains(context, elem);
    };
    Sizzle.attr = function(elem, name) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      var fn = Expr.attrHandle[name.toLowerCase()],
          val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
      return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
    };
    Sizzle.error = function(msg) {
      throw new Error("Syntax error, unrecognized expression: " + msg);
    };
    Sizzle.uniqueSort = function(results) {
      var elem,
          duplicates = [],
          j = 0,
          i = 0;
      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable && results.slice(0);
      results.sort(sortOrder);
      if (hasDuplicate) {
        while ((elem = results[i++])) {
          if (elem === results[i]) {
            j = duplicates.push(i);
          }
        }
        while (j--) {
          results.splice(duplicates[j], 1);
        }
      }
      sortInput = null;
      return results;
    };
    getText = Sizzle.getText = function(elem) {
      var node,
          ret = "",
          i = 0,
          nodeType = elem.nodeType;
      if (!nodeType) {
        while ((node = elem[i++])) {
          ret += getText(node);
        }
      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
        if (typeof elem.textContent === "string") {
          return elem.textContent;
        } else {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            ret += getText(elem);
          }
        }
      } else if (nodeType === 3 || nodeType === 4) {
        return elem.nodeValue;
      }
      return ret;
    };
    Expr = Sizzle.selectors = {
      cacheLength: 50,
      createPseudo: markFunction,
      match: matchExpr,
      attrHandle: {},
      find: {},
      relative: {
        ">": {
          dir: "parentNode",
          first: true
        },
        " ": {dir: "parentNode"},
        "+": {
          dir: "previousSibling",
          first: true
        },
        "~": {dir: "previousSibling"}
      },
      preFilter: {
        "ATTR": function(match) {
          match[1] = match[1].replace(runescape, funescape);
          match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
          if (match[2] === "~=") {
            match[3] = " " + match[3] + " ";
          }
          return match.slice(0, 4);
        },
        "CHILD": function(match) {
          match[1] = match[1].toLowerCase();
          if (match[1].slice(0, 3) === "nth") {
            if (!match[3]) {
              Sizzle.error(match[0]);
            }
            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
            match[5] = +((match[7] + match[8]) || match[3] === "odd");
          } else if (match[3]) {
            Sizzle.error(match[0]);
          }
          return match;
        },
        "PSEUDO": function(match) {
          var excess,
              unquoted = !match[6] && match[2];
          if (matchExpr["CHILD"].test(match[0])) {
            return null;
          }
          if (match[3]) {
            match[2] = match[4] || match[5] || "";
          } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
            match[0] = match[0].slice(0, excess);
            match[2] = unquoted.slice(0, excess);
          }
          return match.slice(0, 3);
        }
      },
      filter: {
        "TAG": function(nodeNameSelector) {
          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
          return nodeNameSelector === "*" ? function() {
            return true;
          } : function(elem) {
            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
          };
        },
        "CLASS": function(className) {
          var pattern = classCache[className + " "];
          return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
            return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
          });
        },
        "ATTR": function(name, operator, check) {
          return function(elem) {
            var result = Sizzle.attr(elem, name);
            if (result == null) {
              return operator === "!=";
            }
            if (!operator) {
              return true;
            }
            result += "";
            return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
          };
        },
        "CHILD": function(type, what, argument, first, last) {
          var simple = type.slice(0, 3) !== "nth",
              forward = type.slice(-4) !== "last",
              ofType = what === "of-type";
          return first === 1 && last === 0 ? function(elem) {
            return !!elem.parentNode;
          } : function(elem, context, xml) {
            var cache,
                outerCache,
                node,
                diff,
                nodeIndex,
                start,
                dir = simple !== forward ? "nextSibling" : "previousSibling",
                parent = elem.parentNode,
                name = ofType && elem.nodeName.toLowerCase(),
                useCache = !xml && !ofType;
            if (parent) {
              if (simple) {
                while (dir) {
                  node = elem;
                  while ((node = node[dir])) {
                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                      return false;
                    }
                  }
                  start = dir = type === "only" && !start && "nextSibling";
                }
                return true;
              }
              start = [forward ? parent.firstChild : parent.lastChild];
              if (forward && useCache) {
                outerCache = parent[expando] || (parent[expando] = {});
                cache = outerCache[type] || [];
                nodeIndex = cache[0] === dirruns && cache[1];
                diff = cache[0] === dirruns && cache[2];
                node = nodeIndex && parent.childNodes[nodeIndex];
                while ((node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())) {
                  if (node.nodeType === 1 && ++diff && node === elem) {
                    outerCache[type] = [dirruns, nodeIndex, diff];
                    break;
                  }
                }
              } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                diff = cache[1];
              } else {
                while ((node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())) {
                  if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                    if (useCache) {
                      (node[expando] || (node[expando] = {}))[type] = [dirruns, diff];
                    }
                    if (node === elem) {
                      break;
                    }
                  }
                }
              }
              diff -= last;
              return diff === first || (diff % first === 0 && diff / first >= 0);
            }
          };
        },
        "PSEUDO": function(pseudo, argument) {
          var args,
              fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
          if (fn[expando]) {
            return fn(argument);
          }
          if (fn.length > 1) {
            args = [pseudo, pseudo, "", argument];
            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
              var idx,
                  matched = fn(seed, argument),
                  i = matched.length;
              while (i--) {
                idx = indexOf(seed, matched[i]);
                seed[idx] = !(matches[idx] = matched[i]);
              }
            }) : function(elem) {
              return fn(elem, 0, args);
            };
          }
          return fn;
        }
      },
      pseudos: {
        "not": markFunction(function(selector) {
          var input = [],
              results = [],
              matcher = compile(selector.replace(rtrim, "$1"));
          return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
            var elem,
                unmatched = matcher(seed, null, xml, []),
                i = seed.length;
            while (i--) {
              if ((elem = unmatched[i])) {
                seed[i] = !(matches[i] = elem);
              }
            }
          }) : function(elem, context, xml) {
            input[0] = elem;
            matcher(input, null, xml, results);
            input[0] = null;
            return !results.pop();
          };
        }),
        "has": markFunction(function(selector) {
          return function(elem) {
            return Sizzle(selector, elem).length > 0;
          };
        }),
        "contains": markFunction(function(text) {
          text = text.replace(runescape, funescape);
          return function(elem) {
            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
          };
        }),
        "lang": markFunction(function(lang) {
          if (!ridentifier.test(lang || "")) {
            Sizzle.error("unsupported lang: " + lang);
          }
          lang = lang.replace(runescape, funescape).toLowerCase();
          return function(elem) {
            var elemLang;
            do {
              if ((elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {
                elemLang = elemLang.toLowerCase();
                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
              }
            } while ((elem = elem.parentNode) && elem.nodeType === 1);
            return false;
          };
        }),
        "target": function(elem) {
          var hash = window.location && window.location.hash;
          return hash && hash.slice(1) === elem.id;
        },
        "root": function(elem) {
          return elem === docElem;
        },
        "focus": function(elem) {
          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        },
        "enabled": function(elem) {
          return elem.disabled === false;
        },
        "disabled": function(elem) {
          return elem.disabled === true;
        },
        "checked": function(elem) {
          var nodeName = elem.nodeName.toLowerCase();
          return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
        },
        "selected": function(elem) {
          if (elem.parentNode) {
            elem.parentNode.selectedIndex;
          }
          return elem.selected === true;
        },
        "empty": function(elem) {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            if (elem.nodeType < 6) {
              return false;
            }
          }
          return true;
        },
        "parent": function(elem) {
          return !Expr.pseudos["empty"](elem);
        },
        "header": function(elem) {
          return rheader.test(elem.nodeName);
        },
        "input": function(elem) {
          return rinputs.test(elem.nodeName);
        },
        "button": function(elem) {
          var name = elem.nodeName.toLowerCase();
          return name === "input" && elem.type === "button" || name === "button";
        },
        "text": function(elem) {
          var attr;
          return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
        },
        "first": createPositionalPseudo(function() {
          return [0];
        }),
        "last": createPositionalPseudo(function(matchIndexes, length) {
          return [length - 1];
        }),
        "eq": createPositionalPseudo(function(matchIndexes, length, argument) {
          return [argument < 0 ? argument + length : argument];
        }),
        "even": createPositionalPseudo(function(matchIndexes, length) {
          var i = 0;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "odd": createPositionalPseudo(function(matchIndexes, length) {
          var i = 1;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; --i >= 0; ) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; ++i < length; ) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        })
      }
    };
    Expr.pseudos["nth"] = Expr.pseudos["eq"];
    for (i in {
      radio: true,
      checkbox: true,
      file: true,
      password: true,
      image: true
    }) {
      Expr.pseudos[i] = createInputPseudo(i);
    }
    for (i in {
      submit: true,
      reset: true
    }) {
      Expr.pseudos[i] = createButtonPseudo(i);
    }
    function setFilters() {}
    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();
    tokenize = Sizzle.tokenize = function(selector, parseOnly) {
      var matched,
          match,
          tokens,
          type,
          soFar,
          groups,
          preFilters,
          cached = tokenCache[selector + " "];
      if (cached) {
        return parseOnly ? 0 : cached.slice(0);
      }
      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;
      while (soFar) {
        if (!matched || (match = rcomma.exec(soFar))) {
          if (match) {
            soFar = soFar.slice(match[0].length) || soFar;
          }
          groups.push((tokens = []));
        }
        matched = false;
        if ((match = rcombinators.exec(soFar))) {
          matched = match.shift();
          tokens.push({
            value: matched,
            type: match[0].replace(rtrim, " ")
          });
          soFar = soFar.slice(matched.length);
        }
        for (type in Expr.filter) {
          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: type,
              matches: match
            });
            soFar = soFar.slice(matched.length);
          }
        }
        if (!matched) {
          break;
        }
      }
      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
    };
    function toSelector(tokens) {
      var i = 0,
          len = tokens.length,
          selector = "";
      for (; i < len; i++) {
        selector += tokens[i].value;
      }
      return selector;
    }
    function addCombinator(matcher, combinator, base) {
      var dir = combinator.dir,
          checkNonElements = base && dir === "parentNode",
          doneName = done++;
      return combinator.first ? function(elem, context, xml) {
        while ((elem = elem[dir])) {
          if (elem.nodeType === 1 || checkNonElements) {
            return matcher(elem, context, xml);
          }
        }
      } : function(elem, context, xml) {
        var oldCache,
            outerCache,
            newCache = [dirruns, doneName];
        if (xml) {
          while ((elem = elem[dir])) {
            if (elem.nodeType === 1 || checkNonElements) {
              if (matcher(elem, context, xml)) {
                return true;
              }
            }
          }
        } else {
          while ((elem = elem[dir])) {
            if (elem.nodeType === 1 || checkNonElements) {
              outerCache = elem[expando] || (elem[expando] = {});
              if ((oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                return (newCache[2] = oldCache[2]);
              } else {
                outerCache[dir] = newCache;
                if ((newCache[2] = matcher(elem, context, xml))) {
                  return true;
                }
              }
            }
          }
        }
      };
    }
    function elementMatcher(matchers) {
      return matchers.length > 1 ? function(elem, context, xml) {
        var i = matchers.length;
        while (i--) {
          if (!matchers[i](elem, context, xml)) {
            return false;
          }
        }
        return true;
      } : matchers[0];
    }
    function multipleContexts(selector, contexts, results) {
      var i = 0,
          len = contexts.length;
      for (; i < len; i++) {
        Sizzle(selector, contexts[i], results);
      }
      return results;
    }
    function condense(unmatched, map, filter, context, xml) {
      var elem,
          newUnmatched = [],
          i = 0,
          len = unmatched.length,
          mapped = map != null;
      for (; i < len; i++) {
        if ((elem = unmatched[i])) {
          if (!filter || filter(elem, context, xml)) {
            newUnmatched.push(elem);
            if (mapped) {
              map.push(i);
            }
          }
        }
      }
      return newUnmatched;
    }
    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
      if (postFilter && !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }
      if (postFinder && !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }
      return markFunction(function(seed, results, context, xml) {
        var temp,
            i,
            elem,
            preMap = [],
            postMap = [],
            preexisting = results.length,
            elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
            matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
            matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
        if (matcher) {
          matcher(matcherIn, matcherOut, context, xml);
        }
        if (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml);
          i = temp.length;
          while (i--) {
            if ((elem = temp[i])) {
              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
            }
          }
        }
        if (seed) {
          if (postFinder || preFilter) {
            if (postFinder) {
              temp = [];
              i = matcherOut.length;
              while (i--) {
                if ((elem = matcherOut[i])) {
                  temp.push((matcherIn[i] = elem));
                }
              }
              postFinder(null, (matcherOut = []), temp, xml);
            }
            i = matcherOut.length;
            while (i--) {
              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                seed[temp] = !(results[temp] = elem);
              }
            }
          }
        } else {
          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
          if (postFinder) {
            postFinder(null, results, matcherOut, xml);
          } else {
            push.apply(results, matcherOut);
          }
        }
      });
    }
    function matcherFromTokens(tokens) {
      var checkContext,
          matcher,
          j,
          len = tokens.length,
          leadingRelative = Expr.relative[tokens[0].type],
          implicitRelative = leadingRelative || Expr.relative[" "],
          i = leadingRelative ? 1 : 0,
          matchContext = addCombinator(function(elem) {
            return elem === checkContext;
          }, implicitRelative, true),
          matchAnyContext = addCombinator(function(elem) {
            return indexOf(checkContext, elem) > -1;
          }, implicitRelative, true),
          matchers = [function(elem, context, xml) {
            var ret = (!leadingRelative && (xml || context !== outermostContext)) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
            checkContext = null;
            return ret;
          }];
      for (; i < len; i++) {
        if ((matcher = Expr.relative[tokens[i].type])) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } else {
          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
          if (matcher[expando]) {
            j = ++i;
            for (; j < len; j++) {
              if (Expr.relative[tokens[j].type]) {
                break;
              }
            }
            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({value: tokens[i - 2].type === " " ? "*" : ""})).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens((tokens = tokens.slice(j))), j < len && toSelector(tokens));
          }
          matchers.push(matcher);
        }
      }
      return elementMatcher(matchers);
    }
    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
      var bySet = setMatchers.length > 0,
          byElement = elementMatchers.length > 0,
          superMatcher = function(seed, context, xml, results, outermost) {
            var elem,
                j,
                matcher,
                matchedCount = 0,
                i = "0",
                unmatched = seed && [],
                setMatched = [],
                contextBackup = outermostContext,
                elems = seed || byElement && Expr.find["TAG"]("*", outermost),
                dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                len = elems.length;
            if (outermost) {
              outermostContext = context !== document && context;
            }
            for (; i !== len && (elem = elems[i]) != null; i++) {
              if (byElement && elem) {
                j = 0;
                while ((matcher = elementMatchers[j++])) {
                  if (matcher(elem, context, xml)) {
                    results.push(elem);
                    break;
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                }
              }
              if (bySet) {
                if ((elem = !matcher && elem)) {
                  matchedCount--;
                }
                if (seed) {
                  unmatched.push(elem);
                }
              }
            }
            matchedCount += i;
            if (bySet && i !== matchedCount) {
              j = 0;
              while ((matcher = setMatchers[j++])) {
                matcher(unmatched, setMatched, context, xml);
              }
              if (seed) {
                if (matchedCount > 0) {
                  while (i--) {
                    if (!(unmatched[i] || setMatched[i])) {
                      setMatched[i] = pop.call(results);
                    }
                  }
                }
                setMatched = condense(setMatched);
              }
              push.apply(results, setMatched);
              if (outermost && !seed && setMatched.length > 0 && (matchedCount + setMatchers.length) > 1) {
                Sizzle.uniqueSort(results);
              }
            }
            if (outermost) {
              dirruns = dirrunsUnique;
              outermostContext = contextBackup;
            }
            return unmatched;
          };
      return bySet ? markFunction(superMatcher) : superMatcher;
    }
    compile = Sizzle.compile = function(selector, match) {
      var i,
          setMatchers = [],
          elementMatchers = [],
          cached = compilerCache[selector + " "];
      if (!cached) {
        if (!match) {
          match = tokenize(selector);
        }
        i = match.length;
        while (i--) {
          cached = matcherFromTokens(match[i]);
          if (cached[expando]) {
            setMatchers.push(cached);
          } else {
            elementMatchers.push(cached);
          }
        }
        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
        cached.selector = selector;
      }
      return cached;
    };
    select = Sizzle.select = function(selector, context, results, seed) {
      var i,
          tokens,
          token,
          type,
          find,
          compiled = typeof selector === "function" && selector,
          match = !seed && tokenize((selector = compiled.selector || selector));
      results = results || [];
      if (match.length === 1) {
        tokens = match[0] = match[0].slice(0);
        if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
          context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
          if (!context) {
            return results;
          } else if (compiled) {
            context = context.parentNode;
          }
          selector = selector.slice(tokens.shift().value.length);
        }
        i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
        while (i--) {
          token = tokens[i];
          if (Expr.relative[(type = token.type)]) {
            break;
          }
          if ((find = Expr.find[type])) {
            if ((seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context))) {
              tokens.splice(i, 1);
              selector = seed.length && toSelector(tokens);
              if (!selector) {
                push.apply(results, seed);
                return results;
              }
              break;
            }
          }
        }
      }
      (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context);
      return results;
    };
    support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
    support.detectDuplicates = !!hasDuplicate;
    setDocument();
    support.sortDetached = assert(function(div1) {
      return div1.compareDocumentPosition(document.createElement("div")) & 1;
    });
    if (!assert(function(div) {
      div.innerHTML = "<a href='#'></a>";
      return div.firstChild.getAttribute("href") === "#";
    })) {
      addHandle("type|href|height|width", function(elem, name, isXML) {
        if (!isXML) {
          return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
        }
      });
    }
    if (!support.attributes || !assert(function(div) {
      div.innerHTML = "<input/>";
      div.firstChild.setAttribute("value", "");
      return div.firstChild.getAttribute("value") === "";
    })) {
      addHandle("value", function(elem, name, isXML) {
        if (!isXML && elem.nodeName.toLowerCase() === "input") {
          return elem.defaultValue;
        }
      });
    }
    if (!assert(function(div) {
      return div.getAttribute("disabled") == null;
    })) {
      addHandle(booleans, function(elem, name, isXML) {
        var val;
        if (!isXML) {
          return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        }
      });
    }
    return Sizzle;
  })(window);
  jQuery.find = Sizzle;
  jQuery.expr = Sizzle.selectors;
  jQuery.expr[":"] = jQuery.expr.pseudos;
  jQuery.unique = Sizzle.uniqueSort;
  jQuery.text = Sizzle.getText;
  jQuery.isXMLDoc = Sizzle.isXML;
  jQuery.contains = Sizzle.contains;
  var rneedsContext = jQuery.expr.match.needsContext;
  var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);
  var risSimple = /^.[^:#\[\.,]*$/;
  function winnow(elements, qualifier, not) {
    if (jQuery.isFunction(qualifier)) {
      return jQuery.grep(elements, function(elem, i) {
        return !!qualifier.call(elem, i, elem) !== not;
      });
    }
    if (qualifier.nodeType) {
      return jQuery.grep(elements, function(elem) {
        return (elem === qualifier) !== not;
      });
    }
    if (typeof qualifier === "string") {
      if (risSimple.test(qualifier)) {
        return jQuery.filter(qualifier, elements, not);
      }
      qualifier = jQuery.filter(qualifier, elements);
    }
    return jQuery.grep(elements, function(elem) {
      return (indexOf.call(qualifier, elem) >= 0) !== not;
    });
  }
  jQuery.filter = function(expr, elems, not) {
    var elem = elems[0];
    if (not) {
      expr = ":not(" + expr + ")";
    }
    return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
      return elem.nodeType === 1;
    }));
  };
  jQuery.fn.extend({
    find: function(selector) {
      var i,
          len = this.length,
          ret = [],
          self = this;
      if (typeof selector !== "string") {
        return this.pushStack(jQuery(selector).filter(function() {
          for (i = 0; i < len; i++) {
            if (jQuery.contains(self[i], this)) {
              return true;
            }
          }
        }));
      }
      for (i = 0; i < len; i++) {
        jQuery.find(selector, self[i], ret);
      }
      ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
      ret.selector = this.selector ? this.selector + " " + selector : selector;
      return ret;
    },
    filter: function(selector) {
      return this.pushStack(winnow(this, selector || [], false));
    },
    not: function(selector) {
      return this.pushStack(winnow(this, selector || [], true));
    },
    is: function(selector) {
      return !!winnow(this, typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
    }
  });
  var rootjQuery,
      rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
      init = jQuery.fn.init = function(selector, context) {
        var match,
            elem;
        if (!selector) {
          return this;
        }
        if (typeof selector === "string") {
          if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
            match = [null, selector, null];
          } else {
            match = rquickExpr.exec(selector);
          }
          if (match && (match[1] || !context)) {
            if (match[1]) {
              context = context instanceof jQuery ? context[0] : context;
              jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
              if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                for (match in context) {
                  if (jQuery.isFunction(this[match])) {
                    this[match](context[match]);
                  } else {
                    this.attr(match, context[match]);
                  }
                }
              }
              return this;
            } else {
              elem = document.getElementById(match[2]);
              if (elem && elem.parentNode) {
                this.length = 1;
                this[0] = elem;
              }
              this.context = document;
              this.selector = selector;
              return this;
            }
          } else if (!context || context.jquery) {
            return (context || rootjQuery).find(selector);
          } else {
            return this.constructor(context).find(selector);
          }
        } else if (selector.nodeType) {
          this.context = this[0] = selector;
          this.length = 1;
          return this;
        } else if (jQuery.isFunction(selector)) {
          return typeof rootjQuery.ready !== "undefined" ? rootjQuery.ready(selector) : selector(jQuery);
        }
        if (selector.selector !== undefined) {
          this.selector = selector.selector;
          this.context = selector.context;
        }
        return jQuery.makeArray(selector, this);
      };
  init.prototype = jQuery.fn;
  rootjQuery = jQuery(document);
  var rparentsprev = /^(?:parents|prev(?:Until|All))/,
      guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
      };
  jQuery.extend({
    dir: function(elem, dir, until) {
      var matched = [],
          truncate = until !== undefined;
      while ((elem = elem[dir]) && elem.nodeType !== 9) {
        if (elem.nodeType === 1) {
          if (truncate && jQuery(elem).is(until)) {
            break;
          }
          matched.push(elem);
        }
      }
      return matched;
    },
    sibling: function(n, elem) {
      var matched = [];
      for (; n; n = n.nextSibling) {
        if (n.nodeType === 1 && n !== elem) {
          matched.push(n);
        }
      }
      return matched;
    }
  });
  jQuery.fn.extend({
    has: function(target) {
      var targets = jQuery(target, this),
          l = targets.length;
      return this.filter(function() {
        var i = 0;
        for (; i < l; i++) {
          if (jQuery.contains(this, targets[i])) {
            return true;
          }
        }
      });
    },
    closest: function(selectors, context) {
      var cur,
          i = 0,
          l = this.length,
          matched = [],
          pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;
      for (; i < l; i++) {
        for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
          if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
            matched.push(cur);
            break;
          }
        }
      }
      return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
    },
    index: function(elem) {
      if (!elem) {
        return (this[0] && this[0].parentNode) ? this.first().prevAll().length : -1;
      }
      if (typeof elem === "string") {
        return indexOf.call(jQuery(elem), this[0]);
      }
      return indexOf.call(this, elem.jquery ? elem[0] : elem);
    },
    add: function(selector, context) {
      return this.pushStack(jQuery.unique(jQuery.merge(this.get(), jQuery(selector, context))));
    },
    addBack: function(selector) {
      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
    }
  });
  function sibling(cur, dir) {
    while ((cur = cur[dir]) && cur.nodeType !== 1) {}
    return cur;
  }
  jQuery.each({
    parent: function(elem) {
      var parent = elem.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    parents: function(elem) {
      return jQuery.dir(elem, "parentNode");
    },
    parentsUntil: function(elem, i, until) {
      return jQuery.dir(elem, "parentNode", until);
    },
    next: function(elem) {
      return sibling(elem, "nextSibling");
    },
    prev: function(elem) {
      return sibling(elem, "previousSibling");
    },
    nextAll: function(elem) {
      return jQuery.dir(elem, "nextSibling");
    },
    prevAll: function(elem) {
      return jQuery.dir(elem, "previousSibling");
    },
    nextUntil: function(elem, i, until) {
      return jQuery.dir(elem, "nextSibling", until);
    },
    prevUntil: function(elem, i, until) {
      return jQuery.dir(elem, "previousSibling", until);
    },
    siblings: function(elem) {
      return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
    },
    children: function(elem) {
      return jQuery.sibling(elem.firstChild);
    },
    contents: function(elem) {
      return elem.contentDocument || jQuery.merge([], elem.childNodes);
    }
  }, function(name, fn) {
    jQuery.fn[name] = function(until, selector) {
      var matched = jQuery.map(this, fn, until);
      if (name.slice(-5) !== "Until") {
        selector = until;
      }
      if (selector && typeof selector === "string") {
        matched = jQuery.filter(selector, matched);
      }
      if (this.length > 1) {
        if (!guaranteedUnique[name]) {
          jQuery.unique(matched);
        }
        if (rparentsprev.test(name)) {
          matched.reverse();
        }
      }
      return this.pushStack(matched);
    };
  });
  var rnotwhite = (/\S+/g);
  var optionsCache = {};
  function createOptions(options) {
    var object = optionsCache[options] = {};
    jQuery.each(options.match(rnotwhite) || [], function(_, flag) {
      object[flag] = true;
    });
    return object;
  }
  jQuery.Callbacks = function(options) {
    options = typeof options === "string" ? (optionsCache[options] || createOptions(options)) : jQuery.extend({}, options);
    var memory,
        fired,
        firing,
        firingStart,
        firingLength,
        firingIndex,
        list = [],
        stack = !options.once && [],
        fire = function(data) {
          memory = options.memory && data;
          fired = true;
          firingIndex = firingStart || 0;
          firingStart = 0;
          firingLength = list.length;
          firing = true;
          for (; list && firingIndex < firingLength; firingIndex++) {
            if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
              memory = false;
              break;
            }
          }
          firing = false;
          if (list) {
            if (stack) {
              if (stack.length) {
                fire(stack.shift());
              }
            } else if (memory) {
              list = [];
            } else {
              self.disable();
            }
          }
        },
        self = {
          add: function() {
            if (list) {
              var start = list.length;
              (function add(args) {
                jQuery.each(args, function(_, arg) {
                  var type = jQuery.type(arg);
                  if (type === "function") {
                    if (!options.unique || !self.has(arg)) {
                      list.push(arg);
                    }
                  } else if (arg && arg.length && type !== "string") {
                    add(arg);
                  }
                });
              })(arguments);
              if (firing) {
                firingLength = list.length;
              } else if (memory) {
                firingStart = start;
                fire(memory);
              }
            }
            return this;
          },
          remove: function() {
            if (list) {
              jQuery.each(arguments, function(_, arg) {
                var index;
                while ((index = jQuery.inArray(arg, list, index)) > -1) {
                  list.splice(index, 1);
                  if (firing) {
                    if (index <= firingLength) {
                      firingLength--;
                    }
                    if (index <= firingIndex) {
                      firingIndex--;
                    }
                  }
                }
              });
            }
            return this;
          },
          has: function(fn) {
            return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
          },
          empty: function() {
            list = [];
            firingLength = 0;
            return this;
          },
          disable: function() {
            list = stack = memory = undefined;
            return this;
          },
          disabled: function() {
            return !list;
          },
          lock: function() {
            stack = undefined;
            if (!memory) {
              self.disable();
            }
            return this;
          },
          locked: function() {
            return !stack;
          },
          fireWith: function(context, args) {
            if (list && (!fired || stack)) {
              args = args || [];
              args = [context, args.slice ? args.slice() : args];
              if (firing) {
                stack.push(args);
              } else {
                fire(args);
              }
            }
            return this;
          },
          fire: function() {
            self.fireWith(this, arguments);
            return this;
          },
          fired: function() {
            return !!fired;
          }
        };
    return self;
  };
  jQuery.extend({
    Deferred: function(func) {
      var tuples = [["resolve", "done", jQuery.Callbacks("once memory"), "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"], ["notify", "progress", jQuery.Callbacks("memory")]],
          state = "pending",
          promise = {
            state: function() {
              return state;
            },
            always: function() {
              deferred.done(arguments).fail(arguments);
              return this;
            },
            then: function() {
              var fns = arguments;
              return jQuery.Deferred(function(newDefer) {
                jQuery.each(tuples, function(i, tuple) {
                  var fn = jQuery.isFunction(fns[i]) && fns[i];
                  deferred[tuple[1]](function() {
                    var returned = fn && fn.apply(this, arguments);
                    if (returned && jQuery.isFunction(returned.promise)) {
                      returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);
                    } else {
                      newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                    }
                  });
                });
                fns = null;
              }).promise();
            },
            promise: function(obj) {
              return obj != null ? jQuery.extend(obj, promise) : promise;
            }
          },
          deferred = {};
      promise.pipe = promise.then;
      jQuery.each(tuples, function(i, tuple) {
        var list = tuple[2],
            stateString = tuple[3];
        promise[tuple[1]] = list.add;
        if (stateString) {
          list.add(function() {
            state = stateString;
          }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
        }
        deferred[tuple[0]] = function() {
          deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
          return this;
        };
        deferred[tuple[0] + "With"] = list.fireWith;
      });
      promise.promise(deferred);
      if (func) {
        func.call(deferred, deferred);
      }
      return deferred;
    },
    when: function(subordinate) {
      var i = 0,
          resolveValues = slice.call(arguments),
          length = resolveValues.length,
          remaining = length !== 1 || (subordinate && jQuery.isFunction(subordinate.promise)) ? length : 0,
          deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
          updateFunc = function(i, contexts, values) {
            return function(value) {
              contexts[i] = this;
              values[i] = arguments.length > 1 ? slice.call(arguments) : value;
              if (values === progressValues) {
                deferred.notifyWith(contexts, values);
              } else if (!(--remaining)) {
                deferred.resolveWith(contexts, values);
              }
            };
          },
          progressValues,
          progressContexts,
          resolveContexts;
      if (length > 1) {
        progressValues = new Array(length);
        progressContexts = new Array(length);
        resolveContexts = new Array(length);
        for (; i < length; i++) {
          if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
            resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));
          } else {
            --remaining;
          }
        }
      }
      if (!remaining) {
        deferred.resolveWith(resolveContexts, resolveValues);
      }
      return deferred.promise();
    }
  });
  var readyList;
  jQuery.fn.ready = function(fn) {
    jQuery.ready.promise().done(fn);
    return this;
  };
  jQuery.extend({
    isReady: false,
    readyWait: 1,
    holdReady: function(hold) {
      if (hold) {
        jQuery.readyWait++;
      } else {
        jQuery.ready(true);
      }
    },
    ready: function(wait) {
      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
        return ;
      }
      jQuery.isReady = true;
      if (wait !== true && --jQuery.readyWait > 0) {
        return ;
      }
      readyList.resolveWith(document, [jQuery]);
      if (jQuery.fn.triggerHandler) {
        jQuery(document).triggerHandler("ready");
        jQuery(document).off("ready");
      }
    }
  });
  function completed() {
    document.removeEventListener("DOMContentLoaded", completed, false);
    window.removeEventListener("load", completed, false);
    jQuery.ready();
  }
  jQuery.ready.promise = function(obj) {
    if (!readyList) {
      readyList = jQuery.Deferred();
      if (document.readyState === "complete") {
        setTimeout(jQuery.ready);
      } else {
        document.addEventListener("DOMContentLoaded", completed, false);
        window.addEventListener("load", completed, false);
      }
    }
    return readyList.promise(obj);
  };
  jQuery.ready.promise();
  var access = jQuery.access = function(elems, fn, key, value, chainable, emptyGet, raw) {
    var i = 0,
        len = elems.length,
        bulk = key == null;
    if (jQuery.type(key) === "object") {
      chainable = true;
      for (i in key) {
        jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
      }
    } else if (value !== undefined) {
      chainable = true;
      if (!jQuery.isFunction(value)) {
        raw = true;
      }
      if (bulk) {
        if (raw) {
          fn.call(elems, value);
          fn = null;
        } else {
          bulk = fn;
          fn = function(elem, key, value) {
            return bulk.call(jQuery(elem), value);
          };
        }
      }
      if (fn) {
        for (; i < len; i++) {
          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
        }
      }
    }
    return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
  };
  jQuery.acceptData = function(owner) {
    return owner.nodeType === 1 || owner.nodeType === 9 || !(+owner.nodeType);
  };
  function Data() {
    Object.defineProperty(this.cache = {}, 0, {get: function() {
        return {};
      }});
    this.expando = jQuery.expando + Data.uid++;
  }
  Data.uid = 1;
  Data.accepts = jQuery.acceptData;
  Data.prototype = {
    key: function(owner) {
      if (!Data.accepts(owner)) {
        return 0;
      }
      var descriptor = {},
          unlock = owner[this.expando];
      if (!unlock) {
        unlock = Data.uid++;
        try {
          descriptor[this.expando] = {value: unlock};
          Object.defineProperties(owner, descriptor);
        } catch (e) {
          descriptor[this.expando] = unlock;
          jQuery.extend(owner, descriptor);
        }
      }
      if (!this.cache[unlock]) {
        this.cache[unlock] = {};
      }
      return unlock;
    },
    set: function(owner, data, value) {
      var prop,
          unlock = this.key(owner),
          cache = this.cache[unlock];
      if (typeof data === "string") {
        cache[data] = value;
      } else {
        if (jQuery.isEmptyObject(cache)) {
          jQuery.extend(this.cache[unlock], data);
        } else {
          for (prop in data) {
            cache[prop] = data[prop];
          }
        }
      }
      return cache;
    },
    get: function(owner, key) {
      var cache = this.cache[this.key(owner)];
      return key === undefined ? cache : cache[key];
    },
    access: function(owner, key, value) {
      var stored;
      if (key === undefined || ((key && typeof key === "string") && value === undefined)) {
        stored = this.get(owner, key);
        return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
      }
      this.set(owner, key, value);
      return value !== undefined ? value : key;
    },
    remove: function(owner, key) {
      var i,
          name,
          camel,
          unlock = this.key(owner),
          cache = this.cache[unlock];
      if (key === undefined) {
        this.cache[unlock] = {};
      } else {
        if (jQuery.isArray(key)) {
          name = key.concat(key.map(jQuery.camelCase));
        } else {
          camel = jQuery.camelCase(key);
          if (key in cache) {
            name = [key, camel];
          } else {
            name = camel;
            name = name in cache ? [name] : (name.match(rnotwhite) || []);
          }
        }
        i = name.length;
        while (i--) {
          delete cache[name[i]];
        }
      }
    },
    hasData: function(owner) {
      return !jQuery.isEmptyObject(this.cache[owner[this.expando]] || {});
    },
    discard: function(owner) {
      if (owner[this.expando]) {
        delete this.cache[owner[this.expando]];
      }
    }
  };
  var data_priv = new Data();
  var data_user = new Data();
  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
      rmultiDash = /([A-Z])/g;
  function dataAttr(elem, key, data) {
    var name;
    if (data === undefined && elem.nodeType === 1) {
      name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();
      data = elem.getAttribute(name);
      if (typeof data === "string") {
        try {
          data = data === "true" ? true : data === "false" ? false : data === "null" ? null : +data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
        } catch (e) {}
        data_user.set(elem, key, data);
      } else {
        data = undefined;
      }
    }
    return data;
  }
  jQuery.extend({
    hasData: function(elem) {
      return data_user.hasData(elem) || data_priv.hasData(elem);
    },
    data: function(elem, name, data) {
      return data_user.access(elem, name, data);
    },
    removeData: function(elem, name) {
      data_user.remove(elem, name);
    },
    _data: function(elem, name, data) {
      return data_priv.access(elem, name, data);
    },
    _removeData: function(elem, name) {
      data_priv.remove(elem, name);
    }
  });
  jQuery.fn.extend({
    data: function(key, value) {
      var i,
          name,
          data,
          elem = this[0],
          attrs = elem && elem.attributes;
      if (key === undefined) {
        if (this.length) {
          data = data_user.get(elem);
          if (elem.nodeType === 1 && !data_priv.get(elem, "hasDataAttrs")) {
            i = attrs.length;
            while (i--) {
              if (attrs[i]) {
                name = attrs[i].name;
                if (name.indexOf("data-") === 0) {
                  name = jQuery.camelCase(name.slice(5));
                  dataAttr(elem, name, data[name]);
                }
              }
            }
            data_priv.set(elem, "hasDataAttrs", true);
          }
        }
        return data;
      }
      if (typeof key === "object") {
        return this.each(function() {
          data_user.set(this, key);
        });
      }
      return access(this, function(value) {
        var data,
            camelKey = jQuery.camelCase(key);
        if (elem && value === undefined) {
          data = data_user.get(elem, key);
          if (data !== undefined) {
            return data;
          }
          data = data_user.get(elem, camelKey);
          if (data !== undefined) {
            return data;
          }
          data = dataAttr(elem, camelKey, undefined);
          if (data !== undefined) {
            return data;
          }
          return ;
        }
        this.each(function() {
          var data = data_user.get(this, camelKey);
          data_user.set(this, camelKey, value);
          if (key.indexOf("-") !== -1 && data !== undefined) {
            data_user.set(this, key, value);
          }
        });
      }, null, value, arguments.length > 1, null, true);
    },
    removeData: function(key) {
      return this.each(function() {
        data_user.remove(this, key);
      });
    }
  });
  jQuery.extend({
    queue: function(elem, type, data) {
      var queue;
      if (elem) {
        type = (type || "fx") + "queue";
        queue = data_priv.get(elem, type);
        if (data) {
          if (!queue || jQuery.isArray(data)) {
            queue = data_priv.access(elem, type, jQuery.makeArray(data));
          } else {
            queue.push(data);
          }
        }
        return queue || [];
      }
    },
    dequeue: function(elem, type) {
      type = type || "fx";
      var queue = jQuery.queue(elem, type),
          startLength = queue.length,
          fn = queue.shift(),
          hooks = jQuery._queueHooks(elem, type),
          next = function() {
            jQuery.dequeue(elem, type);
          };
      if (fn === "inprogress") {
        fn = queue.shift();
        startLength--;
      }
      if (fn) {
        if (type === "fx") {
          queue.unshift("inprogress");
        }
        delete hooks.stop;
        fn.call(elem, next, hooks);
      }
      if (!startLength && hooks) {
        hooks.empty.fire();
      }
    },
    _queueHooks: function(elem, type) {
      var key = type + "queueHooks";
      return data_priv.get(elem, key) || data_priv.access(elem, key, {empty: jQuery.Callbacks("once memory").add(function() {
          data_priv.remove(elem, [type + "queue", key]);
        })});
    }
  });
  jQuery.fn.extend({
    queue: function(type, data) {
      var setter = 2;
      if (typeof type !== "string") {
        data = type;
        type = "fx";
        setter--;
      }
      if (arguments.length < setter) {
        return jQuery.queue(this[0], type);
      }
      return data === undefined ? this : this.each(function() {
        var queue = jQuery.queue(this, type, data);
        jQuery._queueHooks(this, type);
        if (type === "fx" && queue[0] !== "inprogress") {
          jQuery.dequeue(this, type);
        }
      });
    },
    dequeue: function(type) {
      return this.each(function() {
        jQuery.dequeue(this, type);
      });
    },
    clearQueue: function(type) {
      return this.queue(type || "fx", []);
    },
    promise: function(type, obj) {
      var tmp,
          count = 1,
          defer = jQuery.Deferred(),
          elements = this,
          i = this.length,
          resolve = function() {
            if (!(--count)) {
              defer.resolveWith(elements, [elements]);
            }
          };
      if (typeof type !== "string") {
        obj = type;
        type = undefined;
      }
      type = type || "fx";
      while (i--) {
        tmp = data_priv.get(elements[i], type + "queueHooks");
        if (tmp && tmp.empty) {
          count++;
          tmp.empty.add(resolve);
        }
      }
      resolve();
      return defer.promise(obj);
    }
  });
  var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;
  var cssExpand = ["Top", "Right", "Bottom", "Left"];
  var isHidden = function(elem, el) {
    elem = el || elem;
    return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
  };
  var rcheckableType = (/^(?:checkbox|radio)$/i);
  (function() {
    var fragment = document.createDocumentFragment(),
        div = fragment.appendChild(document.createElement("div")),
        input = document.createElement("input");
    input.setAttribute("type", "radio");
    input.setAttribute("checked", "checked");
    input.setAttribute("name", "t");
    div.appendChild(input);
    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
    div.innerHTML = "<textarea>x</textarea>";
    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
  })();
  var strundefined = typeof undefined;
  support.focusinBubbles = "onfocusin" in window;
  var rkeyEvent = /^key/,
      rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
      rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
      rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
  function returnTrue() {
    return true;
  }
  function returnFalse() {
    return false;
  }
  function safeActiveElement() {
    try {
      return document.activeElement;
    } catch (err) {}
  }
  jQuery.event = {
    global: {},
    add: function(elem, types, handler, data, selector) {
      var handleObjIn,
          eventHandle,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = data_priv.get(elem);
      if (!elemData) {
        return ;
      }
      if (handler.handler) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      }
      if (!handler.guid) {
        handler.guid = jQuery.guid++;
      }
      if (!(events = elemData.events)) {
        events = elemData.events = {};
      }
      if (!(eventHandle = elemData.handle)) {
        eventHandle = elemData.handle = function(e) {
          return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
        };
      }
      types = (types || "").match(rnotwhite) || [""];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();
        if (!type) {
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        special = jQuery.event.special[type] || {};
        handleObj = jQuery.extend({
          type: type,
          origType: origType,
          data: data,
          handler: handler,
          guid: handler.guid,
          selector: selector,
          needsContext: selector && jQuery.expr.match.needsContext.test(selector),
          namespace: namespaces.join(".")
        }, handleObjIn);
        if (!(handlers = events[type])) {
          handlers = events[type] = [];
          handlers.delegateCount = 0;
          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
            if (elem.addEventListener) {
              elem.addEventListener(type, eventHandle, false);
            }
          }
        }
        if (special.add) {
          special.add.call(elem, handleObj);
          if (!handleObj.handler.guid) {
            handleObj.handler.guid = handler.guid;
          }
        }
        if (selector) {
          handlers.splice(handlers.delegateCount++, 0, handleObj);
        } else {
          handlers.push(handleObj);
        }
        jQuery.event.global[type] = true;
      }
    },
    remove: function(elem, types, handler, selector, mappedTypes) {
      var j,
          origCount,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = data_priv.hasData(elem) && data_priv.get(elem);
      if (!elemData || !(events = elemData.events)) {
        return ;
      }
      types = (types || "").match(rnotwhite) || [""];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();
        if (!type) {
          for (type in events) {
            jQuery.event.remove(elem, type + types[t], handler, selector, true);
          }
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        handlers = events[type] || [];
        tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
        origCount = j = handlers.length;
        while (j--) {
          handleObj = handlers[j];
          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
            handlers.splice(j, 1);
            if (handleObj.selector) {
              handlers.delegateCount--;
            }
            if (special.remove) {
              special.remove.call(elem, handleObj);
            }
          }
        }
        if (origCount && !handlers.length) {
          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
            jQuery.removeEvent(elem, type, elemData.handle);
          }
          delete events[type];
        }
      }
      if (jQuery.isEmptyObject(events)) {
        delete elemData.handle;
        data_priv.remove(elem, "events");
      }
    },
    trigger: function(event, data, elem, onlyHandlers) {
      var i,
          cur,
          tmp,
          bubbleType,
          ontype,
          handle,
          special,
          eventPath = [elem || document],
          type = hasOwn.call(event, "type") ? event.type : event,
          namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
      cur = tmp = elem = elem || document;
      if (elem.nodeType === 3 || elem.nodeType === 8) {
        return ;
      }
      if (rfocusMorph.test(type + jQuery.event.triggered)) {
        return ;
      }
      if (type.indexOf(".") >= 0) {
        namespaces = type.split(".");
        type = namespaces.shift();
        namespaces.sort();
      }
      ontype = type.indexOf(":") < 0 && "on" + type;
      event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
      event.isTrigger = onlyHandlers ? 2 : 3;
      event.namespace = namespaces.join(".");
      event.namespace_re = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
      event.result = undefined;
      if (!event.target) {
        event.target = elem;
      }
      data = data == null ? [event] : jQuery.makeArray(data, [event]);
      special = jQuery.event.special[type] || {};
      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
        return ;
      }
      if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
        bubbleType = special.delegateType || type;
        if (!rfocusMorph.test(bubbleType + type)) {
          cur = cur.parentNode;
        }
        for (; cur; cur = cur.parentNode) {
          eventPath.push(cur);
          tmp = cur;
        }
        if (tmp === (elem.ownerDocument || document)) {
          eventPath.push(tmp.defaultView || tmp.parentWindow || window);
        }
      }
      i = 0;
      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
        event.type = i > 1 ? bubbleType : special.bindType || type;
        handle = (data_priv.get(cur, "events") || {})[event.type] && data_priv.get(cur, "handle");
        if (handle) {
          handle.apply(cur, data);
        }
        handle = ontype && cur[ontype];
        if (handle && handle.apply && jQuery.acceptData(cur)) {
          event.result = handle.apply(cur, data);
          if (event.result === false) {
            event.preventDefault();
          }
        }
      }
      event.type = type;
      if (!onlyHandlers && !event.isDefaultPrevented()) {
        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {
          if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
            tmp = elem[ontype];
            if (tmp) {
              elem[ontype] = null;
            }
            jQuery.event.triggered = type;
            elem[type]();
            jQuery.event.triggered = undefined;
            if (tmp) {
              elem[ontype] = tmp;
            }
          }
        }
      }
      return event.result;
    },
    dispatch: function(event) {
      event = jQuery.event.fix(event);
      var i,
          j,
          ret,
          matched,
          handleObj,
          handlerQueue = [],
          args = slice.call(arguments),
          handlers = (data_priv.get(this, "events") || {})[event.type] || [],
          special = jQuery.event.special[event.type] || {};
      args[0] = event;
      event.delegateTarget = this;
      if (special.preDispatch && special.preDispatch.call(this, event) === false) {
        return ;
      }
      handlerQueue = jQuery.event.handlers.call(this, event, handlers);
      i = 0;
      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
        event.currentTarget = matched.elem;
        j = 0;
        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
          if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
            if (ret !== undefined) {
              if ((event.result = ret) === false) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
      }
      if (special.postDispatch) {
        special.postDispatch.call(this, event);
      }
      return event.result;
    },
    handlers: function(event, handlers) {
      var i,
          matches,
          sel,
          handleObj,
          handlerQueue = [],
          delegateCount = handlers.delegateCount,
          cur = event.target;
      if (delegateCount && cur.nodeType && (!event.button || event.type !== "click")) {
        for (; cur !== this; cur = cur.parentNode || this) {
          if (cur.disabled !== true || event.type !== "click") {
            matches = [];
            for (i = 0; i < delegateCount; i++) {
              handleObj = handlers[i];
              sel = handleObj.selector + " ";
              if (matches[sel] === undefined) {
                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length;
              }
              if (matches[sel]) {
                matches.push(handleObj);
              }
            }
            if (matches.length) {
              handlerQueue.push({
                elem: cur,
                handlers: matches
              });
            }
          }
        }
      }
      if (delegateCount < handlers.length) {
        handlerQueue.push({
          elem: this,
          handlers: handlers.slice(delegateCount)
        });
      }
      return handlerQueue;
    },
    props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
    fixHooks: {},
    keyHooks: {
      props: "char charCode key keyCode".split(" "),
      filter: function(event, original) {
        if (event.which == null) {
          event.which = original.charCode != null ? original.charCode : original.keyCode;
        }
        return event;
      }
    },
    mouseHooks: {
      props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
      filter: function(event, original) {
        var eventDoc,
            doc,
            body,
            button = original.button;
        if (event.pageX == null && original.clientX != null) {
          eventDoc = event.target.ownerDocument || document;
          doc = eventDoc.documentElement;
          body = eventDoc.body;
          event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
          event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
        }
        if (!event.which && button !== undefined) {
          event.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
        }
        return event;
      }
    },
    fix: function(event) {
      if (event[jQuery.expando]) {
        return event;
      }
      var i,
          prop,
          copy,
          type = event.type,
          originalEvent = event,
          fixHook = this.fixHooks[type];
      if (!fixHook) {
        this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
      }
      copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
      event = new jQuery.Event(originalEvent);
      i = copy.length;
      while (i--) {
        prop = copy[i];
        event[prop] = originalEvent[prop];
      }
      if (!event.target) {
        event.target = document;
      }
      if (event.target.nodeType === 3) {
        event.target = event.target.parentNode;
      }
      return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
    },
    special: {
      load: {noBubble: true},
      focus: {
        trigger: function() {
          if (this !== safeActiveElement() && this.focus) {
            this.focus();
            return false;
          }
        },
        delegateType: "focusin"
      },
      blur: {
        trigger: function() {
          if (this === safeActiveElement() && this.blur) {
            this.blur();
            return false;
          }
        },
        delegateType: "focusout"
      },
      click: {
        trigger: function() {
          if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
            this.click();
            return false;
          }
        },
        _default: function(event) {
          return jQuery.nodeName(event.target, "a");
        }
      },
      beforeunload: {postDispatch: function(event) {
          if (event.result !== undefined && event.originalEvent) {
            event.originalEvent.returnValue = event.result;
          }
        }}
    },
    simulate: function(type, elem, event, bubble) {
      var e = jQuery.extend(new jQuery.Event(), event, {
        type: type,
        isSimulated: true,
        originalEvent: {}
      });
      if (bubble) {
        jQuery.event.trigger(e, null, elem);
      } else {
        jQuery.event.dispatch.call(elem, e);
      }
      if (e.isDefaultPrevented()) {
        event.preventDefault();
      }
    }
  };
  jQuery.removeEvent = function(elem, type, handle) {
    if (elem.removeEventListener) {
      elem.removeEventListener(type, handle, false);
    }
  };
  jQuery.Event = function(src, props) {
    if (!(this instanceof jQuery.Event)) {
      return new jQuery.Event(src, props);
    }
    if (src && src.type) {
      this.originalEvent = src;
      this.type = src.type;
      this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse;
    } else {
      this.type = src;
    }
    if (props) {
      jQuery.extend(this, props);
    }
    this.timeStamp = src && src.timeStamp || jQuery.now();
    this[jQuery.expando] = true;
  };
  jQuery.Event.prototype = {
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,
    preventDefault: function() {
      var e = this.originalEvent;
      this.isDefaultPrevented = returnTrue;
      if (e && e.preventDefault) {
        e.preventDefault();
      }
    },
    stopPropagation: function() {
      var e = this.originalEvent;
      this.isPropagationStopped = returnTrue;
      if (e && e.stopPropagation) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function() {
      var e = this.originalEvent;
      this.isImmediatePropagationStopped = returnTrue;
      if (e && e.stopImmediatePropagation) {
        e.stopImmediatePropagation();
      }
      this.stopPropagation();
    }
  };
  jQuery.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout",
    pointerenter: "pointerover",
    pointerleave: "pointerout"
  }, function(orig, fix) {
    jQuery.event.special[orig] = {
      delegateType: fix,
      bindType: fix,
      handle: function(event) {
        var ret,
            target = this,
            related = event.relatedTarget,
            handleObj = event.handleObj;
        if (!related || (related !== target && !jQuery.contains(target, related))) {
          event.type = handleObj.origType;
          ret = handleObj.handler.apply(this, arguments);
          event.type = fix;
        }
        return ret;
      }
    };
  });
  if (!support.focusinBubbles) {
    jQuery.each({
      focus: "focusin",
      blur: "focusout"
    }, function(orig, fix) {
      var handler = function(event) {
        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
      };
      jQuery.event.special[fix] = {
        setup: function() {
          var doc = this.ownerDocument || this,
              attaches = data_priv.access(doc, fix);
          if (!attaches) {
            doc.addEventListener(orig, handler, true);
          }
          data_priv.access(doc, fix, (attaches || 0) + 1);
        },
        teardown: function() {
          var doc = this.ownerDocument || this,
              attaches = data_priv.access(doc, fix) - 1;
          if (!attaches) {
            doc.removeEventListener(orig, handler, true);
            data_priv.remove(doc, fix);
          } else {
            data_priv.access(doc, fix, attaches);
          }
        }
      };
    });
  }
  jQuery.fn.extend({
    on: function(types, selector, data, fn, one) {
      var origFn,
          type;
      if (typeof types === "object") {
        if (typeof selector !== "string") {
          data = data || selector;
          selector = undefined;
        }
        for (type in types) {
          this.on(type, selector, data, types[type], one);
        }
        return this;
      }
      if (data == null && fn == null) {
        fn = selector;
        data = selector = undefined;
      } else if (fn == null) {
        if (typeof selector === "string") {
          fn = data;
          data = undefined;
        } else {
          fn = data;
          data = selector;
          selector = undefined;
        }
      }
      if (fn === false) {
        fn = returnFalse;
      } else if (!fn) {
        return this;
      }
      if (one === 1) {
        origFn = fn;
        fn = function(event) {
          jQuery().off(event);
          return origFn.apply(this, arguments);
        };
        fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
      }
      return this.each(function() {
        jQuery.event.add(this, types, fn, data, selector);
      });
    },
    one: function(types, selector, data, fn) {
      return this.on(types, selector, data, fn, 1);
    },
    off: function(types, selector, fn) {
      var handleObj,
          type;
      if (types && types.preventDefault && types.handleObj) {
        handleObj = types.handleObj;
        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
        return this;
      }
      if (typeof types === "object") {
        for (type in types) {
          this.off(type, selector, types[type]);
        }
        return this;
      }
      if (selector === false || typeof selector === "function") {
        fn = selector;
        selector = undefined;
      }
      if (fn === false) {
        fn = returnFalse;
      }
      return this.each(function() {
        jQuery.event.remove(this, types, fn, selector);
      });
    },
    trigger: function(type, data) {
      return this.each(function() {
        jQuery.event.trigger(type, data, this);
      });
    },
    triggerHandler: function(type, data) {
      var elem = this[0];
      if (elem) {
        return jQuery.event.trigger(type, data, elem, true);
      }
    }
  });
  var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
      rtagName = /<([\w:]+)/,
      rhtml = /<|&#?\w+;/,
      rnoInnerhtml = /<(?:script|style|link)/i,
      rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
      rscriptType = /^$|\/(?:java|ecma)script/i,
      rscriptTypeMasked = /^true\/(.*)/,
      rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
      wrapMap = {
        option: [1, "<select multiple='multiple'>", "</select>"],
        thead: [1, "<table>", "</table>"],
        col: [2, "<table><colgroup>", "</colgroup></table>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
        _default: [0, "", ""]
      };
  wrapMap.optgroup = wrapMap.option;
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;
  function manipulationTarget(elem, content) {
    return jQuery.nodeName(elem, "table") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem;
  }
  function disableScript(elem) {
    elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
    return elem;
  }
  function restoreScript(elem) {
    var match = rscriptTypeMasked.exec(elem.type);
    if (match) {
      elem.type = match[1];
    } else {
      elem.removeAttribute("type");
    }
    return elem;
  }
  function setGlobalEval(elems, refElements) {
    var i = 0,
        l = elems.length;
    for (; i < l; i++) {
      data_priv.set(elems[i], "globalEval", !refElements || data_priv.get(refElements[i], "globalEval"));
    }
  }
  function cloneCopyEvent(src, dest) {
    var i,
        l,
        type,
        pdataOld,
        pdataCur,
        udataOld,
        udataCur,
        events;
    if (dest.nodeType !== 1) {
      return ;
    }
    if (data_priv.hasData(src)) {
      pdataOld = data_priv.access(src);
      pdataCur = data_priv.set(dest, pdataOld);
      events = pdataOld.events;
      if (events) {
        delete pdataCur.handle;
        pdataCur.events = {};
        for (type in events) {
          for (i = 0, l = events[type].length; i < l; i++) {
            jQuery.event.add(dest, type, events[type][i]);
          }
        }
      }
    }
    if (data_user.hasData(src)) {
      udataOld = data_user.access(src);
      udataCur = jQuery.extend({}, udataOld);
      data_user.set(dest, udataCur);
    }
  }
  function getAll(context, tag) {
    var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || "*") : context.querySelectorAll ? context.querySelectorAll(tag || "*") : [];
    return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret;
  }
  function fixInput(src, dest) {
    var nodeName = dest.nodeName.toLowerCase();
    if (nodeName === "input" && rcheckableType.test(src.type)) {
      dest.checked = src.checked;
    } else if (nodeName === "input" || nodeName === "textarea") {
      dest.defaultValue = src.defaultValue;
    }
  }
  jQuery.extend({
    clone: function(elem, dataAndEvents, deepDataAndEvents) {
      var i,
          l,
          srcElements,
          destElements,
          clone = elem.cloneNode(true),
          inPage = jQuery.contains(elem.ownerDocument, elem);
      if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
        destElements = getAll(clone);
        srcElements = getAll(elem);
        for (i = 0, l = srcElements.length; i < l; i++) {
          fixInput(srcElements[i], destElements[i]);
        }
      }
      if (dataAndEvents) {
        if (deepDataAndEvents) {
          srcElements = srcElements || getAll(elem);
          destElements = destElements || getAll(clone);
          for (i = 0, l = srcElements.length; i < l; i++) {
            cloneCopyEvent(srcElements[i], destElements[i]);
          }
        } else {
          cloneCopyEvent(elem, clone);
        }
      }
      destElements = getAll(clone, "script");
      if (destElements.length > 0) {
        setGlobalEval(destElements, !inPage && getAll(elem, "script"));
      }
      return clone;
    },
    buildFragment: function(elems, context, scripts, selection) {
      var elem,
          tmp,
          tag,
          wrap,
          contains,
          j,
          fragment = context.createDocumentFragment(),
          nodes = [],
          i = 0,
          l = elems.length;
      for (; i < l; i++) {
        elem = elems[i];
        if (elem || elem === 0) {
          if (jQuery.type(elem) === "object") {
            jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
          } else if (!rhtml.test(elem)) {
            nodes.push(context.createTextNode(elem));
          } else {
            tmp = tmp || fragment.appendChild(context.createElement("div"));
            tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
            wrap = wrapMap[tag] || wrapMap._default;
            tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2];
            j = wrap[0];
            while (j--) {
              tmp = tmp.lastChild;
            }
            jQuery.merge(nodes, tmp.childNodes);
            tmp = fragment.firstChild;
            tmp.textContent = "";
          }
        }
      }
      fragment.textContent = "";
      i = 0;
      while ((elem = nodes[i++])) {
        if (selection && jQuery.inArray(elem, selection) !== -1) {
          continue;
        }
        contains = jQuery.contains(elem.ownerDocument, elem);
        tmp = getAll(fragment.appendChild(elem), "script");
        if (contains) {
          setGlobalEval(tmp);
        }
        if (scripts) {
          j = 0;
          while ((elem = tmp[j++])) {
            if (rscriptType.test(elem.type || "")) {
              scripts.push(elem);
            }
          }
        }
      }
      return fragment;
    },
    cleanData: function(elems) {
      var data,
          elem,
          type,
          key,
          special = jQuery.event.special,
          i = 0;
      for (; (elem = elems[i]) !== undefined; i++) {
        if (jQuery.acceptData(elem)) {
          key = elem[data_priv.expando];
          if (key && (data = data_priv.cache[key])) {
            if (data.events) {
              for (type in data.events) {
                if (special[type]) {
                  jQuery.event.remove(elem, type);
                } else {
                  jQuery.removeEvent(elem, type, data.handle);
                }
              }
            }
            if (data_priv.cache[key]) {
              delete data_priv.cache[key];
            }
          }
        }
        delete data_user.cache[elem[data_user.expando]];
      }
    }
  });
  jQuery.fn.extend({
    text: function(value) {
      return access(this, function(value) {
        return value === undefined ? jQuery.text(this) : this.empty().each(function() {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            this.textContent = value;
          }
        });
      }, null, value, arguments.length);
    },
    append: function() {
      return this.domManip(arguments, function(elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.appendChild(elem);
        }
      });
    },
    prepend: function() {
      return this.domManip(arguments, function(elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.insertBefore(elem, target.firstChild);
        }
      });
    },
    before: function() {
      return this.domManip(arguments, function(elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this);
        }
      });
    },
    after: function() {
      return this.domManip(arguments, function(elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this.nextSibling);
        }
      });
    },
    remove: function(selector, keepData) {
      var elem,
          elems = selector ? jQuery.filter(selector, this) : this,
          i = 0;
      for (; (elem = elems[i]) != null; i++) {
        if (!keepData && elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem));
        }
        if (elem.parentNode) {
          if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
            setGlobalEval(getAll(elem, "script"));
          }
          elem.parentNode.removeChild(elem);
        }
      }
      return this;
    },
    empty: function() {
      var elem,
          i = 0;
      for (; (elem = this[i]) != null; i++) {
        if (elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem, false));
          elem.textContent = "";
        }
      }
      return this;
    },
    clone: function(dataAndEvents, deepDataAndEvents) {
      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
      return this.map(function() {
        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
      });
    },
    html: function(value) {
      return access(this, function(value) {
        var elem = this[0] || {},
            i = 0,
            l = this.length;
        if (value === undefined && elem.nodeType === 1) {
          return elem.innerHTML;
        }
        if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
          value = value.replace(rxhtmlTag, "<$1></$2>");
          try {
            for (; i < l; i++) {
              elem = this[i] || {};
              if (elem.nodeType === 1) {
                jQuery.cleanData(getAll(elem, false));
                elem.innerHTML = value;
              }
            }
            elem = 0;
          } catch (e) {}
        }
        if (elem) {
          this.empty().append(value);
        }
      }, null, value, arguments.length);
    },
    replaceWith: function() {
      var arg = arguments[0];
      this.domManip(arguments, function(elem) {
        arg = this.parentNode;
        jQuery.cleanData(getAll(this));
        if (arg) {
          arg.replaceChild(elem, this);
        }
      });
      return arg && (arg.length || arg.nodeType) ? this : this.remove();
    },
    detach: function(selector) {
      return this.remove(selector, true);
    },
    domManip: function(args, callback) {
      args = concat.apply([], args);
      var fragment,
          first,
          scripts,
          hasScripts,
          node,
          doc,
          i = 0,
          l = this.length,
          set = this,
          iNoClone = l - 1,
          value = args[0],
          isFunction = jQuery.isFunction(value);
      if (isFunction || (l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value))) {
        return this.each(function(index) {
          var self = set.eq(index);
          if (isFunction) {
            args[0] = value.call(this, index, self.html());
          }
          self.domManip(args, callback);
        });
      }
      if (l) {
        fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);
        first = fragment.firstChild;
        if (fragment.childNodes.length === 1) {
          fragment = first;
        }
        if (first) {
          scripts = jQuery.map(getAll(fragment, "script"), disableScript);
          hasScripts = scripts.length;
          for (; i < l; i++) {
            node = fragment;
            if (i !== iNoClone) {
              node = jQuery.clone(node, true, true);
              if (hasScripts) {
                jQuery.merge(scripts, getAll(node, "script"));
              }
            }
            callback.call(this[i], node, i);
          }
          if (hasScripts) {
            doc = scripts[scripts.length - 1].ownerDocument;
            jQuery.map(scripts, restoreScript);
            for (i = 0; i < hasScripts; i++) {
              node = scripts[i];
              if (rscriptType.test(node.type || "") && !data_priv.access(node, "globalEval") && jQuery.contains(doc, node)) {
                if (node.src) {
                  if (jQuery._evalUrl) {
                    jQuery._evalUrl(node.src);
                  }
                } else {
                  jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
                }
              }
            }
          }
        }
      }
      return this;
    }
  });
  jQuery.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function(name, original) {
    jQuery.fn[name] = function(selector) {
      var elems,
          ret = [],
          insert = jQuery(selector),
          last = insert.length - 1,
          i = 0;
      for (; i <= last; i++) {
        elems = i === last ? this : this.clone(true);
        jQuery(insert[i])[original](elems);
        push.apply(ret, elems.get());
      }
      return this.pushStack(ret);
    };
  });
  var iframe,
      elemdisplay = {};
  function actualDisplay(name, doc) {
    var style,
        elem = jQuery(doc.createElement(name)).appendTo(doc.body),
        display = window.getDefaultComputedStyle && (style = window.getDefaultComputedStyle(elem[0])) ? style.display : jQuery.css(elem[0], "display");
    elem.detach();
    return display;
  }
  function defaultDisplay(nodeName) {
    var doc = document,
        display = elemdisplay[nodeName];
    if (!display) {
      display = actualDisplay(nodeName, doc);
      if (display === "none" || !display) {
        iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);
        doc = iframe[0].contentDocument;
        doc.write();
        doc.close();
        display = actualDisplay(nodeName, doc);
        iframe.detach();
      }
      elemdisplay[nodeName] = display;
    }
    return display;
  }
  var rmargin = (/^margin/);
  var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
  var getStyles = function(elem) {
    if (elem.ownerDocument.defaultView.opener) {
      return elem.ownerDocument.defaultView.getComputedStyle(elem, null);
    }
    return window.getComputedStyle(elem, null);
  };
  function curCSS(elem, name, computed) {
    var width,
        minWidth,
        maxWidth,
        ret,
        style = elem.style;
    computed = computed || getStyles(elem);
    if (computed) {
      ret = computed.getPropertyValue(name) || computed[name];
    }
    if (computed) {
      if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
        ret = jQuery.style(elem, name);
      }
      if (rnumnonpx.test(ret) && rmargin.test(name)) {
        width = style.width;
        minWidth = style.minWidth;
        maxWidth = style.maxWidth;
        style.minWidth = style.maxWidth = style.width = ret;
        ret = computed.width;
        style.width = width;
        style.minWidth = minWidth;
        style.maxWidth = maxWidth;
      }
    }
    return ret !== undefined ? ret + "" : ret;
  }
  function addGetHookIf(conditionFn, hookFn) {
    return {get: function() {
        if (conditionFn()) {
          delete this.get;
          return ;
        }
        return (this.get = hookFn).apply(this, arguments);
      }};
  }
  (function() {
    var pixelPositionVal,
        boxSizingReliableVal,
        docElem = document.documentElement,
        container = document.createElement("div"),
        div = document.createElement("div");
    if (!div.style) {
      return ;
    }
    div.style.backgroundClip = "content-box";
    div.cloneNode(true).style.backgroundClip = "";
    support.clearCloneStyle = div.style.backgroundClip === "content-box";
    container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" + "position:absolute";
    container.appendChild(div);
    function computePixelPositionAndBoxSizingReliable() {
      div.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" + "box-sizing:border-box;display:block;margin-top:1%;top:1%;" + "border:1px;padding:1px;width:4px;position:absolute";
      div.innerHTML = "";
      docElem.appendChild(container);
      var divStyle = window.getComputedStyle(div, null);
      pixelPositionVal = divStyle.top !== "1%";
      boxSizingReliableVal = divStyle.width === "4px";
      docElem.removeChild(container);
    }
    if (window.getComputedStyle) {
      jQuery.extend(support, {
        pixelPosition: function() {
          computePixelPositionAndBoxSizingReliable();
          return pixelPositionVal;
        },
        boxSizingReliable: function() {
          if (boxSizingReliableVal == null) {
            computePixelPositionAndBoxSizingReliable();
          }
          return boxSizingReliableVal;
        },
        reliableMarginRight: function() {
          var ret,
              marginDiv = div.appendChild(document.createElement("div"));
          marginDiv.style.cssText = div.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" + "box-sizing:content-box;display:block;margin:0;border:0;padding:0";
          marginDiv.style.marginRight = marginDiv.style.width = "0";
          div.style.width = "1px";
          docElem.appendChild(container);
          ret = !parseFloat(window.getComputedStyle(marginDiv, null).marginRight);
          docElem.removeChild(container);
          div.removeChild(marginDiv);
          return ret;
        }
      });
    }
  })();
  jQuery.swap = function(elem, options, callback, args) {
    var ret,
        name,
        old = {};
    for (name in options) {
      old[name] = elem.style[name];
      elem.style[name] = options[name];
    }
    ret = callback.apply(elem, args || []);
    for (name in options) {
      elem.style[name] = old[name];
    }
    return ret;
  };
  var rdisplayswap = /^(none|table(?!-c[ea]).+)/,
      rnumsplit = new RegExp("^(" + pnum + ")(.*)$", "i"),
      rrelNum = new RegExp("^([+-])=(" + pnum + ")", "i"),
      cssShow = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
      },
      cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
      },
      cssPrefixes = ["Webkit", "O", "Moz", "ms"];
  function vendorPropName(style, name) {
    if (name in style) {
      return name;
    }
    var capName = name[0].toUpperCase() + name.slice(1),
        origName = name,
        i = cssPrefixes.length;
    while (i--) {
      name = cssPrefixes[i] + capName;
      if (name in style) {
        return name;
      }
    }
    return origName;
  }
  function setPositiveNumber(elem, value, subtract) {
    var matches = rnumsplit.exec(value);
    return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") : value;
  }
  function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
    var i = extra === (isBorderBox ? "border" : "content") ? 4 : name === "width" ? 1 : 0,
        val = 0;
    for (; i < 4; i += 2) {
      if (extra === "margin") {
        val += jQuery.css(elem, extra + cssExpand[i], true, styles);
      }
      if (isBorderBox) {
        if (extra === "content") {
          val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        }
        if (extra !== "margin") {
          val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      } else {
        val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        if (extra !== "padding") {
          val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      }
    }
    return val;
  }
  function getWidthOrHeight(elem, name, extra) {
    var valueIsBorderBox = true,
        val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
        styles = getStyles(elem),
        isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
    if (val <= 0 || val == null) {
      val = curCSS(elem, name, styles);
      if (val < 0 || val == null) {
        val = elem.style[name];
      }
      if (rnumnonpx.test(val)) {
        return val;
      }
      valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);
      val = parseFloat(val) || 0;
    }
    return (val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles)) + "px";
  }
  function showHide(elements, show) {
    var display,
        elem,
        hidden,
        values = [],
        index = 0,
        length = elements.length;
    for (; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      values[index] = data_priv.get(elem, "olddisplay");
      display = elem.style.display;
      if (show) {
        if (!values[index] && display === "none") {
          elem.style.display = "";
        }
        if (elem.style.display === "" && isHidden(elem)) {
          values[index] = data_priv.access(elem, "olddisplay", defaultDisplay(elem.nodeName));
        }
      } else {
        hidden = isHidden(elem);
        if (display !== "none" || !hidden) {
          data_priv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
        }
      }
    }
    for (index = 0; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      if (!show || elem.style.display === "none" || elem.style.display === "") {
        elem.style.display = show ? values[index] || "" : "none";
      }
    }
    return elements;
  }
  jQuery.extend({
    cssHooks: {opacity: {get: function(elem, computed) {
          if (computed) {
            var ret = curCSS(elem, "opacity");
            return ret === "" ? "1" : ret;
          }
        }}},
    cssNumber: {
      "columnCount": true,
      "fillOpacity": true,
      "flexGrow": true,
      "flexShrink": true,
      "fontWeight": true,
      "lineHeight": true,
      "opacity": true,
      "order": true,
      "orphans": true,
      "widows": true,
      "zIndex": true,
      "zoom": true
    },
    cssProps: {"float": "cssFloat"},
    style: function(elem, name, value, extra) {
      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
        return ;
      }
      var ret,
          type,
          hooks,
          origName = jQuery.camelCase(name),
          style = elem.style;
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (value !== undefined) {
        type = typeof value;
        if (type === "string" && (ret = rrelNum.exec(value))) {
          value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
          type = "number";
        }
        if (value == null || value !== value) {
          return ;
        }
        if (type === "number" && !jQuery.cssNumber[origName]) {
          value += "px";
        }
        if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
          style[name] = "inherit";
        }
        if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
          style[name] = value;
        }
      } else {
        if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
          return ret;
        }
        return style[name];
      }
    },
    css: function(elem, name, extra, styles) {
      var val,
          num,
          hooks,
          origName = jQuery.camelCase(name);
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (hooks && "get" in hooks) {
        val = hooks.get(elem, true, extra);
      }
      if (val === undefined) {
        val = curCSS(elem, name, styles);
      }
      if (val === "normal" && name in cssNormalTransform) {
        val = cssNormalTransform[name];
      }
      if (extra === "" || extra) {
        num = parseFloat(val);
        return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
      }
      return val;
    }
  });
  jQuery.each(["height", "width"], function(i, name) {
    jQuery.cssHooks[name] = {
      get: function(elem, computed, extra) {
        if (computed) {
          return rdisplayswap.test(jQuery.css(elem, "display")) && elem.offsetWidth === 0 ? jQuery.swap(elem, cssShow, function() {
            return getWidthOrHeight(elem, name, extra);
          }) : getWidthOrHeight(elem, name, extra);
        }
      },
      set: function(elem, value, extra) {
        var styles = extra && getStyles(elem);
        return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles) : 0);
      }
    };
  });
  jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function(elem, computed) {
    if (computed) {
      return jQuery.swap(elem, {"display": "inline-block"}, curCSS, [elem, "marginRight"]);
    }
  });
  jQuery.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function(prefix, suffix) {
    jQuery.cssHooks[prefix + suffix] = {expand: function(value) {
        var i = 0,
            expanded = {},
            parts = typeof value === "string" ? value.split(" ") : [value];
        for (; i < 4; i++) {
          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
        }
        return expanded;
      }};
    if (!rmargin.test(prefix)) {
      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    }
  });
  jQuery.fn.extend({
    css: function(name, value) {
      return access(this, function(elem, name, value) {
        var styles,
            len,
            map = {},
            i = 0;
        if (jQuery.isArray(name)) {
          styles = getStyles(elem);
          len = name.length;
          for (; i < len; i++) {
            map[name[i]] = jQuery.css(elem, name[i], false, styles);
          }
          return map;
        }
        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
      }, name, value, arguments.length > 1);
    },
    show: function() {
      return showHide(this, true);
    },
    hide: function() {
      return showHide(this);
    },
    toggle: function(state) {
      if (typeof state === "boolean") {
        return state ? this.show() : this.hide();
      }
      return this.each(function() {
        if (isHidden(this)) {
          jQuery(this).show();
        } else {
          jQuery(this).hide();
        }
      });
    }
  });
  function Tween(elem, options, prop, end, easing) {
    return new Tween.prototype.init(elem, options, prop, end, easing);
  }
  jQuery.Tween = Tween;
  Tween.prototype = {
    constructor: Tween,
    init: function(elem, options, prop, end, easing, unit) {
      this.elem = elem;
      this.prop = prop;
      this.easing = easing || "swing";
      this.options = options;
      this.start = this.now = this.cur();
      this.end = end;
      this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
    },
    cur: function() {
      var hooks = Tween.propHooks[this.prop];
      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
    },
    run: function(percent) {
      var eased,
          hooks = Tween.propHooks[this.prop];
      if (this.options.duration) {
        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
      } else {
        this.pos = eased = percent;
      }
      this.now = (this.end - this.start) * eased + this.start;
      if (this.options.step) {
        this.options.step.call(this.elem, this.now, this);
      }
      if (hooks && hooks.set) {
        hooks.set(this);
      } else {
        Tween.propHooks._default.set(this);
      }
      return this;
    }
  };
  Tween.prototype.init.prototype = Tween.prototype;
  Tween.propHooks = {_default: {
      get: function(tween) {
        var result;
        if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
          return tween.elem[tween.prop];
        }
        result = jQuery.css(tween.elem, tween.prop, "");
        return !result || result === "auto" ? 0 : result;
      },
      set: function(tween) {
        if (jQuery.fx.step[tween.prop]) {
          jQuery.fx.step[tween.prop](tween);
        } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
        } else {
          tween.elem[tween.prop] = tween.now;
        }
      }
    }};
  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {set: function(tween) {
      if (tween.elem.nodeType && tween.elem.parentNode) {
        tween.elem[tween.prop] = tween.now;
      }
    }};
  jQuery.easing = {
    linear: function(p) {
      return p;
    },
    swing: function(p) {
      return 0.5 - Math.cos(p * Math.PI) / 2;
    }
  };
  jQuery.fx = Tween.prototype.init;
  jQuery.fx.step = {};
  var fxNow,
      timerId,
      rfxtypes = /^(?:toggle|show|hide)$/,
      rfxnum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"),
      rrun = /queueHooks$/,
      animationPrefilters = [defaultPrefilter],
      tweeners = {"*": [function(prop, value) {
          var tween = this.createTween(prop, value),
              target = tween.cur(),
              parts = rfxnum.exec(value),
              unit = parts && parts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
              start = (jQuery.cssNumber[prop] || unit !== "px" && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)),
              scale = 1,
              maxIterations = 20;
          if (start && start[3] !== unit) {
            unit = unit || start[3];
            parts = parts || [];
            start = +target || 1;
            do {
              scale = scale || ".5";
              start = start / scale;
              jQuery.style(tween.elem, prop, start + unit);
            } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
          }
          if (parts) {
            start = tween.start = +start || +target || 0;
            tween.unit = unit;
            tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2];
          }
          return tween;
        }]};
  function createFxNow() {
    setTimeout(function() {
      fxNow = undefined;
    });
    return (fxNow = jQuery.now());
  }
  function genFx(type, includeWidth) {
    var which,
        i = 0,
        attrs = {height: type};
    includeWidth = includeWidth ? 1 : 0;
    for (; i < 4; i += 2 - includeWidth) {
      which = cssExpand[i];
      attrs["margin" + which] = attrs["padding" + which] = type;
    }
    if (includeWidth) {
      attrs.opacity = attrs.width = type;
    }
    return attrs;
  }
  function createTween(value, prop, animation) {
    var tween,
        collection = (tweeners[prop] || []).concat(tweeners["*"]),
        index = 0,
        length = collection.length;
    for (; index < length; index++) {
      if ((tween = collection[index].call(animation, prop, value))) {
        return tween;
      }
    }
  }
  function defaultPrefilter(elem, props, opts) {
    var prop,
        value,
        toggle,
        tween,
        hooks,
        oldfire,
        display,
        checkDisplay,
        anim = this,
        orig = {},
        style = elem.style,
        hidden = elem.nodeType && isHidden(elem),
        dataShow = data_priv.get(elem, "fxshow");
    if (!opts.queue) {
      hooks = jQuery._queueHooks(elem, "fx");
      if (hooks.unqueued == null) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;
        hooks.empty.fire = function() {
          if (!hooks.unqueued) {
            oldfire();
          }
        };
      }
      hooks.unqueued++;
      anim.always(function() {
        anim.always(function() {
          hooks.unqueued--;
          if (!jQuery.queue(elem, "fx").length) {
            hooks.empty.fire();
          }
        });
      });
    }
    if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
      opts.overflow = [style.overflow, style.overflowX, style.overflowY];
      display = jQuery.css(elem, "display");
      checkDisplay = display === "none" ? data_priv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;
      if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
        style.display = "inline-block";
      }
    }
    if (opts.overflow) {
      style.overflow = "hidden";
      anim.always(function() {
        style.overflow = opts.overflow[0];
        style.overflowX = opts.overflow[1];
        style.overflowY = opts.overflow[2];
      });
    }
    for (prop in props) {
      value = props[prop];
      if (rfxtypes.exec(value)) {
        delete props[prop];
        toggle = toggle || value === "toggle";
        if (value === (hidden ? "hide" : "show")) {
          if (value === "show" && dataShow && dataShow[prop] !== undefined) {
            hidden = true;
          } else {
            continue;
          }
        }
        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
      } else {
        display = undefined;
      }
    }
    if (!jQuery.isEmptyObject(orig)) {
      if (dataShow) {
        if ("hidden" in dataShow) {
          hidden = dataShow.hidden;
        }
      } else {
        dataShow = data_priv.access(elem, "fxshow", {});
      }
      if (toggle) {
        dataShow.hidden = !hidden;
      }
      if (hidden) {
        jQuery(elem).show();
      } else {
        anim.done(function() {
          jQuery(elem).hide();
        });
      }
      anim.done(function() {
        var prop;
        data_priv.remove(elem, "fxshow");
        for (prop in orig) {
          jQuery.style(elem, prop, orig[prop]);
        }
      });
      for (prop in orig) {
        tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
        if (!(prop in dataShow)) {
          dataShow[prop] = tween.start;
          if (hidden) {
            tween.end = tween.start;
            tween.start = prop === "width" || prop === "height" ? 1 : 0;
          }
        }
      }
    } else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
      style.display = display;
    }
  }
  function propFilter(props, specialEasing) {
    var index,
        name,
        easing,
        value,
        hooks;
    for (index in props) {
      name = jQuery.camelCase(index);
      easing = specialEasing[name];
      value = props[index];
      if (jQuery.isArray(value)) {
        easing = value[1];
        value = props[index] = value[0];
      }
      if (index !== name) {
        props[name] = value;
        delete props[index];
      }
      hooks = jQuery.cssHooks[name];
      if (hooks && "expand" in hooks) {
        value = hooks.expand(value);
        delete props[name];
        for (index in value) {
          if (!(index in props)) {
            props[index] = value[index];
            specialEasing[index] = easing;
          }
        }
      } else {
        specialEasing[name] = easing;
      }
    }
  }
  function Animation(elem, properties, options) {
    var result,
        stopped,
        index = 0,
        length = animationPrefilters.length,
        deferred = jQuery.Deferred().always(function() {
          delete tick.elem;
        }),
        tick = function() {
          if (stopped) {
            return false;
          }
          var currentTime = fxNow || createFxNow(),
              remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
              temp = remaining / animation.duration || 0,
              percent = 1 - temp,
              index = 0,
              length = animation.tweens.length;
          for (; index < length; index++) {
            animation.tweens[index].run(percent);
          }
          deferred.notifyWith(elem, [animation, percent, remaining]);
          if (percent < 1 && length) {
            return remaining;
          } else {
            deferred.resolveWith(elem, [animation]);
            return false;
          }
        },
        animation = deferred.promise({
          elem: elem,
          props: jQuery.extend({}, properties),
          opts: jQuery.extend(true, {specialEasing: {}}, options),
          originalProperties: properties,
          originalOptions: options,
          startTime: fxNow || createFxNow(),
          duration: options.duration,
          tweens: [],
          createTween: function(prop, end) {
            var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
            animation.tweens.push(tween);
            return tween;
          },
          stop: function(gotoEnd) {
            var index = 0,
                length = gotoEnd ? animation.tweens.length : 0;
            if (stopped) {
              return this;
            }
            stopped = true;
            for (; index < length; index++) {
              animation.tweens[index].run(1);
            }
            if (gotoEnd) {
              deferred.resolveWith(elem, [animation, gotoEnd]);
            } else {
              deferred.rejectWith(elem, [animation, gotoEnd]);
            }
            return this;
          }
        }),
        props = animation.props;
    propFilter(props, animation.opts.specialEasing);
    for (; index < length; index++) {
      result = animationPrefilters[index].call(animation, elem, props, animation.opts);
      if (result) {
        return result;
      }
    }
    jQuery.map(props, createTween, animation);
    if (jQuery.isFunction(animation.opts.start)) {
      animation.opts.start.call(elem, animation);
    }
    jQuery.fx.timer(jQuery.extend(tick, {
      elem: elem,
      anim: animation,
      queue: animation.opts.queue
    }));
    return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
  }
  jQuery.Animation = jQuery.extend(Animation, {
    tweener: function(props, callback) {
      if (jQuery.isFunction(props)) {
        callback = props;
        props = ["*"];
      } else {
        props = props.split(" ");
      }
      var prop,
          index = 0,
          length = props.length;
      for (; index < length; index++) {
        prop = props[index];
        tweeners[prop] = tweeners[prop] || [];
        tweeners[prop].unshift(callback);
      }
    },
    prefilter: function(callback, prepend) {
      if (prepend) {
        animationPrefilters.unshift(callback);
      } else {
        animationPrefilters.push(callback);
      }
    }
  });
  jQuery.speed = function(speed, easing, fn) {
    var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
      complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
      duration: speed,
      easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
    };
    opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
    if (opt.queue == null || opt.queue === true) {
      opt.queue = "fx";
    }
    opt.old = opt.complete;
    opt.complete = function() {
      if (jQuery.isFunction(opt.old)) {
        opt.old.call(this);
      }
      if (opt.queue) {
        jQuery.dequeue(this, opt.queue);
      }
    };
    return opt;
  };
  jQuery.fn.extend({
    fadeTo: function(speed, to, easing, callback) {
      return this.filter(isHidden).css("opacity", 0).show().end().animate({opacity: to}, speed, easing, callback);
    },
    animate: function(prop, speed, easing, callback) {
      var empty = jQuery.isEmptyObject(prop),
          optall = jQuery.speed(speed, easing, callback),
          doAnimation = function() {
            var anim = Animation(this, jQuery.extend({}, prop), optall);
            if (empty || data_priv.get(this, "finish")) {
              anim.stop(true);
            }
          };
      doAnimation.finish = doAnimation;
      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
    },
    stop: function(type, clearQueue, gotoEnd) {
      var stopQueue = function(hooks) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop(gotoEnd);
      };
      if (typeof type !== "string") {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
      }
      if (clearQueue && type !== false) {
        this.queue(type || "fx", []);
      }
      return this.each(function() {
        var dequeue = true,
            index = type != null && type + "queueHooks",
            timers = jQuery.timers,
            data = data_priv.get(this);
        if (index) {
          if (data[index] && data[index].stop) {
            stopQueue(data[index]);
          }
        } else {
          for (index in data) {
            if (data[index] && data[index].stop && rrun.test(index)) {
              stopQueue(data[index]);
            }
          }
        }
        for (index = timers.length; index--; ) {
          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
            timers[index].anim.stop(gotoEnd);
            dequeue = false;
            timers.splice(index, 1);
          }
        }
        if (dequeue || !gotoEnd) {
          jQuery.dequeue(this, type);
        }
      });
    },
    finish: function(type) {
      if (type !== false) {
        type = type || "fx";
      }
      return this.each(function() {
        var index,
            data = data_priv.get(this),
            queue = data[type + "queue"],
            hooks = data[type + "queueHooks"],
            timers = jQuery.timers,
            length = queue ? queue.length : 0;
        data.finish = true;
        jQuery.queue(this, type, []);
        if (hooks && hooks.stop) {
          hooks.stop.call(this, true);
        }
        for (index = timers.length; index--; ) {
          if (timers[index].elem === this && timers[index].queue === type) {
            timers[index].anim.stop(true);
            timers.splice(index, 1);
          }
        }
        for (index = 0; index < length; index++) {
          if (queue[index] && queue[index].finish) {
            queue[index].finish.call(this);
          }
        }
        delete data.finish;
      });
    }
  });
  jQuery.each(["toggle", "show", "hide"], function(i, name) {
    var cssFn = jQuery.fn[name];
    jQuery.fn[name] = function(speed, easing, callback) {
      return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
    };
  });
  jQuery.each({
    slideDown: genFx("show"),
    slideUp: genFx("hide"),
    slideToggle: genFx("toggle"),
    fadeIn: {opacity: "show"},
    fadeOut: {opacity: "hide"},
    fadeToggle: {opacity: "toggle"}
  }, function(name, props) {
    jQuery.fn[name] = function(speed, easing, callback) {
      return this.animate(props, speed, easing, callback);
    };
  });
  jQuery.timers = [];
  jQuery.fx.tick = function() {
    var timer,
        i = 0,
        timers = jQuery.timers;
    fxNow = jQuery.now();
    for (; i < timers.length; i++) {
      timer = timers[i];
      if (!timer() && timers[i] === timer) {
        timers.splice(i--, 1);
      }
    }
    if (!timers.length) {
      jQuery.fx.stop();
    }
    fxNow = undefined;
  };
  jQuery.fx.timer = function(timer) {
    jQuery.timers.push(timer);
    if (timer()) {
      jQuery.fx.start();
    } else {
      jQuery.timers.pop();
    }
  };
  jQuery.fx.interval = 13;
  jQuery.fx.start = function() {
    if (!timerId) {
      timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
    }
  };
  jQuery.fx.stop = function() {
    clearInterval(timerId);
    timerId = null;
  };
  jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
    _default: 400
  };
  jQuery.fn.delay = function(time, type) {
    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
    type = type || "fx";
    return this.queue(type, function(next, hooks) {
      var timeout = setTimeout(next, time);
      hooks.stop = function() {
        clearTimeout(timeout);
      };
    });
  };
  (function() {
    var input = document.createElement("input"),
        select = document.createElement("select"),
        opt = select.appendChild(document.createElement("option"));
    input.type = "checkbox";
    support.checkOn = input.value !== "";
    support.optSelected = opt.selected;
    select.disabled = true;
    support.optDisabled = !opt.disabled;
    input = document.createElement("input");
    input.value = "t";
    input.type = "radio";
    support.radioValue = input.value === "t";
  })();
  var nodeHook,
      boolHook,
      attrHandle = jQuery.expr.attrHandle;
  jQuery.fn.extend({
    attr: function(name, value) {
      return access(this, jQuery.attr, name, value, arguments.length > 1);
    },
    removeAttr: function(name) {
      return this.each(function() {
        jQuery.removeAttr(this, name);
      });
    }
  });
  jQuery.extend({
    attr: function(elem, name, value) {
      var hooks,
          ret,
          nType = elem.nodeType;
      if (!elem || nType === 3 || nType === 8 || nType === 2) {
        return ;
      }
      if (typeof elem.getAttribute === strundefined) {
        return jQuery.prop(elem, name, value);
      }
      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        name = name.toLowerCase();
        hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
      }
      if (value !== undefined) {
        if (value === null) {
          jQuery.removeAttr(elem, name);
        } else if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        } else {
          elem.setAttribute(name, value + "");
          return value;
        }
      } else if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      } else {
        ret = jQuery.find.attr(elem, name);
        return ret == null ? undefined : ret;
      }
    },
    removeAttr: function(elem, value) {
      var name,
          propName,
          i = 0,
          attrNames = value && value.match(rnotwhite);
      if (attrNames && elem.nodeType === 1) {
        while ((name = attrNames[i++])) {
          propName = jQuery.propFix[name] || name;
          if (jQuery.expr.match.bool.test(name)) {
            elem[propName] = false;
          }
          elem.removeAttribute(name);
        }
      }
    },
    attrHooks: {type: {set: function(elem, value) {
          if (!support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
            var val = elem.value;
            elem.setAttribute("type", value);
            if (val) {
              elem.value = val;
            }
            return value;
          }
        }}}
  });
  boolHook = {set: function(elem, value, name) {
      if (value === false) {
        jQuery.removeAttr(elem, name);
      } else {
        elem.setAttribute(name, name);
      }
      return name;
    }};
  jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
    var getter = attrHandle[name] || jQuery.find.attr;
    attrHandle[name] = function(elem, name, isXML) {
      var ret,
          handle;
      if (!isXML) {
        handle = attrHandle[name];
        attrHandle[name] = ret;
        ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
        attrHandle[name] = handle;
      }
      return ret;
    };
  });
  var rfocusable = /^(?:input|select|textarea|button)$/i;
  jQuery.fn.extend({
    prop: function(name, value) {
      return access(this, jQuery.prop, name, value, arguments.length > 1);
    },
    removeProp: function(name) {
      return this.each(function() {
        delete this[jQuery.propFix[name] || name];
      });
    }
  });
  jQuery.extend({
    propFix: {
      "for": "htmlFor",
      "class": "className"
    },
    prop: function(elem, name, value) {
      var ret,
          hooks,
          notxml,
          nType = elem.nodeType;
      if (!elem || nType === 3 || nType === 8 || nType === 2) {
        return ;
      }
      notxml = nType !== 1 || !jQuery.isXMLDoc(elem);
      if (notxml) {
        name = jQuery.propFix[name] || name;
        hooks = jQuery.propHooks[name];
      }
      if (value !== undefined) {
        return hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : (elem[name] = value);
      } else {
        return hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name];
      }
    },
    propHooks: {tabIndex: {get: function(elem) {
          return elem.hasAttribute("tabindex") || rfocusable.test(elem.nodeName) || elem.href ? elem.tabIndex : -1;
        }}}
  });
  if (!support.optSelected) {
    jQuery.propHooks.selected = {get: function(elem) {
        var parent = elem.parentNode;
        if (parent && parent.parentNode) {
          parent.parentNode.selectedIndex;
        }
        return null;
      }};
  }
  jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
    jQuery.propFix[this.toLowerCase()] = this;
  });
  var rclass = /[\t\r\n\f]/g;
  jQuery.fn.extend({
    addClass: function(value) {
      var classes,
          elem,
          cur,
          clazz,
          j,
          finalValue,
          proceed = typeof value === "string" && value,
          i = 0,
          len = this.length;
      if (jQuery.isFunction(value)) {
        return this.each(function(j) {
          jQuery(this).addClass(value.call(this, j, this.className));
        });
      }
      if (proceed) {
        classes = (value || "").match(rnotwhite) || [];
        for (; i < len; i++) {
          elem = this[i];
          cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : " ");
          if (cur) {
            j = 0;
            while ((clazz = classes[j++])) {
              if (cur.indexOf(" " + clazz + " ") < 0) {
                cur += clazz + " ";
              }
            }
            finalValue = jQuery.trim(cur);
            if (elem.className !== finalValue) {
              elem.className = finalValue;
            }
          }
        }
      }
      return this;
    },
    removeClass: function(value) {
      var classes,
          elem,
          cur,
          clazz,
          j,
          finalValue,
          proceed = arguments.length === 0 || typeof value === "string" && value,
          i = 0,
          len = this.length;
      if (jQuery.isFunction(value)) {
        return this.each(function(j) {
          jQuery(this).removeClass(value.call(this, j, this.className));
        });
      }
      if (proceed) {
        classes = (value || "").match(rnotwhite) || [];
        for (; i < len; i++) {
          elem = this[i];
          cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : "");
          if (cur) {
            j = 0;
            while ((clazz = classes[j++])) {
              while (cur.indexOf(" " + clazz + " ") >= 0) {
                cur = cur.replace(" " + clazz + " ", " ");
              }
            }
            finalValue = value ? jQuery.trim(cur) : "";
            if (elem.className !== finalValue) {
              elem.className = finalValue;
            }
          }
        }
      }
      return this;
    },
    toggleClass: function(value, stateVal) {
      var type = typeof value;
      if (typeof stateVal === "boolean" && type === "string") {
        return stateVal ? this.addClass(value) : this.removeClass(value);
      }
      if (jQuery.isFunction(value)) {
        return this.each(function(i) {
          jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
        });
      }
      return this.each(function() {
        if (type === "string") {
          var className,
              i = 0,
              self = jQuery(this),
              classNames = value.match(rnotwhite) || [];
          while ((className = classNames[i++])) {
            if (self.hasClass(className)) {
              self.removeClass(className);
            } else {
              self.addClass(className);
            }
          }
        } else if (type === strundefined || type === "boolean") {
          if (this.className) {
            data_priv.set(this, "__className__", this.className);
          }
          this.className = this.className || value === false ? "" : data_priv.get(this, "__className__") || "";
        }
      });
    },
    hasClass: function(selector) {
      var className = " " + selector + " ",
          i = 0,
          l = this.length;
      for (; i < l; i++) {
        if (this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) {
          return true;
        }
      }
      return false;
    }
  });
  var rreturn = /\r/g;
  jQuery.fn.extend({val: function(value) {
      var hooks,
          ret,
          isFunction,
          elem = this[0];
      if (!arguments.length) {
        if (elem) {
          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
          if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
            return ret;
          }
          ret = elem.value;
          return typeof ret === "string" ? ret.replace(rreturn, "") : ret == null ? "" : ret;
        }
        return ;
      }
      isFunction = jQuery.isFunction(value);
      return this.each(function(i) {
        var val;
        if (this.nodeType !== 1) {
          return ;
        }
        if (isFunction) {
          val = value.call(this, i, jQuery(this).val());
        } else {
          val = value;
        }
        if (val == null) {
          val = "";
        } else if (typeof val === "number") {
          val += "";
        } else if (jQuery.isArray(val)) {
          val = jQuery.map(val, function(value) {
            return value == null ? "" : value + "";
          });
        }
        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
        if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
          this.value = val;
        }
      });
    }});
  jQuery.extend({valHooks: {
      option: {get: function(elem) {
          var val = jQuery.find.attr(elem, "value");
          return val != null ? val : jQuery.trim(jQuery.text(elem));
        }},
      select: {
        get: function(elem) {
          var value,
              option,
              options = elem.options,
              index = elem.selectedIndex,
              one = elem.type === "select-one" || index < 0,
              values = one ? null : [],
              max = one ? index + 1 : options.length,
              i = index < 0 ? max : one ? index : 0;
          for (; i < max; i++) {
            option = options[i];
            if ((option.selected || i === index) && (support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
              value = jQuery(option).val();
              if (one) {
                return value;
              }
              values.push(value);
            }
          }
          return values;
        },
        set: function(elem, value) {
          var optionSet,
              option,
              options = elem.options,
              values = jQuery.makeArray(value),
              i = options.length;
          while (i--) {
            option = options[i];
            if ((option.selected = jQuery.inArray(option.value, values) >= 0)) {
              optionSet = true;
            }
          }
          if (!optionSet) {
            elem.selectedIndex = -1;
          }
          return values;
        }
      }
    }});
  jQuery.each(["radio", "checkbox"], function() {
    jQuery.valHooks[this] = {set: function(elem, value) {
        if (jQuery.isArray(value)) {
          return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0);
        }
      }};
    if (!support.checkOn) {
      jQuery.valHooks[this].get = function(elem) {
        return elem.getAttribute("value") === null ? "on" : elem.value;
      };
    }
  });
  jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu").split(" "), function(i, name) {
    jQuery.fn[name] = function(data, fn) {
      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
    };
  });
  jQuery.fn.extend({
    hover: function(fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    },
    bind: function(types, data, fn) {
      return this.on(types, null, data, fn);
    },
    unbind: function(types, fn) {
      return this.off(types, null, fn);
    },
    delegate: function(selector, types, data, fn) {
      return this.on(types, selector, data, fn);
    },
    undelegate: function(selector, types, fn) {
      return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
    }
  });
  var nonce = jQuery.now();
  var rquery = (/\?/);
  jQuery.parseJSON = function(data) {
    return JSON.parse(data + "");
  };
  jQuery.parseXML = function(data) {
    var xml,
        tmp;
    if (!data || typeof data !== "string") {
      return null;
    }
    try {
      tmp = new DOMParser();
      xml = tmp.parseFromString(data, "text/xml");
    } catch (e) {
      xml = undefined;
    }
    if (!xml || xml.getElementsByTagName("parsererror").length) {
      jQuery.error("Invalid XML: " + data);
    }
    return xml;
  };
  var rhash = /#.*$/,
      rts = /([?&])_=[^&]*/,
      rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
      rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
      rnoContent = /^(?:GET|HEAD)$/,
      rprotocol = /^\/\//,
      rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
      prefilters = {},
      transports = {},
      allTypes = "*/".concat("*"),
      ajaxLocation = window.location.href,
      ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];
  function addToPrefiltersOrTransports(structure) {
    return function(dataTypeExpression, func) {
      if (typeof dataTypeExpression !== "string") {
        func = dataTypeExpression;
        dataTypeExpression = "*";
      }
      var dataType,
          i = 0,
          dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
      if (jQuery.isFunction(func)) {
        while ((dataType = dataTypes[i++])) {
          if (dataType[0] === "+") {
            dataType = dataType.slice(1) || "*";
            (structure[dataType] = structure[dataType] || []).unshift(func);
          } else {
            (structure[dataType] = structure[dataType] || []).push(func);
          }
        }
      }
    };
  }
  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
    var inspected = {},
        seekingTransport = (structure === transports);
    function inspect(dataType) {
      var selected;
      inspected[dataType] = true;
      jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
        if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
          options.dataTypes.unshift(dataTypeOrTransport);
          inspect(dataTypeOrTransport);
          return false;
        } else if (seekingTransport) {
          return !(selected = dataTypeOrTransport);
        }
      });
      return selected;
    }
    return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
  }
  function ajaxExtend(target, src) {
    var key,
        deep,
        flatOptions = jQuery.ajaxSettings.flatOptions || {};
    for (key in src) {
      if (src[key] !== undefined) {
        (flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];
      }
    }
    if (deep) {
      jQuery.extend(true, target, deep);
    }
    return target;
  }
  function ajaxHandleResponses(s, jqXHR, responses) {
    var ct,
        type,
        finalDataType,
        firstDataType,
        contents = s.contents,
        dataTypes = s.dataTypes;
    while (dataTypes[0] === "*") {
      dataTypes.shift();
      if (ct === undefined) {
        ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
      }
    }
    if (ct) {
      for (type in contents) {
        if (contents[type] && contents[type].test(ct)) {
          dataTypes.unshift(type);
          break;
        }
      }
    }
    if (dataTypes[0] in responses) {
      finalDataType = dataTypes[0];
    } else {
      for (type in responses) {
        if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
          finalDataType = type;
          break;
        }
        if (!firstDataType) {
          firstDataType = type;
        }
      }
      finalDataType = finalDataType || firstDataType;
    }
    if (finalDataType) {
      if (finalDataType !== dataTypes[0]) {
        dataTypes.unshift(finalDataType);
      }
      return responses[finalDataType];
    }
  }
  function ajaxConvert(s, response, jqXHR, isSuccess) {
    var conv2,
        current,
        conv,
        tmp,
        prev,
        converters = {},
        dataTypes = s.dataTypes.slice();
    if (dataTypes[1]) {
      for (conv in s.converters) {
        converters[conv.toLowerCase()] = s.converters[conv];
      }
    }
    current = dataTypes.shift();
    while (current) {
      if (s.responseFields[current]) {
        jqXHR[s.responseFields[current]] = response;
      }
      if (!prev && isSuccess && s.dataFilter) {
        response = s.dataFilter(response, s.dataType);
      }
      prev = current;
      current = dataTypes.shift();
      if (current) {
        if (current === "*") {
          current = prev;
        } else if (prev !== "*" && prev !== current) {
          conv = converters[prev + " " + current] || converters["* " + current];
          if (!conv) {
            for (conv2 in converters) {
              tmp = conv2.split(" ");
              if (tmp[1] === current) {
                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                if (conv) {
                  if (conv === true) {
                    conv = converters[conv2];
                  } else if (converters[conv2] !== true) {
                    current = tmp[0];
                    dataTypes.unshift(tmp[1]);
                  }
                  break;
                }
              }
            }
          }
          if (conv !== true) {
            if (conv && s["throws"]) {
              response = conv(response);
            } else {
              try {
                response = conv(response);
              } catch (e) {
                return {
                  state: "parsererror",
                  error: conv ? e : "No conversion from " + prev + " to " + current
                };
              }
            }
          }
        }
      }
    }
    return {
      state: "success",
      data: response
    };
  }
  jQuery.extend({
    active: 0,
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: ajaxLocation,
      type: "GET",
      isLocal: rlocalProtocol.test(ajaxLocParts[1]),
      global: true,
      processData: true,
      async: true,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",
      accepts: {
        "*": allTypes,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },
      contents: {
        xml: /xml/,
        html: /html/,
        json: /json/
      },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },
      converters: {
        "* text": String,
        "text html": true,
        "text json": jQuery.parseJSON,
        "text xml": jQuery.parseXML
      },
      flatOptions: {
        url: true,
        context: true
      }
    },
    ajaxSetup: function(target, settings) {
      return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
    },
    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
    ajaxTransport: addToPrefiltersOrTransports(transports),
    ajax: function(url, options) {
      if (typeof url === "object") {
        options = url;
        url = undefined;
      }
      options = options || {};
      var transport,
          cacheURL,
          responseHeadersString,
          responseHeaders,
          timeoutTimer,
          parts,
          fireGlobals,
          i,
          s = jQuery.ajaxSetup({}, options),
          callbackContext = s.context || s,
          globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
          deferred = jQuery.Deferred(),
          completeDeferred = jQuery.Callbacks("once memory"),
          statusCode = s.statusCode || {},
          requestHeaders = {},
          requestHeadersNames = {},
          state = 0,
          strAbort = "canceled",
          jqXHR = {
            readyState: 0,
            getResponseHeader: function(key) {
              var match;
              if (state === 2) {
                if (!responseHeaders) {
                  responseHeaders = {};
                  while ((match = rheaders.exec(responseHeadersString))) {
                    responseHeaders[match[1].toLowerCase()] = match[2];
                  }
                }
                match = responseHeaders[key.toLowerCase()];
              }
              return match == null ? null : match;
            },
            getAllResponseHeaders: function() {
              return state === 2 ? responseHeadersString : null;
            },
            setRequestHeader: function(name, value) {
              var lname = name.toLowerCase();
              if (!state) {
                name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                requestHeaders[name] = value;
              }
              return this;
            },
            overrideMimeType: function(type) {
              if (!state) {
                s.mimeType = type;
              }
              return this;
            },
            statusCode: function(map) {
              var code;
              if (map) {
                if (state < 2) {
                  for (code in map) {
                    statusCode[code] = [statusCode[code], map[code]];
                  }
                } else {
                  jqXHR.always(map[jqXHR.status]);
                }
              }
              return this;
            },
            abort: function(statusText) {
              var finalText = statusText || strAbort;
              if (transport) {
                transport.abort(finalText);
              }
              done(0, finalText);
              return this;
            }
          };
      deferred.promise(jqXHR).complete = completeDeferred.add;
      jqXHR.success = jqXHR.done;
      jqXHR.error = jqXHR.fail;
      s.url = ((url || s.url || ajaxLocation) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//");
      s.type = options.method || options.type || s.method || s.type;
      s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""];
      if (s.crossDomain == null) {
        parts = rurl.exec(s.url.toLowerCase());
        s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === "http:" ? "80" : "443")) !== (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? "80" : "443"))));
      }
      if (s.data && s.processData && typeof s.data !== "string") {
        s.data = jQuery.param(s.data, s.traditional);
      }
      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
      if (state === 2) {
        return jqXHR;
      }
      fireGlobals = jQuery.event && s.global;
      if (fireGlobals && jQuery.active++ === 0) {
        jQuery.event.trigger("ajaxStart");
      }
      s.type = s.type.toUpperCase();
      s.hasContent = !rnoContent.test(s.type);
      cacheURL = s.url;
      if (!s.hasContent) {
        if (s.data) {
          cacheURL = (s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data);
          delete s.data;
        }
        if (s.cache === false) {
          s.url = rts.test(cacheURL) ? cacheURL.replace(rts, "$1_=" + nonce++) : cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
        }
      }
      if (s.ifModified) {
        if (jQuery.lastModified[cacheURL]) {
          jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
        }
        if (jQuery.etag[cacheURL]) {
          jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
        }
      }
      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
        jqXHR.setRequestHeader("Content-Type", s.contentType);
      }
      jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
      for (i in s.headers) {
        jqXHR.setRequestHeader(i, s.headers[i]);
      }
      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
        return jqXHR.abort();
      }
      strAbort = "abort";
      for (i in {
        success: 1,
        error: 1,
        complete: 1
      }) {
        jqXHR[i](s[i]);
      }
      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
      if (!transport) {
        done(-1, "No Transport");
      } else {
        jqXHR.readyState = 1;
        if (fireGlobals) {
          globalEventContext.trigger("ajaxSend", [jqXHR, s]);
        }
        if (s.async && s.timeout > 0) {
          timeoutTimer = setTimeout(function() {
            jqXHR.abort("timeout");
          }, s.timeout);
        }
        try {
          state = 1;
          transport.send(requestHeaders, done);
        } catch (e) {
          if (state < 2) {
            done(-1, e);
          } else {
            throw e;
          }
        }
      }
      function done(status, nativeStatusText, responses, headers) {
        var isSuccess,
            success,
            error,
            response,
            modified,
            statusText = nativeStatusText;
        if (state === 2) {
          return ;
        }
        state = 2;
        if (timeoutTimer) {
          clearTimeout(timeoutTimer);
        }
        transport = undefined;
        responseHeadersString = headers || "";
        jqXHR.readyState = status > 0 ? 4 : 0;
        isSuccess = status >= 200 && status < 300 || status === 304;
        if (responses) {
          response = ajaxHandleResponses(s, jqXHR, responses);
        }
        response = ajaxConvert(s, response, jqXHR, isSuccess);
        if (isSuccess) {
          if (s.ifModified) {
            modified = jqXHR.getResponseHeader("Last-Modified");
            if (modified) {
              jQuery.lastModified[cacheURL] = modified;
            }
            modified = jqXHR.getResponseHeader("etag");
            if (modified) {
              jQuery.etag[cacheURL] = modified;
            }
          }
          if (status === 204 || s.type === "HEAD") {
            statusText = "nocontent";
          } else if (status === 304) {
            statusText = "notmodified";
          } else {
            statusText = response.state;
            success = response.data;
            error = response.error;
            isSuccess = !error;
          }
        } else {
          error = statusText;
          if (status || !statusText) {
            statusText = "error";
            if (status < 0) {
              status = 0;
            }
          }
        }
        jqXHR.status = status;
        jqXHR.statusText = (nativeStatusText || statusText) + "";
        if (isSuccess) {
          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
        } else {
          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
        }
        jqXHR.statusCode(statusCode);
        statusCode = undefined;
        if (fireGlobals) {
          globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
        }
        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
        if (fireGlobals) {
          globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
          if (!(--jQuery.active)) {
            jQuery.event.trigger("ajaxStop");
          }
        }
      }
      return jqXHR;
    },
    getJSON: function(url, data, callback) {
      return jQuery.get(url, data, callback, "json");
    },
    getScript: function(url, callback) {
      return jQuery.get(url, undefined, callback, "script");
    }
  });
  jQuery.each(["get", "post"], function(i, method) {
    jQuery[method] = function(url, data, callback, type) {
      if (jQuery.isFunction(data)) {
        type = type || callback;
        callback = data;
        data = undefined;
      }
      return jQuery.ajax({
        url: url,
        type: method,
        dataType: type,
        data: data,
        success: callback
      });
    };
  });
  jQuery._evalUrl = function(url) {
    return jQuery.ajax({
      url: url,
      type: "GET",
      dataType: "script",
      async: false,
      global: false,
      "throws": true
    });
  };
  jQuery.fn.extend({
    wrapAll: function(html) {
      var wrap;
      if (jQuery.isFunction(html)) {
        return this.each(function(i) {
          jQuery(this).wrapAll(html.call(this, i));
        });
      }
      if (this[0]) {
        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
        if (this[0].parentNode) {
          wrap.insertBefore(this[0]);
        }
        wrap.map(function() {
          var elem = this;
          while (elem.firstElementChild) {
            elem = elem.firstElementChild;
          }
          return elem;
        }).append(this);
      }
      return this;
    },
    wrapInner: function(html) {
      if (jQuery.isFunction(html)) {
        return this.each(function(i) {
          jQuery(this).wrapInner(html.call(this, i));
        });
      }
      return this.each(function() {
        var self = jQuery(this),
            contents = self.contents();
        if (contents.length) {
          contents.wrapAll(html);
        } else {
          self.append(html);
        }
      });
    },
    wrap: function(html) {
      var isFunction = jQuery.isFunction(html);
      return this.each(function(i) {
        jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
      });
    },
    unwrap: function() {
      return this.parent().each(function() {
        if (!jQuery.nodeName(this, "body")) {
          jQuery(this).replaceWith(this.childNodes);
        }
      }).end();
    }
  });
  jQuery.expr.filters.hidden = function(elem) {
    return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
  };
  jQuery.expr.filters.visible = function(elem) {
    return !jQuery.expr.filters.hidden(elem);
  };
  var r20 = /%20/g,
      rbracket = /\[\]$/,
      rCRLF = /\r?\n/g,
      rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
      rsubmittable = /^(?:input|select|textarea|keygen)/i;
  function buildParams(prefix, obj, traditional, add) {
    var name;
    if (jQuery.isArray(obj)) {
      jQuery.each(obj, function(i, v) {
        if (traditional || rbracket.test(prefix)) {
          add(prefix, v);
        } else {
          buildParams(prefix + "[" + (typeof v === "object" ? i : "") + "]", v, traditional, add);
        }
      });
    } else if (!traditional && jQuery.type(obj) === "object") {
      for (name in obj) {
        buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
      }
    } else {
      add(prefix, obj);
    }
  }
  jQuery.param = function(a, traditional) {
    var prefix,
        s = [],
        add = function(key, value) {
          value = jQuery.isFunction(value) ? value() : (value == null ? "" : value);
          s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
        };
    if (traditional === undefined) {
      traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
    }
    if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
      jQuery.each(a, function() {
        add(this.name, this.value);
      });
    } else {
      for (prefix in a) {
        buildParams(prefix, a[prefix], traditional, add);
      }
    }
    return s.join("&").replace(r20, "+");
  };
  jQuery.fn.extend({
    serialize: function() {
      return jQuery.param(this.serializeArray());
    },
    serializeArray: function() {
      return this.map(function() {
        var elements = jQuery.prop(this, "elements");
        return elements ? jQuery.makeArray(elements) : this;
      }).filter(function() {
        var type = this.type;
        return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
      }).map(function(i, elem) {
        var val = jQuery(this).val();
        return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function(val) {
          return {
            name: elem.name,
            value: val.replace(rCRLF, "\r\n")
          };
        }) : {
          name: elem.name,
          value: val.replace(rCRLF, "\r\n")
        };
      }).get();
    }
  });
  jQuery.ajaxSettings.xhr = function() {
    try {
      return new XMLHttpRequest();
    } catch (e) {}
  };
  var xhrId = 0,
      xhrCallbacks = {},
      xhrSuccessStatus = {
        0: 200,
        1223: 204
      },
      xhrSupported = jQuery.ajaxSettings.xhr();
  if (window.attachEvent) {
    window.attachEvent("onunload", function() {
      for (var key in xhrCallbacks) {
        xhrCallbacks[key]();
      }
    });
  }
  support.cors = !!xhrSupported && ("withCredentials" in xhrSupported);
  support.ajax = xhrSupported = !!xhrSupported;
  jQuery.ajaxTransport(function(options) {
    var callback;
    if (support.cors || xhrSupported && !options.crossDomain) {
      return {
        send: function(headers, complete) {
          var i,
              xhr = options.xhr(),
              id = ++xhrId;
          xhr.open(options.type, options.url, options.async, options.username, options.password);
          if (options.xhrFields) {
            for (i in options.xhrFields) {
              xhr[i] = options.xhrFields[i];
            }
          }
          if (options.mimeType && xhr.overrideMimeType) {
            xhr.overrideMimeType(options.mimeType);
          }
          if (!options.crossDomain && !headers["X-Requested-With"]) {
            headers["X-Requested-With"] = "XMLHttpRequest";
          }
          for (i in headers) {
            xhr.setRequestHeader(i, headers[i]);
          }
          callback = function(type) {
            return function() {
              if (callback) {
                delete xhrCallbacks[id];
                callback = xhr.onload = xhr.onerror = null;
                if (type === "abort") {
                  xhr.abort();
                } else if (type === "error") {
                  complete(xhr.status, xhr.statusText);
                } else {
                  complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, typeof xhr.responseText === "string" ? {text: xhr.responseText} : undefined, xhr.getAllResponseHeaders());
                }
              }
            };
          };
          xhr.onload = callback();
          xhr.onerror = callback("error");
          callback = xhrCallbacks[id] = callback("abort");
          try {
            xhr.send(options.hasContent && options.data || null);
          } catch (e) {
            if (callback) {
              throw e;
            }
          }
        },
        abort: function() {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  jQuery.ajaxSetup({
    accepts: {script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},
    contents: {script: /(?:java|ecma)script/},
    converters: {"text script": function(text) {
        jQuery.globalEval(text);
        return text;
      }}
  });
  jQuery.ajaxPrefilter("script", function(s) {
    if (s.cache === undefined) {
      s.cache = false;
    }
    if (s.crossDomain) {
      s.type = "GET";
    }
  });
  jQuery.ajaxTransport("script", function(s) {
    if (s.crossDomain) {
      var script,
          callback;
      return {
        send: function(_, complete) {
          script = jQuery("<script>").prop({
            async: true,
            charset: s.scriptCharset,
            src: s.url
          }).on("load error", callback = function(evt) {
            script.remove();
            callback = null;
            if (evt) {
              complete(evt.type === "error" ? 404 : 200, evt.type);
            }
          });
          document.head.appendChild(script[0]);
        },
        abort: function() {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  var oldCallbacks = [],
      rjsonp = /(=)\?(?=&|$)|\?\?/;
  jQuery.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function() {
      var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (nonce++));
      this[callback] = true;
      return callback;
    }
  });
  jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
    var callbackName,
        overwritten,
        responseContainer,
        jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && !(s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data");
    if (jsonProp || s.dataTypes[0] === "jsonp") {
      callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
      if (jsonProp) {
        s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
      } else if (s.jsonp !== false) {
        s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
      }
      s.converters["script json"] = function() {
        if (!responseContainer) {
          jQuery.error(callbackName + " was not called");
        }
        return responseContainer[0];
      };
      s.dataTypes[0] = "json";
      overwritten = window[callbackName];
      window[callbackName] = function() {
        responseContainer = arguments;
      };
      jqXHR.always(function() {
        window[callbackName] = overwritten;
        if (s[callbackName]) {
          s.jsonpCallback = originalSettings.jsonpCallback;
          oldCallbacks.push(callbackName);
        }
        if (responseContainer && jQuery.isFunction(overwritten)) {
          overwritten(responseContainer[0]);
        }
        responseContainer = overwritten = undefined;
      });
      return "script";
    }
  });
  jQuery.parseHTML = function(data, context, keepScripts) {
    if (!data || typeof data !== "string") {
      return null;
    }
    if (typeof context === "boolean") {
      keepScripts = context;
      context = false;
    }
    context = context || document;
    var parsed = rsingleTag.exec(data),
        scripts = !keepScripts && [];
    if (parsed) {
      return [context.createElement(parsed[1])];
    }
    parsed = jQuery.buildFragment([data], context, scripts);
    if (scripts && scripts.length) {
      jQuery(scripts).remove();
    }
    return jQuery.merge([], parsed.childNodes);
  };
  var _load = jQuery.fn.load;
  jQuery.fn.load = function(url, params, callback) {
    if (typeof url !== "string" && _load) {
      return _load.apply(this, arguments);
    }
    var selector,
        type,
        response,
        self = this,
        off = url.indexOf(" ");
    if (off >= 0) {
      selector = jQuery.trim(url.slice(off));
      url = url.slice(0, off);
    }
    if (jQuery.isFunction(params)) {
      callback = params;
      params = undefined;
    } else if (params && typeof params === "object") {
      type = "POST";
    }
    if (self.length > 0) {
      jQuery.ajax({
        url: url,
        type: type,
        dataType: "html",
        data: params
      }).done(function(responseText) {
        response = arguments;
        self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText);
      }).complete(callback && function(jqXHR, status) {
        self.each(callback, response || [jqXHR.responseText, status, jqXHR]);
      });
    }
    return this;
  };
  jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(i, type) {
    jQuery.fn[type] = function(fn) {
      return this.on(type, fn);
    };
  });
  jQuery.expr.filters.animated = function(elem) {
    return jQuery.grep(jQuery.timers, function(fn) {
      return elem === fn.elem;
    }).length;
  };
  var docElem = window.document.documentElement;
  function getWindow(elem) {
    return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
  }
  jQuery.offset = {setOffset: function(elem, options, i) {
      var curPosition,
          curLeft,
          curCSSTop,
          curTop,
          curOffset,
          curCSSLeft,
          calculatePosition,
          position = jQuery.css(elem, "position"),
          curElem = jQuery(elem),
          props = {};
      if (position === "static") {
        elem.style.position = "relative";
      }
      curOffset = curElem.offset();
      curCSSTop = jQuery.css(elem, "top");
      curCSSLeft = jQuery.css(elem, "left");
      calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
      if (calculatePosition) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;
      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }
      if (jQuery.isFunction(options)) {
        options = options.call(elem, i, curOffset);
      }
      if (options.top != null) {
        props.top = (options.top - curOffset.top) + curTop;
      }
      if (options.left != null) {
        props.left = (options.left - curOffset.left) + curLeft;
      }
      if ("using" in options) {
        options.using.call(elem, props);
      } else {
        curElem.css(props);
      }
    }};
  jQuery.fn.extend({
    offset: function(options) {
      if (arguments.length) {
        return options === undefined ? this : this.each(function(i) {
          jQuery.offset.setOffset(this, options, i);
        });
      }
      var docElem,
          win,
          elem = this[0],
          box = {
            top: 0,
            left: 0
          },
          doc = elem && elem.ownerDocument;
      if (!doc) {
        return ;
      }
      docElem = doc.documentElement;
      if (!jQuery.contains(docElem, elem)) {
        return box;
      }
      if (typeof elem.getBoundingClientRect !== strundefined) {
        box = elem.getBoundingClientRect();
      }
      win = getWindow(doc);
      return {
        top: box.top + win.pageYOffset - docElem.clientTop,
        left: box.left + win.pageXOffset - docElem.clientLeft
      };
    },
    position: function() {
      if (!this[0]) {
        return ;
      }
      var offsetParent,
          offset,
          elem = this[0],
          parentOffset = {
            top: 0,
            left: 0
          };
      if (jQuery.css(elem, "position") === "fixed") {
        offset = elem.getBoundingClientRect();
      } else {
        offsetParent = this.offsetParent();
        offset = this.offset();
        if (!jQuery.nodeName(offsetParent[0], "html")) {
          parentOffset = offsetParent.offset();
        }
        parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
        parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
      }
      return {
        top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
        left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
      };
    },
    offsetParent: function() {
      return this.map(function() {
        var offsetParent = this.offsetParent || docElem;
        while (offsetParent && (!jQuery.nodeName(offsetParent, "html") && jQuery.css(offsetParent, "position") === "static")) {
          offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || docElem;
      });
    }
  });
  jQuery.each({
    scrollLeft: "pageXOffset",
    scrollTop: "pageYOffset"
  }, function(method, prop) {
    var top = "pageYOffset" === prop;
    jQuery.fn[method] = function(val) {
      return access(this, function(elem, method, val) {
        var win = getWindow(elem);
        if (val === undefined) {
          return win ? win[prop] : elem[method];
        }
        if (win) {
          win.scrollTo(!top ? val : window.pageXOffset, top ? val : window.pageYOffset);
        } else {
          elem[method] = val;
        }
      }, method, val, arguments.length, null);
    };
  });
  jQuery.each(["top", "left"], function(i, prop) {
    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
      if (computed) {
        computed = curCSS(elem, prop);
        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
      }
    });
  });
  jQuery.each({
    Height: "height",
    Width: "width"
  }, function(name, type) {
    jQuery.each({
      padding: "inner" + name,
      content: type,
      "": "outer" + name
    }, function(defaultExtra, funcName) {
      jQuery.fn[funcName] = function(margin, value) {
        var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
            extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
        return access(this, function(elem, type, value) {
          var doc;
          if (jQuery.isWindow(elem)) {
            return elem.document.documentElement["client" + name];
          }
          if (elem.nodeType === 9) {
            doc = elem.documentElement;
            return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
          }
          return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
        }, type, chainable ? margin : undefined, chainable, null);
      };
    });
  });
  jQuery.fn.size = function() {
    return this.length;
  };
  jQuery.fn.andSelf = jQuery.fn.addBack;
  if (typeof define === "function" && define.amd) {
    System.register("github:components/jquery@2.1.3/jquery", [], false, function(__require, __exports, __module) {
      return (function() {
        return jQuery;
      }).call(this);
    });
  }
  var _jQuery = window.jQuery,
      _$ = window.$;
  jQuery.noConflict = function(deep) {
    if (window.$ === jQuery) {
      window.$ = _$;
    }
    if (deep && window.jQuery === jQuery) {
      window.jQuery = _jQuery;
    }
    return jQuery;
  };
  if (typeof noGlobal === strundefined) {
    window.jQuery = window.$ = jQuery;
  }
  return jQuery;
}));


})();
System.register("github:components/jqueryui@1.11.3/jquery-ui", ["github:components/jquery@2.1.3"], false, function(__require, __exports, __module) {
  System.get("@@global-helpers").prepareGlobal(__module.id, ["github:components/jquery@2.1.3"]);
  (function() {
    "format global";
    "deps jquery";
    (function(factory) {
      if (typeof define === "function" && define.amd) {
        define(["jquery"], factory);
      } else {
        factory(jQuery);
      }
    }(function($) {
      $.ui = $.ui || {};
      $.extend($.ui, {
        version: "1.11.3",
        keyCode: {
          BACKSPACE: 8,
          COMMA: 188,
          DELETE: 46,
          DOWN: 40,
          END: 35,
          ENTER: 13,
          ESCAPE: 27,
          HOME: 36,
          LEFT: 37,
          PAGE_DOWN: 34,
          PAGE_UP: 33,
          PERIOD: 190,
          RIGHT: 39,
          SPACE: 32,
          TAB: 9,
          UP: 38
        }
      });
      $.fn.extend({
        scrollParent: function(includeHidden) {
          var position = this.css("position"),
              excludeStaticParent = position === "absolute",
              overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
              scrollParent = this.parents().filter(function() {
                var parent = $(this);
                if (excludeStaticParent && parent.css("position") === "static") {
                  return false;
                }
                return overflowRegex.test(parent.css("overflow") + parent.css("overflow-y") + parent.css("overflow-x"));
              }).eq(0);
          return position === "fixed" || !scrollParent.length ? $(this[0].ownerDocument || document) : scrollParent;
        },
        uniqueId: (function() {
          var uuid = 0;
          return function() {
            return this.each(function() {
              if (!this.id) {
                this.id = "ui-id-" + (++uuid);
              }
            });
          };
        })(),
        removeUniqueId: function() {
          return this.each(function() {
            if (/^ui-id-\d+$/.test(this.id)) {
              $(this).removeAttr("id");
            }
          });
        }
      });
      function focusable(element, isTabIndexNotNaN) {
        var map,
            mapName,
            img,
            nodeName = element.nodeName.toLowerCase();
        if ("area" === nodeName) {
          map = element.parentNode;
          mapName = map.name;
          if (!element.href || !mapName || map.nodeName.toLowerCase() !== "map") {
            return false;
          }
          img = $("img[usemap='#" + mapName + "']")[0];
          return !!img && visible(img);
        }
        return (/^(input|select|textarea|button|object)$/.test(nodeName) ? !element.disabled : "a" === nodeName ? element.href || isTabIndexNotNaN : isTabIndexNotNaN) && visible(element);
      }
      function visible(element) {
        return $.expr.filters.visible(element) && !$(element).parents().addBack().filter(function() {
          return $.css(this, "visibility") === "hidden";
        }).length;
      }
      $.extend($.expr[":"], {
        data: $.expr.createPseudo ? $.expr.createPseudo(function(dataName) {
          return function(elem) {
            return !!$.data(elem, dataName);
          };
        }) : function(elem, i, match) {
          return !!$.data(elem, match[3]);
        },
        focusable: function(element) {
          return focusable(element, !isNaN($.attr(element, "tabindex")));
        },
        tabbable: function(element) {
          var tabIndex = $.attr(element, "tabindex"),
              isTabIndexNaN = isNaN(tabIndex);
          return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN);
        }
      });
      if (!$("<a>").outerWidth(1).jquery) {
        $.each(["Width", "Height"], function(i, name) {
          var side = name === "Width" ? ["Left", "Right"] : ["Top", "Bottom"],
              type = name.toLowerCase(),
              orig = {
                innerWidth: $.fn.innerWidth,
                innerHeight: $.fn.innerHeight,
                outerWidth: $.fn.outerWidth,
                outerHeight: $.fn.outerHeight
              };
          function reduce(elem, size, border, margin) {
            $.each(side, function() {
              size -= parseFloat($.css(elem, "padding" + this)) || 0;
              if (border) {
                size -= parseFloat($.css(elem, "border" + this + "Width")) || 0;
              }
              if (margin) {
                size -= parseFloat($.css(elem, "margin" + this)) || 0;
              }
            });
            return size;
          }
          $.fn["inner" + name] = function(size) {
            if (size === undefined) {
              return orig["inner" + name].call(this);
            }
            return this.each(function() {
              $(this).css(type, reduce(this, size) + "px");
            });
          };
          $.fn["outer" + name] = function(size, margin) {
            if (typeof size !== "number") {
              return orig["outer" + name].call(this, size);
            }
            return this.each(function() {
              $(this).css(type, reduce(this, size, true, margin) + "px");
            });
          };
        });
      }
      if (!$.fn.addBack) {
        $.fn.addBack = function(selector) {
          return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        };
      }
      if ($("<a>").data("a-b", "a").removeData("a-b").data("a-b")) {
        $.fn.removeData = (function(removeData) {
          return function(key) {
            if (arguments.length) {
              return removeData.call(this, $.camelCase(key));
            } else {
              return removeData.call(this);
            }
          };
        })($.fn.removeData);
      }
      $.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());
      $.fn.extend({
        focus: (function(orig) {
          return function(delay, fn) {
            return typeof delay === "number" ? this.each(function() {
              var elem = this;
              setTimeout(function() {
                $(elem).focus();
                if (fn) {
                  fn.call(elem);
                }
              }, delay);
            }) : orig.apply(this, arguments);
          };
        })($.fn.focus),
        disableSelection: (function() {
          var eventType = "onselectstart" in document.createElement("div") ? "selectstart" : "mousedown";
          return function() {
            return this.bind(eventType + ".ui-disableSelection", function(event) {
              event.preventDefault();
            });
          };
        })(),
        enableSelection: function() {
          return this.unbind(".ui-disableSelection");
        },
        zIndex: function(zIndex) {
          if (zIndex !== undefined) {
            return this.css("zIndex", zIndex);
          }
          if (this.length) {
            var elem = $(this[0]),
                position,
                value;
            while (elem.length && elem[0] !== document) {
              position = elem.css("position");
              if (position === "absolute" || position === "relative" || position === "fixed") {
                value = parseInt(elem.css("zIndex"), 10);
                if (!isNaN(value) && value !== 0) {
                  return value;
                }
              }
              elem = elem.parent();
            }
          }
          return 0;
        }
      });
      $.ui.plugin = {
        add: function(module, option, set) {
          var i,
              proto = $.ui[module].prototype;
          for (i in set) {
            proto.plugins[i] = proto.plugins[i] || [];
            proto.plugins[i].push([option, set[i]]);
          }
        },
        call: function(instance, name, args, allowDisconnected) {
          var i,
              set = instance.plugins[name];
          if (!set) {
            return ;
          }
          if (!allowDisconnected && (!instance.element[0].parentNode || instance.element[0].parentNode.nodeType === 11)) {
            return ;
          }
          for (i = 0; i < set.length; i++) {
            if (instance.options[set[i][0]]) {
              set[i][1].apply(instance.element, args);
            }
          }
        }
      };
      var widget_uuid = 0,
          widget_slice = Array.prototype.slice;
      $.cleanData = (function(orig) {
        return function(elems) {
          var events,
              elem,
              i;
          for (i = 0; (elem = elems[i]) != null; i++) {
            try {
              events = $._data(elem, "events");
              if (events && events.remove) {
                $(elem).triggerHandler("remove");
              }
            } catch (e) {}
          }
          orig(elems);
        };
      })($.cleanData);
      $.widget = function(name, base, prototype) {
        var fullName,
            existingConstructor,
            constructor,
            basePrototype,
            proxiedPrototype = {},
            namespace = name.split(".")[0];
        name = name.split(".")[1];
        fullName = namespace + "-" + name;
        if (!prototype) {
          prototype = base;
          base = $.Widget;
        }
        $.expr[":"][fullName.toLowerCase()] = function(elem) {
          return !!$.data(elem, fullName);
        };
        $[namespace] = $[namespace] || {};
        existingConstructor = $[namespace][name];
        constructor = $[namespace][name] = function(options, element) {
          if (!this._createWidget) {
            return new constructor(options, element);
          }
          if (arguments.length) {
            this._createWidget(options, element);
          }
        };
        $.extend(constructor, existingConstructor, {
          version: prototype.version,
          _proto: $.extend({}, prototype),
          _childConstructors: []
        });
        basePrototype = new base();
        basePrototype.options = $.widget.extend({}, basePrototype.options);
        $.each(prototype, function(prop, value) {
          if (!$.isFunction(value)) {
            proxiedPrototype[prop] = value;
            return ;
          }
          proxiedPrototype[prop] = (function() {
            var _super = function() {
              return base.prototype[prop].apply(this, arguments);
            },
                _superApply = function(args) {
                  return base.prototype[prop].apply(this, args);
                };
            return function() {
              var __super = this._super,
                  __superApply = this._superApply,
                  returnValue;
              this._super = _super;
              this._superApply = _superApply;
              returnValue = value.apply(this, arguments);
              this._super = __super;
              this._superApply = __superApply;
              return returnValue;
            };
          })();
        });
        constructor.prototype = $.widget.extend(basePrototype, {widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name}, proxiedPrototype, {
          constructor: constructor,
          namespace: namespace,
          widgetName: name,
          widgetFullName: fullName
        });
        if (existingConstructor) {
          $.each(existingConstructor._childConstructors, function(i, child) {
            var childPrototype = child.prototype;
            $.widget(childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto);
          });
          delete existingConstructor._childConstructors;
        } else {
          base._childConstructors.push(constructor);
        }
        $.widget.bridge(name, constructor);
        return constructor;
      };
      $.widget.extend = function(target) {
        var input = widget_slice.call(arguments, 1),
            inputIndex = 0,
            inputLength = input.length,
            key,
            value;
        for (; inputIndex < inputLength; inputIndex++) {
          for (key in input[inputIndex]) {
            value = input[inputIndex][key];
            if (input[inputIndex].hasOwnProperty(key) && value !== undefined) {
              if ($.isPlainObject(value)) {
                target[key] = $.isPlainObject(target[key]) ? $.widget.extend({}, target[key], value) : $.widget.extend({}, value);
              } else {
                target[key] = value;
              }
            }
          }
        }
        return target;
      };
      $.widget.bridge = function(name, object) {
        var fullName = object.prototype.widgetFullName || name;
        $.fn[name] = function(options) {
          var isMethodCall = typeof options === "string",
              args = widget_slice.call(arguments, 1),
              returnValue = this;
          if (isMethodCall) {
            this.each(function() {
              var methodValue,
                  instance = $.data(this, fullName);
              if (options === "instance") {
                returnValue = instance;
                return false;
              }
              if (!instance) {
                return $.error("cannot call methods on " + name + " prior to initialization; " + "attempted to call method '" + options + "'");
              }
              if (!$.isFunction(instance[options]) || options.charAt(0) === "_") {
                return $.error("no such method '" + options + "' for " + name + " widget instance");
              }
              methodValue = instance[options].apply(instance, args);
              if (methodValue !== instance && methodValue !== undefined) {
                returnValue = methodValue && methodValue.jquery ? returnValue.pushStack(methodValue.get()) : methodValue;
                return false;
              }
            });
          } else {
            if (args.length) {
              options = $.widget.extend.apply(null, [options].concat(args));
            }
            this.each(function() {
              var instance = $.data(this, fullName);
              if (instance) {
                instance.option(options || {});
                if (instance._init) {
                  instance._init();
                }
              } else {
                $.data(this, fullName, new object(options, this));
              }
            });
          }
          return returnValue;
        };
      };
      $.Widget = function() {};
      $.Widget._childConstructors = [];
      $.Widget.prototype = {
        widgetName: "widget",
        widgetEventPrefix: "",
        defaultElement: "<div>",
        options: {
          disabled: false,
          create: null
        },
        _createWidget: function(options, element) {
          element = $(element || this.defaultElement || this)[0];
          this.element = $(element);
          this.uuid = widget_uuid++;
          this.eventNamespace = "." + this.widgetName + this.uuid;
          this.bindings = $();
          this.hoverable = $();
          this.focusable = $();
          if (element !== this) {
            $.data(element, this.widgetFullName, this);
            this._on(true, this.element, {remove: function(event) {
                if (event.target === element) {
                  this.destroy();
                }
              }});
            this.document = $(element.style ? element.ownerDocument : element.document || element);
            this.window = $(this.document[0].defaultView || this.document[0].parentWindow);
          }
          this.options = $.widget.extend({}, this.options, this._getCreateOptions(), options);
          this._create();
          this._trigger("create", null, this._getCreateEventData());
          this._init();
        },
        _getCreateOptions: $.noop,
        _getCreateEventData: $.noop,
        _create: $.noop,
        _init: $.noop,
        destroy: function() {
          this._destroy();
          this.element.unbind(this.eventNamespace).removeData(this.widgetFullName).removeData($.camelCase(this.widgetFullName));
          this.widget().unbind(this.eventNamespace).removeAttr("aria-disabled").removeClass(this.widgetFullName + "-disabled " + "ui-state-disabled");
          this.bindings.unbind(this.eventNamespace);
          this.hoverable.removeClass("ui-state-hover");
          this.focusable.removeClass("ui-state-focus");
        },
        _destroy: $.noop,
        widget: function() {
          return this.element;
        },
        option: function(key, value) {
          var options = key,
              parts,
              curOption,
              i;
          if (arguments.length === 0) {
            return $.widget.extend({}, this.options);
          }
          if (typeof key === "string") {
            options = {};
            parts = key.split(".");
            key = parts.shift();
            if (parts.length) {
              curOption = options[key] = $.widget.extend({}, this.options[key]);
              for (i = 0; i < parts.length - 1; i++) {
                curOption[parts[i]] = curOption[parts[i]] || {};
                curOption = curOption[parts[i]];
              }
              key = parts.pop();
              if (arguments.length === 1) {
                return curOption[key] === undefined ? null : curOption[key];
              }
              curOption[key] = value;
            } else {
              if (arguments.length === 1) {
                return this.options[key] === undefined ? null : this.options[key];
              }
              options[key] = value;
            }
          }
          this._setOptions(options);
          return this;
        },
        _setOptions: function(options) {
          var key;
          for (key in options) {
            this._setOption(key, options[key]);
          }
          return this;
        },
        _setOption: function(key, value) {
          this.options[key] = value;
          if (key === "disabled") {
            this.widget().toggleClass(this.widgetFullName + "-disabled", !!value);
            if (value) {
              this.hoverable.removeClass("ui-state-hover");
              this.focusable.removeClass("ui-state-focus");
            }
          }
          return this;
        },
        enable: function() {
          return this._setOptions({disabled: false});
        },
        disable: function() {
          return this._setOptions({disabled: true});
        },
        _on: function(suppressDisabledCheck, element, handlers) {
          var delegateElement,
              instance = this;
          if (typeof suppressDisabledCheck !== "boolean") {
            handlers = element;
            element = suppressDisabledCheck;
            suppressDisabledCheck = false;
          }
          if (!handlers) {
            handlers = element;
            element = this.element;
            delegateElement = this.widget();
          } else {
            element = delegateElement = $(element);
            this.bindings = this.bindings.add(element);
          }
          $.each(handlers, function(event, handler) {
            function handlerProxy() {
              if (!suppressDisabledCheck && (instance.options.disabled === true || $(this).hasClass("ui-state-disabled"))) {
                return ;
              }
              return (typeof handler === "string" ? instance[handler] : handler).apply(instance, arguments);
            }
            if (typeof handler !== "string") {
              handlerProxy.guid = handler.guid = handler.guid || handlerProxy.guid || $.guid++;
            }
            var match = event.match(/^([\w:-]*)\s*(.*)$/),
                eventName = match[1] + instance.eventNamespace,
                selector = match[2];
            if (selector) {
              delegateElement.delegate(selector, eventName, handlerProxy);
            } else {
              element.bind(eventName, handlerProxy);
            }
          });
        },
        _off: function(element, eventName) {
          eventName = (eventName || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace;
          element.unbind(eventName).undelegate(eventName);
          this.bindings = $(this.bindings.not(element).get());
          this.focusable = $(this.focusable.not(element).get());
          this.hoverable = $(this.hoverable.not(element).get());
        },
        _delay: function(handler, delay) {
          function handlerProxy() {
            return (typeof handler === "string" ? instance[handler] : handler).apply(instance, arguments);
          }
          var instance = this;
          return setTimeout(handlerProxy, delay || 0);
        },
        _hoverable: function(element) {
          this.hoverable = this.hoverable.add(element);
          this._on(element, {
            mouseenter: function(event) {
              $(event.currentTarget).addClass("ui-state-hover");
            },
            mouseleave: function(event) {
              $(event.currentTarget).removeClass("ui-state-hover");
            }
          });
        },
        _focusable: function(element) {
          this.focusable = this.focusable.add(element);
          this._on(element, {
            focusin: function(event) {
              $(event.currentTarget).addClass("ui-state-focus");
            },
            focusout: function(event) {
              $(event.currentTarget).removeClass("ui-state-focus");
            }
          });
        },
        _trigger: function(type, event, data) {
          var prop,
              orig,
              callback = this.options[type];
          data = data || {};
          event = $.Event(event);
          event.type = (type === this.widgetEventPrefix ? type : this.widgetEventPrefix + type).toLowerCase();
          event.target = this.element[0];
          orig = event.originalEvent;
          if (orig) {
            for (prop in orig) {
              if (!(prop in event)) {
                event[prop] = orig[prop];
              }
            }
          }
          this.element.trigger(event, data);
          return !($.isFunction(callback) && callback.apply(this.element[0], [event].concat(data)) === false || event.isDefaultPrevented());
        }
      };
      $.each({
        show: "fadeIn",
        hide: "fadeOut"
      }, function(method, defaultEffect) {
        $.Widget.prototype["_" + method] = function(element, options, callback) {
          if (typeof options === "string") {
            options = {effect: options};
          }
          var hasOptions,
              effectName = !options ? method : options === true || typeof options === "number" ? defaultEffect : options.effect || defaultEffect;
          options = options || {};
          if (typeof options === "number") {
            options = {duration: options};
          }
          hasOptions = !$.isEmptyObject(options);
          options.complete = callback;
          if (options.delay) {
            element.delay(options.delay);
          }
          if (hasOptions && $.effects && $.effects.effect[effectName]) {
            element[method](options);
          } else if (effectName !== method && element[effectName]) {
            element[effectName](options.duration, options.easing, callback);
          } else {
            element.queue(function(next) {
              $(this)[method]();
              if (callback) {
                callback.call(element[0]);
              }
              next();
            });
          }
        };
      });
      var widget = $.widget;
      var mouseHandled = false;
      $(document).mouseup(function() {
        mouseHandled = false;
      });
      var mouse = $.widget("ui.mouse", {
        version: "1.11.3",
        options: {
          cancel: "input,textarea,button,select,option",
          distance: 1,
          delay: 0
        },
        _mouseInit: function() {
          var that = this;
          this.element.bind("mousedown." + this.widgetName, function(event) {
            return that._mouseDown(event);
          }).bind("click." + this.widgetName, function(event) {
            if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
              $.removeData(event.target, that.widgetName + ".preventClickEvent");
              event.stopImmediatePropagation();
              return false;
            }
          });
          this.started = false;
        },
        _mouseDestroy: function() {
          this.element.unbind("." + this.widgetName);
          if (this._mouseMoveDelegate) {
            this.document.unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
          }
        },
        _mouseDown: function(event) {
          if (mouseHandled) {
            return ;
          }
          this._mouseMoved = false;
          (this._mouseStarted && this._mouseUp(event));
          this._mouseDownEvent = event;
          var that = this,
              btnIsLeft = (event.which === 1),
              elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
          if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
            return true;
          }
          this.mouseDelayMet = !this.options.delay;
          if (!this.mouseDelayMet) {
            this._mouseDelayTimer = setTimeout(function() {
              that.mouseDelayMet = true;
            }, this.options.delay);
          }
          if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
            this._mouseStarted = (this._mouseStart(event) !== false);
            if (!this._mouseStarted) {
              event.preventDefault();
              return true;
            }
          }
          if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
            $.removeData(event.target, this.widgetName + ".preventClickEvent");
          }
          this._mouseMoveDelegate = function(event) {
            return that._mouseMove(event);
          };
          this._mouseUpDelegate = function(event) {
            return that._mouseUp(event);
          };
          this.document.bind("mousemove." + this.widgetName, this._mouseMoveDelegate).bind("mouseup." + this.widgetName, this._mouseUpDelegate);
          event.preventDefault();
          mouseHandled = true;
          return true;
        },
        _mouseMove: function(event) {
          if (this._mouseMoved) {
            if ($.ui.ie && (!document.documentMode || document.documentMode < 9) && !event.button) {
              return this._mouseUp(event);
            } else if (!event.which) {
              return this._mouseUp(event);
            }
          }
          if (event.which || event.button) {
            this._mouseMoved = true;
          }
          if (this._mouseStarted) {
            this._mouseDrag(event);
            return event.preventDefault();
          }
          if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
            this._mouseStarted = (this._mouseStart(this._mouseDownEvent, event) !== false);
            (this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
          }
          return !this._mouseStarted;
        },
        _mouseUp: function(event) {
          this.document.unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
          if (this._mouseStarted) {
            this._mouseStarted = false;
            if (event.target === this._mouseDownEvent.target) {
              $.data(event.target, this.widgetName + ".preventClickEvent", true);
            }
            this._mouseStop(event);
          }
          mouseHandled = false;
          return false;
        },
        _mouseDistanceMet: function(event) {
          return (Math.max(Math.abs(this._mouseDownEvent.pageX - event.pageX), Math.abs(this._mouseDownEvent.pageY - event.pageY)) >= this.options.distance);
        },
        _mouseDelayMet: function() {
          return this.mouseDelayMet;
        },
        _mouseStart: function() {},
        _mouseDrag: function() {},
        _mouseStop: function() {},
        _mouseCapture: function() {
          return true;
        }
      });
      (function() {
        $.ui = $.ui || {};
        var cachedScrollbarWidth,
            supportsOffsetFractions,
            max = Math.max,
            abs = Math.abs,
            round = Math.round,
            rhorizontal = /left|center|right/,
            rvertical = /top|center|bottom/,
            roffset = /[\+\-]\d+(\.[\d]+)?%?/,
            rposition = /^\w+/,
            rpercent = /%$/,
            _position = $.fn.position;
        function getOffsets(offsets, width, height) {
          return [parseFloat(offsets[0]) * (rpercent.test(offsets[0]) ? width / 100 : 1), parseFloat(offsets[1]) * (rpercent.test(offsets[1]) ? height / 100 : 1)];
        }
        function parseCss(element, property) {
          return parseInt($.css(element, property), 10) || 0;
        }
        function getDimensions(elem) {
          var raw = elem[0];
          if (raw.nodeType === 9) {
            return {
              width: elem.width(),
              height: elem.height(),
              offset: {
                top: 0,
                left: 0
              }
            };
          }
          if ($.isWindow(raw)) {
            return {
              width: elem.width(),
              height: elem.height(),
              offset: {
                top: elem.scrollTop(),
                left: elem.scrollLeft()
              }
            };
          }
          if (raw.preventDefault) {
            return {
              width: 0,
              height: 0,
              offset: {
                top: raw.pageY,
                left: raw.pageX
              }
            };
          }
          return {
            width: elem.outerWidth(),
            height: elem.outerHeight(),
            offset: elem.offset()
          };
        }
        $.position = {
          scrollbarWidth: function() {
            if (cachedScrollbarWidth !== undefined) {
              return cachedScrollbarWidth;
            }
            var w1,
                w2,
                div = $("<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),
                innerDiv = div.children()[0];
            $("body").append(div);
            w1 = innerDiv.offsetWidth;
            div.css("overflow", "scroll");
            w2 = innerDiv.offsetWidth;
            if (w1 === w2) {
              w2 = div[0].clientWidth;
            }
            div.remove();
            return (cachedScrollbarWidth = w1 - w2);
          },
          getScrollInfo: function(within) {
            var overflowX = within.isWindow || within.isDocument ? "" : within.element.css("overflow-x"),
                overflowY = within.isWindow || within.isDocument ? "" : within.element.css("overflow-y"),
                hasOverflowX = overflowX === "scroll" || (overflowX === "auto" && within.width < within.element[0].scrollWidth),
                hasOverflowY = overflowY === "scroll" || (overflowY === "auto" && within.height < within.element[0].scrollHeight);
            return {
              width: hasOverflowY ? $.position.scrollbarWidth() : 0,
              height: hasOverflowX ? $.position.scrollbarWidth() : 0
            };
          },
          getWithinInfo: function(element) {
            var withinElement = $(element || window),
                isWindow = $.isWindow(withinElement[0]),
                isDocument = !!withinElement[0] && withinElement[0].nodeType === 9;
            return {
              element: withinElement,
              isWindow: isWindow,
              isDocument: isDocument,
              offset: withinElement.offset() || {
                left: 0,
                top: 0
              },
              scrollLeft: withinElement.scrollLeft(),
              scrollTop: withinElement.scrollTop(),
              width: isWindow || isDocument ? withinElement.width() : withinElement.outerWidth(),
              height: isWindow || isDocument ? withinElement.height() : withinElement.outerHeight()
            };
          }
        };
        $.fn.position = function(options) {
          if (!options || !options.of) {
            return _position.apply(this, arguments);
          }
          options = $.extend({}, options);
          var atOffset,
              targetWidth,
              targetHeight,
              targetOffset,
              basePosition,
              dimensions,
              target = $(options.of),
              within = $.position.getWithinInfo(options.within),
              scrollInfo = $.position.getScrollInfo(within),
              collision = (options.collision || "flip").split(" "),
              offsets = {};
          dimensions = getDimensions(target);
          if (target[0].preventDefault) {
            options.at = "left top";
          }
          targetWidth = dimensions.width;
          targetHeight = dimensions.height;
          targetOffset = dimensions.offset;
          basePosition = $.extend({}, targetOffset);
          $.each(["my", "at"], function() {
            var pos = (options[this] || "").split(" "),
                horizontalOffset,
                verticalOffset;
            if (pos.length === 1) {
              pos = rhorizontal.test(pos[0]) ? pos.concat(["center"]) : rvertical.test(pos[0]) ? ["center"].concat(pos) : ["center", "center"];
            }
            pos[0] = rhorizontal.test(pos[0]) ? pos[0] : "center";
            pos[1] = rvertical.test(pos[1]) ? pos[1] : "center";
            horizontalOffset = roffset.exec(pos[0]);
            verticalOffset = roffset.exec(pos[1]);
            offsets[this] = [horizontalOffset ? horizontalOffset[0] : 0, verticalOffset ? verticalOffset[0] : 0];
            options[this] = [rposition.exec(pos[0])[0], rposition.exec(pos[1])[0]];
          });
          if (collision.length === 1) {
            collision[1] = collision[0];
          }
          if (options.at[0] === "right") {
            basePosition.left += targetWidth;
          } else if (options.at[0] === "center") {
            basePosition.left += targetWidth / 2;
          }
          if (options.at[1] === "bottom") {
            basePosition.top += targetHeight;
          } else if (options.at[1] === "center") {
            basePosition.top += targetHeight / 2;
          }
          atOffset = getOffsets(offsets.at, targetWidth, targetHeight);
          basePosition.left += atOffset[0];
          basePosition.top += atOffset[1];
          return this.each(function() {
            var collisionPosition,
                using,
                elem = $(this),
                elemWidth = elem.outerWidth(),
                elemHeight = elem.outerHeight(),
                marginLeft = parseCss(this, "marginLeft"),
                marginTop = parseCss(this, "marginTop"),
                collisionWidth = elemWidth + marginLeft + parseCss(this, "marginRight") + scrollInfo.width,
                collisionHeight = elemHeight + marginTop + parseCss(this, "marginBottom") + scrollInfo.height,
                position = $.extend({}, basePosition),
                myOffset = getOffsets(offsets.my, elem.outerWidth(), elem.outerHeight());
            if (options.my[0] === "right") {
              position.left -= elemWidth;
            } else if (options.my[0] === "center") {
              position.left -= elemWidth / 2;
            }
            if (options.my[1] === "bottom") {
              position.top -= elemHeight;
            } else if (options.my[1] === "center") {
              position.top -= elemHeight / 2;
            }
            position.left += myOffset[0];
            position.top += myOffset[1];
            if (!supportsOffsetFractions) {
              position.left = round(position.left);
              position.top = round(position.top);
            }
            collisionPosition = {
              marginLeft: marginLeft,
              marginTop: marginTop
            };
            $.each(["left", "top"], function(i, dir) {
              if ($.ui.position[collision[i]]) {
                $.ui.position[collision[i]][dir](position, {
                  targetWidth: targetWidth,
                  targetHeight: targetHeight,
                  elemWidth: elemWidth,
                  elemHeight: elemHeight,
                  collisionPosition: collisionPosition,
                  collisionWidth: collisionWidth,
                  collisionHeight: collisionHeight,
                  offset: [atOffset[0] + myOffset[0], atOffset[1] + myOffset[1]],
                  my: options.my,
                  at: options.at,
                  within: within,
                  elem: elem
                });
              }
            });
            if (options.using) {
              using = function(props) {
                var left = targetOffset.left - position.left,
                    right = left + targetWidth - elemWidth,
                    top = targetOffset.top - position.top,
                    bottom = top + targetHeight - elemHeight,
                    feedback = {
                      target: {
                        element: target,
                        left: targetOffset.left,
                        top: targetOffset.top,
                        width: targetWidth,
                        height: targetHeight
                      },
                      element: {
                        element: elem,
                        left: position.left,
                        top: position.top,
                        width: elemWidth,
                        height: elemHeight
                      },
                      horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
                      vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
                    };
                if (targetWidth < elemWidth && abs(left + right) < targetWidth) {
                  feedback.horizontal = "center";
                }
                if (targetHeight < elemHeight && abs(top + bottom) < targetHeight) {
                  feedback.vertical = "middle";
                }
                if (max(abs(left), abs(right)) > max(abs(top), abs(bottom))) {
                  feedback.important = "horizontal";
                } else {
                  feedback.important = "vertical";
                }
                options.using.call(this, props, feedback);
              };
            }
            elem.offset($.extend(position, {using: using}));
          });
        };
        $.ui.position = {
          fit: {
            left: function(position, data) {
              var within = data.within,
                  withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
                  outerWidth = within.width,
                  collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                  overLeft = withinOffset - collisionPosLeft,
                  overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
                  newOverRight;
              if (data.collisionWidth > outerWidth) {
                if (overLeft > 0 && overRight <= 0) {
                  newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
                  position.left += overLeft - newOverRight;
                } else if (overRight > 0 && overLeft <= 0) {
                  position.left = withinOffset;
                } else {
                  if (overLeft > overRight) {
                    position.left = withinOffset + outerWidth - data.collisionWidth;
                  } else {
                    position.left = withinOffset;
                  }
                }
              } else if (overLeft > 0) {
                position.left += overLeft;
              } else if (overRight > 0) {
                position.left -= overRight;
              } else {
                position.left = max(position.left - collisionPosLeft, position.left);
              }
            },
            top: function(position, data) {
              var within = data.within,
                  withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
                  outerHeight = data.within.height,
                  collisionPosTop = position.top - data.collisionPosition.marginTop,
                  overTop = withinOffset - collisionPosTop,
                  overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
                  newOverBottom;
              if (data.collisionHeight > outerHeight) {
                if (overTop > 0 && overBottom <= 0) {
                  newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
                  position.top += overTop - newOverBottom;
                } else if (overBottom > 0 && overTop <= 0) {
                  position.top = withinOffset;
                } else {
                  if (overTop > overBottom) {
                    position.top = withinOffset + outerHeight - data.collisionHeight;
                  } else {
                    position.top = withinOffset;
                  }
                }
              } else if (overTop > 0) {
                position.top += overTop;
              } else if (overBottom > 0) {
                position.top -= overBottom;
              } else {
                position.top = max(position.top - collisionPosTop, position.top);
              }
            }
          },
          flip: {
            left: function(position, data) {
              var within = data.within,
                  withinOffset = within.offset.left + within.scrollLeft,
                  outerWidth = within.width,
                  offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
                  collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                  overLeft = collisionPosLeft - offsetLeft,
                  overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
                  myOffset = data.my[0] === "left" ? -data.elemWidth : data.my[0] === "right" ? data.elemWidth : 0,
                  atOffset = data.at[0] === "left" ? data.targetWidth : data.at[0] === "right" ? -data.targetWidth : 0,
                  offset = -2 * data.offset[0],
                  newOverRight,
                  newOverLeft;
              if (overLeft < 0) {
                newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
                if (newOverRight < 0 || newOverRight < abs(overLeft)) {
                  position.left += myOffset + atOffset + offset;
                }
              } else if (overRight > 0) {
                newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
                if (newOverLeft > 0 || abs(newOverLeft) < overRight) {
                  position.left += myOffset + atOffset + offset;
                }
              }
            },
            top: function(position, data) {
              var within = data.within,
                  withinOffset = within.offset.top + within.scrollTop,
                  outerHeight = within.height,
                  offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
                  collisionPosTop = position.top - data.collisionPosition.marginTop,
                  overTop = collisionPosTop - offsetTop,
                  overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
                  top = data.my[1] === "top",
                  myOffset = top ? -data.elemHeight : data.my[1] === "bottom" ? data.elemHeight : 0,
                  atOffset = data.at[1] === "top" ? data.targetHeight : data.at[1] === "bottom" ? -data.targetHeight : 0,
                  offset = -2 * data.offset[1],
                  newOverTop,
                  newOverBottom;
              if (overTop < 0) {
                newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
                if (newOverBottom < 0 || newOverBottom < abs(overTop)) {
                  position.top += myOffset + atOffset + offset;
                }
              } else if (overBottom > 0) {
                newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
                if (newOverTop > 0 || abs(newOverTop) < overBottom) {
                  position.top += myOffset + atOffset + offset;
                }
              }
            }
          },
          flipfit: {
            left: function() {
              $.ui.position.flip.left.apply(this, arguments);
              $.ui.position.fit.left.apply(this, arguments);
            },
            top: function() {
              $.ui.position.flip.top.apply(this, arguments);
              $.ui.position.fit.top.apply(this, arguments);
            }
          }
        };
        (function() {
          var testElement,
              testElementParent,
              testElementStyle,
              offsetLeft,
              i,
              body = document.getElementsByTagName("body")[0],
              div = document.createElement("div");
          testElement = document.createElement(body ? "div" : "body");
          testElementStyle = {
            visibility: "hidden",
            width: 0,
            height: 0,
            border: 0,
            margin: 0,
            background: "none"
          };
          if (body) {
            $.extend(testElementStyle, {
              position: "absolute",
              left: "-1000px",
              top: "-1000px"
            });
          }
          for (i in testElementStyle) {
            testElement.style[i] = testElementStyle[i];
          }
          testElement.appendChild(div);
          testElementParent = body || document.documentElement;
          testElementParent.insertBefore(testElement, testElementParent.firstChild);
          div.style.cssText = "position: absolute; left: 10.7432222px;";
          offsetLeft = $(div).offset().left;
          supportsOffsetFractions = offsetLeft > 10 && offsetLeft < 11;
          testElement.innerHTML = "";
          testElementParent.removeChild(testElement);
        })();
      })();
      var position = $.ui.position;
      var accordion = $.widget("ui.accordion", {
        version: "1.11.3",
        options: {
          active: 0,
          animate: {},
          collapsible: false,
          event: "click",
          header: "> li > :first-child,> :not(li):even",
          heightStyle: "auto",
          icons: {
            activeHeader: "ui-icon-triangle-1-s",
            header: "ui-icon-triangle-1-e"
          },
          activate: null,
          beforeActivate: null
        },
        hideProps: {
          borderTopWidth: "hide",
          borderBottomWidth: "hide",
          paddingTop: "hide",
          paddingBottom: "hide",
          height: "hide"
        },
        showProps: {
          borderTopWidth: "show",
          borderBottomWidth: "show",
          paddingTop: "show",
          paddingBottom: "show",
          height: "show"
        },
        _create: function() {
          var options = this.options;
          this.prevShow = this.prevHide = $();
          this.element.addClass("ui-accordion ui-widget ui-helper-reset").attr("role", "tablist");
          if (!options.collapsible && (options.active === false || options.active == null)) {
            options.active = 0;
          }
          this._processPanels();
          if (options.active < 0) {
            options.active += this.headers.length;
          }
          this._refresh();
        },
        _getCreateEventData: function() {
          return {
            header: this.active,
            panel: !this.active.length ? $() : this.active.next()
          };
        },
        _createIcons: function() {
          var icons = this.options.icons;
          if (icons) {
            $("<span>").addClass("ui-accordion-header-icon ui-icon " + icons.header).prependTo(this.headers);
            this.active.children(".ui-accordion-header-icon").removeClass(icons.header).addClass(icons.activeHeader);
            this.headers.addClass("ui-accordion-icons");
          }
        },
        _destroyIcons: function() {
          this.headers.removeClass("ui-accordion-icons").children(".ui-accordion-header-icon").remove();
        },
        _destroy: function() {
          var contents;
          this.element.removeClass("ui-accordion ui-widget ui-helper-reset").removeAttr("role");
          this.headers.removeClass("ui-accordion-header ui-accordion-header-active ui-state-default " + "ui-corner-all ui-state-active ui-state-disabled ui-corner-top").removeAttr("role").removeAttr("aria-expanded").removeAttr("aria-selected").removeAttr("aria-controls").removeAttr("tabIndex").removeUniqueId();
          this._destroyIcons();
          contents = this.headers.next().removeClass("ui-helper-reset ui-widget-content ui-corner-bottom " + "ui-accordion-content ui-accordion-content-active ui-state-disabled").css("display", "").removeAttr("role").removeAttr("aria-hidden").removeAttr("aria-labelledby").removeUniqueId();
          if (this.options.heightStyle !== "content") {
            contents.css("height", "");
          }
        },
        _setOption: function(key, value) {
          if (key === "active") {
            this._activate(value);
            return ;
          }
          if (key === "event") {
            if (this.options.event) {
              this._off(this.headers, this.options.event);
            }
            this._setupEvents(value);
          }
          this._super(key, value);
          if (key === "collapsible" && !value && this.options.active === false) {
            this._activate(0);
          }
          if (key === "icons") {
            this._destroyIcons();
            if (value) {
              this._createIcons();
            }
          }
          if (key === "disabled") {
            this.element.toggleClass("ui-state-disabled", !!value).attr("aria-disabled", value);
            this.headers.add(this.headers.next()).toggleClass("ui-state-disabled", !!value);
          }
        },
        _keydown: function(event) {
          if (event.altKey || event.ctrlKey) {
            return ;
          }
          var keyCode = $.ui.keyCode,
              length = this.headers.length,
              currentIndex = this.headers.index(event.target),
              toFocus = false;
          switch (event.keyCode) {
            case keyCode.RIGHT:
            case keyCode.DOWN:
              toFocus = this.headers[(currentIndex + 1) % length];
              break;
            case keyCode.LEFT:
            case keyCode.UP:
              toFocus = this.headers[(currentIndex - 1 + length) % length];
              break;
            case keyCode.SPACE:
            case keyCode.ENTER:
              this._eventHandler(event);
              break;
            case keyCode.HOME:
              toFocus = this.headers[0];
              break;
            case keyCode.END:
              toFocus = this.headers[length - 1];
              break;
          }
          if (toFocus) {
            $(event.target).attr("tabIndex", -1);
            $(toFocus).attr("tabIndex", 0);
            toFocus.focus();
            event.preventDefault();
          }
        },
        _panelKeyDown: function(event) {
          if (event.keyCode === $.ui.keyCode.UP && event.ctrlKey) {
            $(event.currentTarget).prev().focus();
          }
        },
        refresh: function() {
          var options = this.options;
          this._processPanels();
          if ((options.active === false && options.collapsible === true) || !this.headers.length) {
            options.active = false;
            this.active = $();
          } else if (options.active === false) {
            this._activate(0);
          } else if (this.active.length && !$.contains(this.element[0], this.active[0])) {
            if (this.headers.length === this.headers.find(".ui-state-disabled").length) {
              options.active = false;
              this.active = $();
            } else {
              this._activate(Math.max(0, options.active - 1));
            }
          } else {
            options.active = this.headers.index(this.active);
          }
          this._destroyIcons();
          this._refresh();
        },
        _processPanels: function() {
          var prevHeaders = this.headers,
              prevPanels = this.panels;
          this.headers = this.element.find(this.options.header).addClass("ui-accordion-header ui-state-default ui-corner-all");
          this.panels = this.headers.next().addClass("ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom").filter(":not(.ui-accordion-content-active)").hide();
          if (prevPanels) {
            this._off(prevHeaders.not(this.headers));
            this._off(prevPanels.not(this.panels));
          }
        },
        _refresh: function() {
          var maxHeight,
              options = this.options,
              heightStyle = options.heightStyle,
              parent = this.element.parent();
          this.active = this._findActive(options.active).addClass("ui-accordion-header-active ui-state-active ui-corner-top").removeClass("ui-corner-all");
          this.active.next().addClass("ui-accordion-content-active").show();
          this.headers.attr("role", "tab").each(function() {
            var header = $(this),
                headerId = header.uniqueId().attr("id"),
                panel = header.next(),
                panelId = panel.uniqueId().attr("id");
            header.attr("aria-controls", panelId);
            panel.attr("aria-labelledby", headerId);
          }).next().attr("role", "tabpanel");
          this.headers.not(this.active).attr({
            "aria-selected": "false",
            "aria-expanded": "false",
            tabIndex: -1
          }).next().attr({"aria-hidden": "true"}).hide();
          if (!this.active.length) {
            this.headers.eq(0).attr("tabIndex", 0);
          } else {
            this.active.attr({
              "aria-selected": "true",
              "aria-expanded": "true",
              tabIndex: 0
            }).next().attr({"aria-hidden": "false"});
          }
          this._createIcons();
          this._setupEvents(options.event);
          if (heightStyle === "fill") {
            maxHeight = parent.height();
            this.element.siblings(":visible").each(function() {
              var elem = $(this),
                  position = elem.css("position");
              if (position === "absolute" || position === "fixed") {
                return ;
              }
              maxHeight -= elem.outerHeight(true);
            });
            this.headers.each(function() {
              maxHeight -= $(this).outerHeight(true);
            });
            this.headers.next().each(function() {
              $(this).height(Math.max(0, maxHeight - $(this).innerHeight() + $(this).height()));
            }).css("overflow", "auto");
          } else if (heightStyle === "auto") {
            maxHeight = 0;
            this.headers.next().each(function() {
              maxHeight = Math.max(maxHeight, $(this).css("height", "").height());
            }).height(maxHeight);
          }
        },
        _activate: function(index) {
          var active = this._findActive(index)[0];
          if (active === this.active[0]) {
            return ;
          }
          active = active || this.active[0];
          this._eventHandler({
            target: active,
            currentTarget: active,
            preventDefault: $.noop
          });
        },
        _findActive: function(selector) {
          return typeof selector === "number" ? this.headers.eq(selector) : $();
        },
        _setupEvents: function(event) {
          var events = {keydown: "_keydown"};
          if (event) {
            $.each(event.split(" "), function(index, eventName) {
              events[eventName] = "_eventHandler";
            });
          }
          this._off(this.headers.add(this.headers.next()));
          this._on(this.headers, events);
          this._on(this.headers.next(), {keydown: "_panelKeyDown"});
          this._hoverable(this.headers);
          this._focusable(this.headers);
        },
        _eventHandler: function(event) {
          var options = this.options,
              active = this.active,
              clicked = $(event.currentTarget),
              clickedIsActive = clicked[0] === active[0],
              collapsing = clickedIsActive && options.collapsible,
              toShow = collapsing ? $() : clicked.next(),
              toHide = active.next(),
              eventData = {
                oldHeader: active,
                oldPanel: toHide,
                newHeader: collapsing ? $() : clicked,
                newPanel: toShow
              };
          event.preventDefault();
          if ((clickedIsActive && !options.collapsible) || (this._trigger("beforeActivate", event, eventData) === false)) {
            return ;
          }
          options.active = collapsing ? false : this.headers.index(clicked);
          this.active = clickedIsActive ? $() : clicked;
          this._toggle(eventData);
          active.removeClass("ui-accordion-header-active ui-state-active");
          if (options.icons) {
            active.children(".ui-accordion-header-icon").removeClass(options.icons.activeHeader).addClass(options.icons.header);
          }
          if (!clickedIsActive) {
            clicked.removeClass("ui-corner-all").addClass("ui-accordion-header-active ui-state-active ui-corner-top");
            if (options.icons) {
              clicked.children(".ui-accordion-header-icon").removeClass(options.icons.header).addClass(options.icons.activeHeader);
            }
            clicked.next().addClass("ui-accordion-content-active");
          }
        },
        _toggle: function(data) {
          var toShow = data.newPanel,
              toHide = this.prevShow.length ? this.prevShow : data.oldPanel;
          this.prevShow.add(this.prevHide).stop(true, true);
          this.prevShow = toShow;
          this.prevHide = toHide;
          if (this.options.animate) {
            this._animate(toShow, toHide, data);
          } else {
            toHide.hide();
            toShow.show();
            this._toggleComplete(data);
          }
          toHide.attr({"aria-hidden": "true"});
          toHide.prev().attr({
            "aria-selected": "false",
            "aria-expanded": "false"
          });
          if (toShow.length && toHide.length) {
            toHide.prev().attr({
              "tabIndex": -1,
              "aria-expanded": "false"
            });
          } else if (toShow.length) {
            this.headers.filter(function() {
              return parseInt($(this).attr("tabIndex"), 10) === 0;
            }).attr("tabIndex", -1);
          }
          toShow.attr("aria-hidden", "false").prev().attr({
            "aria-selected": "true",
            "aria-expanded": "true",
            tabIndex: 0
          });
        },
        _animate: function(toShow, toHide, data) {
          var total,
              easing,
              duration,
              that = this,
              adjust = 0,
              down = toShow.length && (!toHide.length || (toShow.index() < toHide.index())),
              animate = this.options.animate || {},
              options = down && animate.down || animate,
              complete = function() {
                that._toggleComplete(data);
              };
          if (typeof options === "number") {
            duration = options;
          }
          if (typeof options === "string") {
            easing = options;
          }
          easing = easing || options.easing || animate.easing;
          duration = duration || options.duration || animate.duration;
          if (!toHide.length) {
            return toShow.animate(this.showProps, duration, easing, complete);
          }
          if (!toShow.length) {
            return toHide.animate(this.hideProps, duration, easing, complete);
          }
          total = toShow.show().outerHeight();
          toHide.animate(this.hideProps, {
            duration: duration,
            easing: easing,
            step: function(now, fx) {
              fx.now = Math.round(now);
            }
          });
          toShow.hide().animate(this.showProps, {
            duration: duration,
            easing: easing,
            complete: complete,
            step: function(now, fx) {
              fx.now = Math.round(now);
              if (fx.prop !== "height") {
                adjust += fx.now;
              } else if (that.options.heightStyle !== "content") {
                fx.now = Math.round(total - toHide.outerHeight() - adjust);
                adjust = 0;
              }
            }
          });
        },
        _toggleComplete: function(data) {
          var toHide = data.oldPanel;
          toHide.removeClass("ui-accordion-content-active").prev().removeClass("ui-corner-top").addClass("ui-corner-all");
          if (toHide.length) {
            toHide.parent()[0].className = toHide.parent()[0].className;
          }
          this._trigger("activate", null, data);
        }
      });
      var menu = $.widget("ui.menu", {
        version: "1.11.3",
        defaultElement: "<ul>",
        delay: 300,
        options: {
          icons: {submenu: "ui-icon-carat-1-e"},
          items: "> *",
          menus: "ul",
          position: {
            my: "left-1 top",
            at: "right top"
          },
          role: "menu",
          blur: null,
          focus: null,
          select: null
        },
        _create: function() {
          this.activeMenu = this.element;
          this.mouseHandled = false;
          this.element.uniqueId().addClass("ui-menu ui-widget ui-widget-content").toggleClass("ui-menu-icons", !!this.element.find(".ui-icon").length).attr({
            role: this.options.role,
            tabIndex: 0
          });
          if (this.options.disabled) {
            this.element.addClass("ui-state-disabled").attr("aria-disabled", "true");
          }
          this._on({
            "mousedown .ui-menu-item": function(event) {
              event.preventDefault();
            },
            "click .ui-menu-item": function(event) {
              var target = $(event.target);
              if (!this.mouseHandled && target.not(".ui-state-disabled").length) {
                this.select(event);
                if (!event.isPropagationStopped()) {
                  this.mouseHandled = true;
                }
                if (target.has(".ui-menu").length) {
                  this.expand(event);
                } else if (!this.element.is(":focus") && $(this.document[0].activeElement).closest(".ui-menu").length) {
                  this.element.trigger("focus", [true]);
                  if (this.active && this.active.parents(".ui-menu").length === 1) {
                    clearTimeout(this.timer);
                  }
                }
              }
            },
            "mouseenter .ui-menu-item": function(event) {
              if (this.previousFilter) {
                return ;
              }
              var target = $(event.currentTarget);
              target.siblings(".ui-state-active").removeClass("ui-state-active");
              this.focus(event, target);
            },
            mouseleave: "collapseAll",
            "mouseleave .ui-menu": "collapseAll",
            focus: function(event, keepActiveItem) {
              var item = this.active || this.element.find(this.options.items).eq(0);
              if (!keepActiveItem) {
                this.focus(event, item);
              }
            },
            blur: function(event) {
              this._delay(function() {
                if (!$.contains(this.element[0], this.document[0].activeElement)) {
                  this.collapseAll(event);
                }
              });
            },
            keydown: "_keydown"
          });
          this.refresh();
          this._on(this.document, {click: function(event) {
              if (this._closeOnDocumentClick(event)) {
                this.collapseAll(event);
              }
              this.mouseHandled = false;
            }});
        },
        _destroy: function() {
          this.element.removeAttr("aria-activedescendant").find(".ui-menu").addBack().removeClass("ui-menu ui-widget ui-widget-content ui-menu-icons ui-front").removeAttr("role").removeAttr("tabIndex").removeAttr("aria-labelledby").removeAttr("aria-expanded").removeAttr("aria-hidden").removeAttr("aria-disabled").removeUniqueId().show();
          this.element.find(".ui-menu-item").removeClass("ui-menu-item").removeAttr("role").removeAttr("aria-disabled").removeUniqueId().removeClass("ui-state-hover").removeAttr("tabIndex").removeAttr("role").removeAttr("aria-haspopup").children().each(function() {
            var elem = $(this);
            if (elem.data("ui-menu-submenu-carat")) {
              elem.remove();
            }
          });
          this.element.find(".ui-menu-divider").removeClass("ui-menu-divider ui-widget-content");
        },
        _keydown: function(event) {
          var match,
              prev,
              character,
              skip,
              preventDefault = true;
          switch (event.keyCode) {
            case $.ui.keyCode.PAGE_UP:
              this.previousPage(event);
              break;
            case $.ui.keyCode.PAGE_DOWN:
              this.nextPage(event);
              break;
            case $.ui.keyCode.HOME:
              this._move("first", "first", event);
              break;
            case $.ui.keyCode.END:
              this._move("last", "last", event);
              break;
            case $.ui.keyCode.UP:
              this.previous(event);
              break;
            case $.ui.keyCode.DOWN:
              this.next(event);
              break;
            case $.ui.keyCode.LEFT:
              this.collapse(event);
              break;
            case $.ui.keyCode.RIGHT:
              if (this.active && !this.active.is(".ui-state-disabled")) {
                this.expand(event);
              }
              break;
            case $.ui.keyCode.ENTER:
            case $.ui.keyCode.SPACE:
              this._activate(event);
              break;
            case $.ui.keyCode.ESCAPE:
              this.collapse(event);
              break;
            default:
              preventDefault = false;
              prev = this.previousFilter || "";
              character = String.fromCharCode(event.keyCode);
              skip = false;
              clearTimeout(this.filterTimer);
              if (character === prev) {
                skip = true;
              } else {
                character = prev + character;
              }
              match = this._filterMenuItems(character);
              match = skip && match.index(this.active.next()) !== -1 ? this.active.nextAll(".ui-menu-item") : match;
              if (!match.length) {
                character = String.fromCharCode(event.keyCode);
                match = this._filterMenuItems(character);
              }
              if (match.length) {
                this.focus(event, match);
                this.previousFilter = character;
                this.filterTimer = this._delay(function() {
                  delete this.previousFilter;
                }, 1000);
              } else {
                delete this.previousFilter;
              }
          }
          if (preventDefault) {
            event.preventDefault();
          }
        },
        _activate: function(event) {
          if (!this.active.is(".ui-state-disabled")) {
            if (this.active.is("[aria-haspopup='true']")) {
              this.expand(event);
            } else {
              this.select(event);
            }
          }
        },
        refresh: function() {
          var menus,
              items,
              that = this,
              icon = this.options.icons.submenu,
              submenus = this.element.find(this.options.menus);
          this.element.toggleClass("ui-menu-icons", !!this.element.find(".ui-icon").length);
          submenus.filter(":not(.ui-menu)").addClass("ui-menu ui-widget ui-widget-content ui-front").hide().attr({
            role: this.options.role,
            "aria-hidden": "true",
            "aria-expanded": "false"
          }).each(function() {
            var menu = $(this),
                item = menu.parent(),
                submenuCarat = $("<span>").addClass("ui-menu-icon ui-icon " + icon).data("ui-menu-submenu-carat", true);
            item.attr("aria-haspopup", "true").prepend(submenuCarat);
            menu.attr("aria-labelledby", item.attr("id"));
          });
          menus = submenus.add(this.element);
          items = menus.find(this.options.items);
          items.not(".ui-menu-item").each(function() {
            var item = $(this);
            if (that._isDivider(item)) {
              item.addClass("ui-widget-content ui-menu-divider");
            }
          });
          items.not(".ui-menu-item, .ui-menu-divider").addClass("ui-menu-item").uniqueId().attr({
            tabIndex: -1,
            role: this._itemRole()
          });
          items.filter(".ui-state-disabled").attr("aria-disabled", "true");
          if (this.active && !$.contains(this.element[0], this.active[0])) {
            this.blur();
          }
        },
        _itemRole: function() {
          return {
            menu: "menuitem",
            listbox: "option"
          }[this.options.role];
        },
        _setOption: function(key, value) {
          if (key === "icons") {
            this.element.find(".ui-menu-icon").removeClass(this.options.icons.submenu).addClass(value.submenu);
          }
          if (key === "disabled") {
            this.element.toggleClass("ui-state-disabled", !!value).attr("aria-disabled", value);
          }
          this._super(key, value);
        },
        focus: function(event, item) {
          var nested,
              focused;
          this.blur(event, event && event.type === "focus");
          this._scrollIntoView(item);
          this.active = item.first();
          focused = this.active.addClass("ui-state-focus").removeClass("ui-state-active");
          if (this.options.role) {
            this.element.attr("aria-activedescendant", focused.attr("id"));
          }
          this.active.parent().closest(".ui-menu-item").addClass("ui-state-active");
          if (event && event.type === "keydown") {
            this._close();
          } else {
            this.timer = this._delay(function() {
              this._close();
            }, this.delay);
          }
          nested = item.children(".ui-menu");
          if (nested.length && event && (/^mouse/.test(event.type))) {
            this._startOpening(nested);
          }
          this.activeMenu = item.parent();
          this._trigger("focus", event, {item: item});
        },
        _scrollIntoView: function(item) {
          var borderTop,
              paddingTop,
              offset,
              scroll,
              elementHeight,
              itemHeight;
          if (this._hasScroll()) {
            borderTop = parseFloat($.css(this.activeMenu[0], "borderTopWidth")) || 0;
            paddingTop = parseFloat($.css(this.activeMenu[0], "paddingTop")) || 0;
            offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
            scroll = this.activeMenu.scrollTop();
            elementHeight = this.activeMenu.height();
            itemHeight = item.outerHeight();
            if (offset < 0) {
              this.activeMenu.scrollTop(scroll + offset);
            } else if (offset + itemHeight > elementHeight) {
              this.activeMenu.scrollTop(scroll + offset - elementHeight + itemHeight);
            }
          }
        },
        blur: function(event, fromFocus) {
          if (!fromFocus) {
            clearTimeout(this.timer);
          }
          if (!this.active) {
            return ;
          }
          this.active.removeClass("ui-state-focus");
          this.active = null;
          this._trigger("blur", event, {item: this.active});
        },
        _startOpening: function(submenu) {
          clearTimeout(this.timer);
          if (submenu.attr("aria-hidden") !== "true") {
            return ;
          }
          this.timer = this._delay(function() {
            this._close();
            this._open(submenu);
          }, this.delay);
        },
        _open: function(submenu) {
          var position = $.extend({of: this.active}, this.options.position);
          clearTimeout(this.timer);
          this.element.find(".ui-menu").not(submenu.parents(".ui-menu")).hide().attr("aria-hidden", "true");
          submenu.show().removeAttr("aria-hidden").attr("aria-expanded", "true").position(position);
        },
        collapseAll: function(event, all) {
          clearTimeout(this.timer);
          this.timer = this._delay(function() {
            var currentMenu = all ? this.element : $(event && event.target).closest(this.element.find(".ui-menu"));
            if (!currentMenu.length) {
              currentMenu = this.element;
            }
            this._close(currentMenu);
            this.blur(event);
            this.activeMenu = currentMenu;
          }, this.delay);
        },
        _close: function(startMenu) {
          if (!startMenu) {
            startMenu = this.active ? this.active.parent() : this.element;
          }
          startMenu.find(".ui-menu").hide().attr("aria-hidden", "true").attr("aria-expanded", "false").end().find(".ui-state-active").not(".ui-state-focus").removeClass("ui-state-active");
        },
        _closeOnDocumentClick: function(event) {
          return !$(event.target).closest(".ui-menu").length;
        },
        _isDivider: function(item) {
          return !/[^\-\u2014\u2013\s]/.test(item.text());
        },
        collapse: function(event) {
          var newItem = this.active && this.active.parent().closest(".ui-menu-item", this.element);
          if (newItem && newItem.length) {
            this._close();
            this.focus(event, newItem);
          }
        },
        expand: function(event) {
          var newItem = this.active && this.active.children(".ui-menu ").find(this.options.items).first();
          if (newItem && newItem.length) {
            this._open(newItem.parent());
            this._delay(function() {
              this.focus(event, newItem);
            });
          }
        },
        next: function(event) {
          this._move("next", "first", event);
        },
        previous: function(event) {
          this._move("prev", "last", event);
        },
        isFirstItem: function() {
          return this.active && !this.active.prevAll(".ui-menu-item").length;
        },
        isLastItem: function() {
          return this.active && !this.active.nextAll(".ui-menu-item").length;
        },
        _move: function(direction, filter, event) {
          var next;
          if (this.active) {
            if (direction === "first" || direction === "last") {
              next = this.active[direction === "first" ? "prevAll" : "nextAll"](".ui-menu-item").eq(-1);
            } else {
              next = this.active[direction + "All"](".ui-menu-item").eq(0);
            }
          }
          if (!next || !next.length || !this.active) {
            next = this.activeMenu.find(this.options.items)[filter]();
          }
          this.focus(event, next);
        },
        nextPage: function(event) {
          var item,
              base,
              height;
          if (!this.active) {
            this.next(event);
            return ;
          }
          if (this.isLastItem()) {
            return ;
          }
          if (this._hasScroll()) {
            base = this.active.offset().top;
            height = this.element.height();
            this.active.nextAll(".ui-menu-item").each(function() {
              item = $(this);
              return item.offset().top - base - height < 0;
            });
            this.focus(event, item);
          } else {
            this.focus(event, this.activeMenu.find(this.options.items)[!this.active ? "first" : "last"]());
          }
        },
        previousPage: function(event) {
          var item,
              base,
              height;
          if (!this.active) {
            this.next(event);
            return ;
          }
          if (this.isFirstItem()) {
            return ;
          }
          if (this._hasScroll()) {
            base = this.active.offset().top;
            height = this.element.height();
            this.active.prevAll(".ui-menu-item").each(function() {
              item = $(this);
              return item.offset().top - base + height > 0;
            });
            this.focus(event, item);
          } else {
            this.focus(event, this.activeMenu.find(this.options.items).first());
          }
        },
        _hasScroll: function() {
          return this.element.outerHeight() < this.element.prop("scrollHeight");
        },
        select: function(event) {
          this.active = this.active || $(event.target).closest(".ui-menu-item");
          var ui = {item: this.active};
          if (!this.active.has(".ui-menu").length) {
            this.collapseAll(event, true);
          }
          this._trigger("select", event, ui);
        },
        _filterMenuItems: function(character) {
          var escapedCharacter = character.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&"),
              regex = new RegExp("^" + escapedCharacter, "i");
          return this.activeMenu.find(this.options.items).filter(".ui-menu-item").filter(function() {
            return regex.test($.trim($(this).text()));
          });
        }
      });
      $.widget("ui.autocomplete", {
        version: "1.11.3",
        defaultElement: "<input>",
        options: {
          appendTo: null,
          autoFocus: false,
          delay: 300,
          minLength: 1,
          position: {
            my: "left top",
            at: "left bottom",
            collision: "none"
          },
          source: null,
          change: null,
          close: null,
          focus: null,
          open: null,
          response: null,
          search: null,
          select: null
        },
        requestIndex: 0,
        pending: 0,
        _create: function() {
          var suppressKeyPress,
              suppressKeyPressRepeat,
              suppressInput,
              nodeName = this.element[0].nodeName.toLowerCase(),
              isTextarea = nodeName === "textarea",
              isInput = nodeName === "input";
          this.isMultiLine = isTextarea ? true : isInput ? false : this.element.prop("isContentEditable");
          this.valueMethod = this.element[isTextarea || isInput ? "val" : "text"];
          this.isNewMenu = true;
          this.element.addClass("ui-autocomplete-input").attr("autocomplete", "off");
          this._on(this.element, {
            keydown: function(event) {
              if (this.element.prop("readOnly")) {
                suppressKeyPress = true;
                suppressInput = true;
                suppressKeyPressRepeat = true;
                return ;
              }
              suppressKeyPress = false;
              suppressInput = false;
              suppressKeyPressRepeat = false;
              var keyCode = $.ui.keyCode;
              switch (event.keyCode) {
                case keyCode.PAGE_UP:
                  suppressKeyPress = true;
                  this._move("previousPage", event);
                  break;
                case keyCode.PAGE_DOWN:
                  suppressKeyPress = true;
                  this._move("nextPage", event);
                  break;
                case keyCode.UP:
                  suppressKeyPress = true;
                  this._keyEvent("previous", event);
                  break;
                case keyCode.DOWN:
                  suppressKeyPress = true;
                  this._keyEvent("next", event);
                  break;
                case keyCode.ENTER:
                  if (this.menu.active) {
                    suppressKeyPress = true;
                    event.preventDefault();
                    this.menu.select(event);
                  }
                  break;
                case keyCode.TAB:
                  if (this.menu.active) {
                    this.menu.select(event);
                  }
                  break;
                case keyCode.ESCAPE:
                  if (this.menu.element.is(":visible")) {
                    if (!this.isMultiLine) {
                      this._value(this.term);
                    }
                    this.close(event);
                    event.preventDefault();
                  }
                  break;
                default:
                  suppressKeyPressRepeat = true;
                  this._searchTimeout(event);
                  break;
              }
            },
            keypress: function(event) {
              if (suppressKeyPress) {
                suppressKeyPress = false;
                if (!this.isMultiLine || this.menu.element.is(":visible")) {
                  event.preventDefault();
                }
                return ;
              }
              if (suppressKeyPressRepeat) {
                return ;
              }
              var keyCode = $.ui.keyCode;
              switch (event.keyCode) {
                case keyCode.PAGE_UP:
                  this._move("previousPage", event);
                  break;
                case keyCode.PAGE_DOWN:
                  this._move("nextPage", event);
                  break;
                case keyCode.UP:
                  this._keyEvent("previous", event);
                  break;
                case keyCode.DOWN:
                  this._keyEvent("next", event);
                  break;
              }
            },
            input: function(event) {
              if (suppressInput) {
                suppressInput = false;
                event.preventDefault();
                return ;
              }
              this._searchTimeout(event);
            },
            focus: function() {
              this.selectedItem = null;
              this.previous = this._value();
            },
            blur: function(event) {
              if (this.cancelBlur) {
                delete this.cancelBlur;
                return ;
              }
              clearTimeout(this.searching);
              this.close(event);
              this._change(event);
            }
          });
          this._initSource();
          this.menu = $("<ul>").addClass("ui-autocomplete ui-front").appendTo(this._appendTo()).menu({role: null}).hide().menu("instance");
          this._on(this.menu.element, {
            mousedown: function(event) {
              event.preventDefault();
              this.cancelBlur = true;
              this._delay(function() {
                delete this.cancelBlur;
              });
              var menuElement = this.menu.element[0];
              if (!$(event.target).closest(".ui-menu-item").length) {
                this._delay(function() {
                  var that = this;
                  this.document.one("mousedown", function(event) {
                    if (event.target !== that.element[0] && event.target !== menuElement && !$.contains(menuElement, event.target)) {
                      that.close();
                    }
                  });
                });
              }
            },
            menufocus: function(event, ui) {
              var label,
                  item;
              if (this.isNewMenu) {
                this.isNewMenu = false;
                if (event.originalEvent && /^mouse/.test(event.originalEvent.type)) {
                  this.menu.blur();
                  this.document.one("mousemove", function() {
                    $(event.target).trigger(event.originalEvent);
                  });
                  return ;
                }
              }
              item = ui.item.data("ui-autocomplete-item");
              if (false !== this._trigger("focus", event, {item: item})) {
                if (event.originalEvent && /^key/.test(event.originalEvent.type)) {
                  this._value(item.value);
                }
              }
              label = ui.item.attr("aria-label") || item.value;
              if (label && $.trim(label).length) {
                this.liveRegion.children().hide();
                $("<div>").text(label).appendTo(this.liveRegion);
              }
            },
            menuselect: function(event, ui) {
              var item = ui.item.data("ui-autocomplete-item"),
                  previous = this.previous;
              if (this.element[0] !== this.document[0].activeElement) {
                this.element.focus();
                this.previous = previous;
                this._delay(function() {
                  this.previous = previous;
                  this.selectedItem = item;
                });
              }
              if (false !== this._trigger("select", event, {item: item})) {
                this._value(item.value);
              }
              this.term = this._value();
              this.close(event);
              this.selectedItem = item;
            }
          });
          this.liveRegion = $("<span>", {
            role: "status",
            "aria-live": "assertive",
            "aria-relevant": "additions"
          }).addClass("ui-helper-hidden-accessible").appendTo(this.document[0].body);
          this._on(this.window, {beforeunload: function() {
              this.element.removeAttr("autocomplete");
            }});
        },
        _destroy: function() {
          clearTimeout(this.searching);
          this.element.removeClass("ui-autocomplete-input").removeAttr("autocomplete");
          this.menu.element.remove();
          this.liveRegion.remove();
        },
        _setOption: function(key, value) {
          this._super(key, value);
          if (key === "source") {
            this._initSource();
          }
          if (key === "appendTo") {
            this.menu.element.appendTo(this._appendTo());
          }
          if (key === "disabled" && value && this.xhr) {
            this.xhr.abort();
          }
        },
        _appendTo: function() {
          var element = this.options.appendTo;
          if (element) {
            element = element.jquery || element.nodeType ? $(element) : this.document.find(element).eq(0);
          }
          if (!element || !element[0]) {
            element = this.element.closest(".ui-front");
          }
          if (!element.length) {
            element = this.document[0].body;
          }
          return element;
        },
        _initSource: function() {
          var array,
              url,
              that = this;
          if ($.isArray(this.options.source)) {
            array = this.options.source;
            this.source = function(request, response) {
              response($.ui.autocomplete.filter(array, request.term));
            };
          } else if (typeof this.options.source === "string") {
            url = this.options.source;
            this.source = function(request, response) {
              if (that.xhr) {
                that.xhr.abort();
              }
              that.xhr = $.ajax({
                url: url,
                data: request,
                dataType: "json",
                success: function(data) {
                  response(data);
                },
                error: function() {
                  response([]);
                }
              });
            };
          } else {
            this.source = this.options.source;
          }
        },
        _searchTimeout: function(event) {
          clearTimeout(this.searching);
          this.searching = this._delay(function() {
            var equalValues = this.term === this._value(),
                menuVisible = this.menu.element.is(":visible"),
                modifierKey = event.altKey || event.ctrlKey || event.metaKey || event.shiftKey;
            if (!equalValues || (equalValues && !menuVisible && !modifierKey)) {
              this.selectedItem = null;
              this.search(null, event);
            }
          }, this.options.delay);
        },
        search: function(value, event) {
          value = value != null ? value : this._value();
          this.term = this._value();
          if (value.length < this.options.minLength) {
            return this.close(event);
          }
          if (this._trigger("search", event) === false) {
            return ;
          }
          return this._search(value);
        },
        _search: function(value) {
          this.pending++;
          this.element.addClass("ui-autocomplete-loading");
          this.cancelSearch = false;
          this.source({term: value}, this._response());
        },
        _response: function() {
          var index = ++this.requestIndex;
          return $.proxy(function(content) {
            if (index === this.requestIndex) {
              this.__response(content);
            }
            this.pending--;
            if (!this.pending) {
              this.element.removeClass("ui-autocomplete-loading");
            }
          }, this);
        },
        __response: function(content) {
          if (content) {
            content = this._normalize(content);
          }
          this._trigger("response", null, {content: content});
          if (!this.options.disabled && content && content.length && !this.cancelSearch) {
            this._suggest(content);
            this._trigger("open");
          } else {
            this._close();
          }
        },
        close: function(event) {
          this.cancelSearch = true;
          this._close(event);
        },
        _close: function(event) {
          if (this.menu.element.is(":visible")) {
            this.menu.element.hide();
            this.menu.blur();
            this.isNewMenu = true;
            this._trigger("close", event);
          }
        },
        _change: function(event) {
          if (this.previous !== this._value()) {
            this._trigger("change", event, {item: this.selectedItem});
          }
        },
        _normalize: function(items) {
          if (items.length && items[0].label && items[0].value) {
            return items;
          }
          return $.map(items, function(item) {
            if (typeof item === "string") {
              return {
                label: item,
                value: item
              };
            }
            return $.extend({}, item, {
              label: item.label || item.value,
              value: item.value || item.label
            });
          });
        },
        _suggest: function(items) {
          var ul = this.menu.element.empty();
          this._renderMenu(ul, items);
          this.isNewMenu = true;
          this.menu.refresh();
          ul.show();
          this._resizeMenu();
          ul.position($.extend({of: this.element}, this.options.position));
          if (this.options.autoFocus) {
            this.menu.next();
          }
        },
        _resizeMenu: function() {
          var ul = this.menu.element;
          ul.outerWidth(Math.max(ul.width("").outerWidth() + 1, this.element.outerWidth()));
        },
        _renderMenu: function(ul, items) {
          var that = this;
          $.each(items, function(index, item) {
            that._renderItemData(ul, item);
          });
        },
        _renderItemData: function(ul, item) {
          return this._renderItem(ul, item).data("ui-autocomplete-item", item);
        },
        _renderItem: function(ul, item) {
          return $("<li>").text(item.label).appendTo(ul);
        },
        _move: function(direction, event) {
          if (!this.menu.element.is(":visible")) {
            this.search(null, event);
            return ;
          }
          if (this.menu.isFirstItem() && /^previous/.test(direction) || this.menu.isLastItem() && /^next/.test(direction)) {
            if (!this.isMultiLine) {
              this._value(this.term);
            }
            this.menu.blur();
            return ;
          }
          this.menu[direction](event);
        },
        widget: function() {
          return this.menu.element;
        },
        _value: function() {
          return this.valueMethod.apply(this.element, arguments);
        },
        _keyEvent: function(keyEvent, event) {
          if (!this.isMultiLine || this.menu.element.is(":visible")) {
            this._move(keyEvent, event);
            event.preventDefault();
          }
        }
      });
      $.extend($.ui.autocomplete, {
        escapeRegex: function(value) {
          return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
        },
        filter: function(array, term) {
          var matcher = new RegExp($.ui.autocomplete.escapeRegex(term), "i");
          return $.grep(array, function(value) {
            return matcher.test(value.label || value.value || value);
          });
        }
      });
      $.widget("ui.autocomplete", $.ui.autocomplete, {
        options: {messages: {
            noResults: "No search results.",
            results: function(amount) {
              return amount + (amount > 1 ? " results are" : " result is") + " available, use up and down arrow keys to navigate.";
            }
          }},
        __response: function(content) {
          var message;
          this._superApply(arguments);
          if (this.options.disabled || this.cancelSearch) {
            return ;
          }
          if (content && content.length) {
            message = this.options.messages.results(content.length);
          } else {
            message = this.options.messages.noResults;
          }
          this.liveRegion.children().hide();
          $("<div>").text(message).appendTo(this.liveRegion);
        }
      });
      var autocomplete = $.ui.autocomplete;
      var lastActive,
          baseClasses = "ui-button ui-widget ui-state-default ui-corner-all",
          typeClasses = "ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only",
          formResetHandler = function() {
            var form = $(this);
            setTimeout(function() {
              form.find(":ui-button").button("refresh");
            }, 1);
          },
          radioGroup = function(radio) {
            var name = radio.name,
                form = radio.form,
                radios = $([]);
            if (name) {
              name = name.replace(/'/g, "\\'");
              if (form) {
                radios = $(form).find("[name='" + name + "'][type=radio]");
              } else {
                radios = $("[name='" + name + "'][type=radio]", radio.ownerDocument).filter(function() {
                  return !this.form;
                });
              }
            }
            return radios;
          };
      $.widget("ui.button", {
        version: "1.11.3",
        defaultElement: "<button>",
        options: {
          disabled: null,
          text: true,
          label: null,
          icons: {
            primary: null,
            secondary: null
          }
        },
        _create: function() {
          this.element.closest("form").unbind("reset" + this.eventNamespace).bind("reset" + this.eventNamespace, formResetHandler);
          if (typeof this.options.disabled !== "boolean") {
            this.options.disabled = !!this.element.prop("disabled");
          } else {
            this.element.prop("disabled", this.options.disabled);
          }
          this._determineButtonType();
          this.hasTitle = !!this.buttonElement.attr("title");
          var that = this,
              options = this.options,
              toggleButton = this.type === "checkbox" || this.type === "radio",
              activeClass = !toggleButton ? "ui-state-active" : "";
          if (options.label === null) {
            options.label = (this.type === "input" ? this.buttonElement.val() : this.buttonElement.html());
          }
          this._hoverable(this.buttonElement);
          this.buttonElement.addClass(baseClasses).attr("role", "button").bind("mouseenter" + this.eventNamespace, function() {
            if (options.disabled) {
              return ;
            }
            if (this === lastActive) {
              $(this).addClass("ui-state-active");
            }
          }).bind("mouseleave" + this.eventNamespace, function() {
            if (options.disabled) {
              return ;
            }
            $(this).removeClass(activeClass);
          }).bind("click" + this.eventNamespace, function(event) {
            if (options.disabled) {
              event.preventDefault();
              event.stopImmediatePropagation();
            }
          });
          this._on({
            focus: function() {
              this.buttonElement.addClass("ui-state-focus");
            },
            blur: function() {
              this.buttonElement.removeClass("ui-state-focus");
            }
          });
          if (toggleButton) {
            this.element.bind("change" + this.eventNamespace, function() {
              that.refresh();
            });
          }
          if (this.type === "checkbox") {
            this.buttonElement.bind("click" + this.eventNamespace, function() {
              if (options.disabled) {
                return false;
              }
            });
          } else if (this.type === "radio") {
            this.buttonElement.bind("click" + this.eventNamespace, function() {
              if (options.disabled) {
                return false;
              }
              $(this).addClass("ui-state-active");
              that.buttonElement.attr("aria-pressed", "true");
              var radio = that.element[0];
              radioGroup(radio).not(radio).map(function() {
                return $(this).button("widget")[0];
              }).removeClass("ui-state-active").attr("aria-pressed", "false");
            });
          } else {
            this.buttonElement.bind("mousedown" + this.eventNamespace, function() {
              if (options.disabled) {
                return false;
              }
              $(this).addClass("ui-state-active");
              lastActive = this;
              that.document.one("mouseup", function() {
                lastActive = null;
              });
            }).bind("mouseup" + this.eventNamespace, function() {
              if (options.disabled) {
                return false;
              }
              $(this).removeClass("ui-state-active");
            }).bind("keydown" + this.eventNamespace, function(event) {
              if (options.disabled) {
                return false;
              }
              if (event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER) {
                $(this).addClass("ui-state-active");
              }
            }).bind("keyup" + this.eventNamespace + " blur" + this.eventNamespace, function() {
              $(this).removeClass("ui-state-active");
            });
            if (this.buttonElement.is("a")) {
              this.buttonElement.keyup(function(event) {
                if (event.keyCode === $.ui.keyCode.SPACE) {
                  $(this).click();
                }
              });
            }
          }
          this._setOption("disabled", options.disabled);
          this._resetButton();
        },
        _determineButtonType: function() {
          var ancestor,
              labelSelector,
              checked;
          if (this.element.is("[type=checkbox]")) {
            this.type = "checkbox";
          } else if (this.element.is("[type=radio]")) {
            this.type = "radio";
          } else if (this.element.is("input")) {
            this.type = "input";
          } else {
            this.type = "button";
          }
          if (this.type === "checkbox" || this.type === "radio") {
            ancestor = this.element.parents().last();
            labelSelector = "label[for='" + this.element.attr("id") + "']";
            this.buttonElement = ancestor.find(labelSelector);
            if (!this.buttonElement.length) {
              ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();
              this.buttonElement = ancestor.filter(labelSelector);
              if (!this.buttonElement.length) {
                this.buttonElement = ancestor.find(labelSelector);
              }
            }
            this.element.addClass("ui-helper-hidden-accessible");
            checked = this.element.is(":checked");
            if (checked) {
              this.buttonElement.addClass("ui-state-active");
            }
            this.buttonElement.prop("aria-pressed", checked);
          } else {
            this.buttonElement = this.element;
          }
        },
        widget: function() {
          return this.buttonElement;
        },
        _destroy: function() {
          this.element.removeClass("ui-helper-hidden-accessible");
          this.buttonElement.removeClass(baseClasses + " ui-state-active " + typeClasses).removeAttr("role").removeAttr("aria-pressed").html(this.buttonElement.find(".ui-button-text").html());
          if (!this.hasTitle) {
            this.buttonElement.removeAttr("title");
          }
        },
        _setOption: function(key, value) {
          this._super(key, value);
          if (key === "disabled") {
            this.widget().toggleClass("ui-state-disabled", !!value);
            this.element.prop("disabled", !!value);
            if (value) {
              if (this.type === "checkbox" || this.type === "radio") {
                this.buttonElement.removeClass("ui-state-focus");
              } else {
                this.buttonElement.removeClass("ui-state-focus ui-state-active");
              }
            }
            return ;
          }
          this._resetButton();
        },
        refresh: function() {
          var isDisabled = this.element.is("input, button") ? this.element.is(":disabled") : this.element.hasClass("ui-button-disabled");
          if (isDisabled !== this.options.disabled) {
            this._setOption("disabled", isDisabled);
          }
          if (this.type === "radio") {
            radioGroup(this.element[0]).each(function() {
              if ($(this).is(":checked")) {
                $(this).button("widget").addClass("ui-state-active").attr("aria-pressed", "true");
              } else {
                $(this).button("widget").removeClass("ui-state-active").attr("aria-pressed", "false");
              }
            });
          } else if (this.type === "checkbox") {
            if (this.element.is(":checked")) {
              this.buttonElement.addClass("ui-state-active").attr("aria-pressed", "true");
            } else {
              this.buttonElement.removeClass("ui-state-active").attr("aria-pressed", "false");
            }
          }
        },
        _resetButton: function() {
          if (this.type === "input") {
            if (this.options.label) {
              this.element.val(this.options.label);
            }
            return ;
          }
          var buttonElement = this.buttonElement.removeClass(typeClasses),
              buttonText = $("<span></span>", this.document[0]).addClass("ui-button-text").html(this.options.label).appendTo(buttonElement.empty()).text(),
              icons = this.options.icons,
              multipleIcons = icons.primary && icons.secondary,
              buttonClasses = [];
          if (icons.primary || icons.secondary) {
            if (this.options.text) {
              buttonClasses.push("ui-button-text-icon" + (multipleIcons ? "s" : (icons.primary ? "-primary" : "-secondary")));
            }
            if (icons.primary) {
              buttonElement.prepend("<span class='ui-button-icon-primary ui-icon " + icons.primary + "'></span>");
            }
            if (icons.secondary) {
              buttonElement.append("<span class='ui-button-icon-secondary ui-icon " + icons.secondary + "'></span>");
            }
            if (!this.options.text) {
              buttonClasses.push(multipleIcons ? "ui-button-icons-only" : "ui-button-icon-only");
              if (!this.hasTitle) {
                buttonElement.attr("title", $.trim(buttonText));
              }
            }
          } else {
            buttonClasses.push("ui-button-text-only");
          }
          buttonElement.addClass(buttonClasses.join(" "));
        }
      });
      $.widget("ui.buttonset", {
        version: "1.11.3",
        options: {items: "button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(ui-button)"},
        _create: function() {
          this.element.addClass("ui-buttonset");
        },
        _init: function() {
          this.refresh();
        },
        _setOption: function(key, value) {
          if (key === "disabled") {
            this.buttons.button("option", key, value);
          }
          this._super(key, value);
        },
        refresh: function() {
          var rtl = this.element.css("direction") === "rtl",
              allButtons = this.element.find(this.options.items),
              existingButtons = allButtons.filter(":ui-button");
          allButtons.not(":ui-button").button();
          existingButtons.button("refresh");
          this.buttons = allButtons.map(function() {
            return $(this).button("widget")[0];
          }).removeClass("ui-corner-all ui-corner-left ui-corner-right").filter(":first").addClass(rtl ? "ui-corner-right" : "ui-corner-left").end().filter(":last").addClass(rtl ? "ui-corner-left" : "ui-corner-right").end().end();
        },
        _destroy: function() {
          this.element.removeClass("ui-buttonset");
          this.buttons.map(function() {
            return $(this).button("widget")[0];
          }).removeClass("ui-corner-left ui-corner-right").end().button("destroy");
        }
      });
      var button = $.ui.button;
      $.extend($.ui, {datepicker: {version: "1.11.3"}});
      var datepicker_instActive;
      function datepicker_getZindex(elem) {
        var position,
            value;
        while (elem.length && elem[0] !== document) {
          position = elem.css("position");
          if (position === "absolute" || position === "relative" || position === "fixed") {
            value = parseInt(elem.css("zIndex"), 10);
            if (!isNaN(value) && value !== 0) {
              return value;
            }
          }
          elem = elem.parent();
        }
        return 0;
      }
      function Datepicker() {
        this._curInst = null;
        this._keyEvent = false;
        this._disabledInputs = [];
        this._datepickerShowing = false;
        this._inDialog = false;
        this._mainDivId = "ui-datepicker-div";
        this._inlineClass = "ui-datepicker-inline";
        this._appendClass = "ui-datepicker-append";
        this._triggerClass = "ui-datepicker-trigger";
        this._dialogClass = "ui-datepicker-dialog";
        this._disableClass = "ui-datepicker-disabled";
        this._unselectableClass = "ui-datepicker-unselectable";
        this._currentClass = "ui-datepicker-current-day";
        this._dayOverClass = "ui-datepicker-days-cell-over";
        this.regional = [];
        this.regional[""] = {
          closeText: "Done",
          prevText: "Prev",
          nextText: "Next",
          currentText: "Today",
          monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
          monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
          dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
          dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
          dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
          weekHeader: "Wk",
          dateFormat: "mm/dd/yy",
          firstDay: 0,
          isRTL: false,
          showMonthAfterYear: false,
          yearSuffix: ""
        };
        this._defaults = {
          showOn: "focus",
          showAnim: "fadeIn",
          showOptions: {},
          defaultDate: null,
          appendText: "",
          buttonText: "...",
          buttonImage: "",
          buttonImageOnly: false,
          hideIfNoPrevNext: false,
          navigationAsDateFormat: false,
          gotoCurrent: false,
          changeMonth: false,
          changeYear: false,
          yearRange: "c-10:c+10",
          showOtherMonths: false,
          selectOtherMonths: false,
          showWeek: false,
          calculateWeek: this.iso8601Week,
          shortYearCutoff: "+10",
          minDate: null,
          maxDate: null,
          duration: "fast",
          beforeShowDay: null,
          beforeShow: null,
          onSelect: null,
          onChangeMonthYear: null,
          onClose: null,
          numberOfMonths: 1,
          showCurrentAtPos: 0,
          stepMonths: 1,
          stepBigMonths: 12,
          altField: "",
          altFormat: "",
          constrainInput: true,
          showButtonPanel: false,
          autoSize: false,
          disabled: false
        };
        $.extend(this._defaults, this.regional[""]);
        this.regional.en = $.extend(true, {}, this.regional[""]);
        this.regional["en-US"] = $.extend(true, {}, this.regional.en);
        this.dpDiv = datepicker_bindHover($("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"));
      }
      $.extend(Datepicker.prototype, {
        markerClassName: "hasDatepicker",
        maxRows: 4,
        _widgetDatepicker: function() {
          return this.dpDiv;
        },
        setDefaults: function(settings) {
          datepicker_extendRemove(this._defaults, settings || {});
          return this;
        },
        _attachDatepicker: function(target, settings) {
          var nodeName,
              inline,
              inst;
          nodeName = target.nodeName.toLowerCase();
          inline = (nodeName === "div" || nodeName === "span");
          if (!target.id) {
            this.uuid += 1;
            target.id = "dp" + this.uuid;
          }
          inst = this._newInst($(target), inline);
          inst.settings = $.extend({}, settings || {});
          if (nodeName === "input") {
            this._connectDatepicker(target, inst);
          } else if (inline) {
            this._inlineDatepicker(target, inst);
          }
        },
        _newInst: function(target, inline) {
          var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1");
          return {
            id: id,
            input: target,
            selectedDay: 0,
            selectedMonth: 0,
            selectedYear: 0,
            drawMonth: 0,
            drawYear: 0,
            inline: inline,
            dpDiv: (!inline ? this.dpDiv : datepicker_bindHover($("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")))
          };
        },
        _connectDatepicker: function(target, inst) {
          var input = $(target);
          inst.append = $([]);
          inst.trigger = $([]);
          if (input.hasClass(this.markerClassName)) {
            return ;
          }
          this._attachments(input, inst);
          input.addClass(this.markerClassName).keydown(this._doKeyDown).keypress(this._doKeyPress).keyup(this._doKeyUp);
          this._autoSize(inst);
          $.data(target, "datepicker", inst);
          if (inst.settings.disabled) {
            this._disableDatepicker(target);
          }
        },
        _attachments: function(input, inst) {
          var showOn,
              buttonText,
              buttonImage,
              appendText = this._get(inst, "appendText"),
              isRTL = this._get(inst, "isRTL");
          if (inst.append) {
            inst.append.remove();
          }
          if (appendText) {
            inst.append = $("<span class='" + this._appendClass + "'>" + appendText + "</span>");
            input[isRTL ? "before" : "after"](inst.append);
          }
          input.unbind("focus", this._showDatepicker);
          if (inst.trigger) {
            inst.trigger.remove();
          }
          showOn = this._get(inst, "showOn");
          if (showOn === "focus" || showOn === "both") {
            input.focus(this._showDatepicker);
          }
          if (showOn === "button" || showOn === "both") {
            buttonText = this._get(inst, "buttonText");
            buttonImage = this._get(inst, "buttonImage");
            inst.trigger = $(this._get(inst, "buttonImageOnly") ? $("<img/>").addClass(this._triggerClass).attr({
              src: buttonImage,
              alt: buttonText,
              title: buttonText
            }) : $("<button type='button'></button>").addClass(this._triggerClass).html(!buttonImage ? buttonText : $("<img/>").attr({
              src: buttonImage,
              alt: buttonText,
              title: buttonText
            })));
            input[isRTL ? "before" : "after"](inst.trigger);
            inst.trigger.click(function() {
              if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {
                $.datepicker._hideDatepicker();
              } else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {
                $.datepicker._hideDatepicker();
                $.datepicker._showDatepicker(input[0]);
              } else {
                $.datepicker._showDatepicker(input[0]);
              }
              return false;
            });
          }
        },
        _autoSize: function(inst) {
          if (this._get(inst, "autoSize") && !inst.inline) {
            var findMax,
                max,
                maxI,
                i,
                date = new Date(2009, 12 - 1, 20),
                dateFormat = this._get(inst, "dateFormat");
            if (dateFormat.match(/[DM]/)) {
              findMax = function(names) {
                max = 0;
                maxI = 0;
                for (i = 0; i < names.length; i++) {
                  if (names[i].length > max) {
                    max = names[i].length;
                    maxI = i;
                  }
                }
                return maxI;
              };
              date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ? "monthNames" : "monthNamesShort"))));
              date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ? "dayNames" : "dayNamesShort"))) + 20 - date.getDay());
            }
            inst.input.attr("size", this._formatDate(inst, date).length);
          }
        },
        _inlineDatepicker: function(target, inst) {
          var divSpan = $(target);
          if (divSpan.hasClass(this.markerClassName)) {
            return ;
          }
          divSpan.addClass(this.markerClassName).append(inst.dpDiv);
          $.data(target, "datepicker", inst);
          this._setDate(inst, this._getDefaultDate(inst), true);
          this._updateDatepicker(inst);
          this._updateAlternate(inst);
          if (inst.settings.disabled) {
            this._disableDatepicker(target);
          }
          inst.dpDiv.css("display", "block");
        },
        _dialogDatepicker: function(input, date, onSelect, settings, pos) {
          var id,
              browserWidth,
              browserHeight,
              scrollX,
              scrollY,
              inst = this._dialogInst;
          if (!inst) {
            this.uuid += 1;
            id = "dp" + this.uuid;
            this._dialogInput = $("<input type='text' id='" + id + "' style='position: absolute; top: -100px; width: 0px;'/>");
            this._dialogInput.keydown(this._doKeyDown);
            $("body").append(this._dialogInput);
            inst = this._dialogInst = this._newInst(this._dialogInput, false);
            inst.settings = {};
            $.data(this._dialogInput[0], "datepicker", inst);
          }
          datepicker_extendRemove(inst.settings, settings || {});
          date = (date && date.constructor === Date ? this._formatDate(inst, date) : date);
          this._dialogInput.val(date);
          this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);
          if (!this._pos) {
            browserWidth = document.documentElement.clientWidth;
            browserHeight = document.documentElement.clientHeight;
            scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
            scrollY = document.documentElement.scrollTop || document.body.scrollTop;
            this._pos = [(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];
          }
          this._dialogInput.css("left", (this._pos[0] + 20) + "px").css("top", this._pos[1] + "px");
          inst.settings.onSelect = onSelect;
          this._inDialog = true;
          this.dpDiv.addClass(this._dialogClass);
          this._showDatepicker(this._dialogInput[0]);
          if ($.blockUI) {
            $.blockUI(this.dpDiv);
          }
          $.data(this._dialogInput[0], "datepicker", inst);
          return this;
        },
        _destroyDatepicker: function(target) {
          var nodeName,
              $target = $(target),
              inst = $.data(target, "datepicker");
          if (!$target.hasClass(this.markerClassName)) {
            return ;
          }
          nodeName = target.nodeName.toLowerCase();
          $.removeData(target, "datepicker");
          if (nodeName === "input") {
            inst.append.remove();
            inst.trigger.remove();
            $target.removeClass(this.markerClassName).unbind("focus", this._showDatepicker).unbind("keydown", this._doKeyDown).unbind("keypress", this._doKeyPress).unbind("keyup", this._doKeyUp);
          } else if (nodeName === "div" || nodeName === "span") {
            $target.removeClass(this.markerClassName).empty();
          }
          if (datepicker_instActive === inst) {
            datepicker_instActive = null;
          }
        },
        _enableDatepicker: function(target) {
          var nodeName,
              inline,
              $target = $(target),
              inst = $.data(target, "datepicker");
          if (!$target.hasClass(this.markerClassName)) {
            return ;
          }
          nodeName = target.nodeName.toLowerCase();
          if (nodeName === "input") {
            target.disabled = false;
            inst.trigger.filter("button").each(function() {
              this.disabled = false;
            }).end().filter("img").css({
              opacity: "1.0",
              cursor: ""
            });
          } else if (nodeName === "div" || nodeName === "span") {
            inline = $target.children("." + this._inlineClass);
            inline.children().removeClass("ui-state-disabled");
            inline.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", false);
          }
          this._disabledInputs = $.map(this._disabledInputs, function(value) {
            return (value === target ? null : value);
          });
        },
        _disableDatepicker: function(target) {
          var nodeName,
              inline,
              $target = $(target),
              inst = $.data(target, "datepicker");
          if (!$target.hasClass(this.markerClassName)) {
            return ;
          }
          nodeName = target.nodeName.toLowerCase();
          if (nodeName === "input") {
            target.disabled = true;
            inst.trigger.filter("button").each(function() {
              this.disabled = true;
            }).end().filter("img").css({
              opacity: "0.5",
              cursor: "default"
            });
          } else if (nodeName === "div" || nodeName === "span") {
            inline = $target.children("." + this._inlineClass);
            inline.children().addClass("ui-state-disabled");
            inline.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", true);
          }
          this._disabledInputs = $.map(this._disabledInputs, function(value) {
            return (value === target ? null : value);
          });
          this._disabledInputs[this._disabledInputs.length] = target;
        },
        _isDisabledDatepicker: function(target) {
          if (!target) {
            return false;
          }
          for (var i = 0; i < this._disabledInputs.length; i++) {
            if (this._disabledInputs[i] === target) {
              return true;
            }
          }
          return false;
        },
        _getInst: function(target) {
          try {
            return $.data(target, "datepicker");
          } catch (err) {
            throw "Missing instance data for this datepicker";
          }
        },
        _optionDatepicker: function(target, name, value) {
          var settings,
              date,
              minDate,
              maxDate,
              inst = this._getInst(target);
          if (arguments.length === 2 && typeof name === "string") {
            return (name === "defaults" ? $.extend({}, $.datepicker._defaults) : (inst ? (name === "all" ? $.extend({}, inst.settings) : this._get(inst, name)) : null));
          }
          settings = name || {};
          if (typeof name === "string") {
            settings = {};
            settings[name] = value;
          }
          if (inst) {
            if (this._curInst === inst) {
              this._hideDatepicker();
            }
            date = this._getDateDatepicker(target, true);
            minDate = this._getMinMaxDate(inst, "min");
            maxDate = this._getMinMaxDate(inst, "max");
            datepicker_extendRemove(inst.settings, settings);
            if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {
              inst.settings.minDate = this._formatDate(inst, minDate);
            }
            if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {
              inst.settings.maxDate = this._formatDate(inst, maxDate);
            }
            if ("disabled" in settings) {
              if (settings.disabled) {
                this._disableDatepicker(target);
              } else {
                this._enableDatepicker(target);
              }
            }
            this._attachments($(target), inst);
            this._autoSize(inst);
            this._setDate(inst, date);
            this._updateAlternate(inst);
            this._updateDatepicker(inst);
          }
        },
        _changeDatepicker: function(target, name, value) {
          this._optionDatepicker(target, name, value);
        },
        _refreshDatepicker: function(target) {
          var inst = this._getInst(target);
          if (inst) {
            this._updateDatepicker(inst);
          }
        },
        _setDateDatepicker: function(target, date) {
          var inst = this._getInst(target);
          if (inst) {
            this._setDate(inst, date);
            this._updateDatepicker(inst);
            this._updateAlternate(inst);
          }
        },
        _getDateDatepicker: function(target, noDefault) {
          var inst = this._getInst(target);
          if (inst && !inst.inline) {
            this._setDateFromField(inst, noDefault);
          }
          return (inst ? this._getDate(inst) : null);
        },
        _doKeyDown: function(event) {
          var onSelect,
              dateStr,
              sel,
              inst = $.datepicker._getInst(event.target),
              handled = true,
              isRTL = inst.dpDiv.is(".ui-datepicker-rtl");
          inst._keyEvent = true;
          if ($.datepicker._datepickerShowing) {
            switch (event.keyCode) {
              case 9:
                $.datepicker._hideDatepicker();
                handled = false;
                break;
              case 13:
                sel = $("td." + $.datepicker._dayOverClass + ":not(." + $.datepicker._currentClass + ")", inst.dpDiv);
                if (sel[0]) {
                  $.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
                }
                onSelect = $.datepicker._get(inst, "onSelect");
                if (onSelect) {
                  dateStr = $.datepicker._formatDate(inst);
                  onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);
                } else {
                  $.datepicker._hideDatepicker();
                }
                return false;
              case 27:
                $.datepicker._hideDatepicker();
                break;
              case 33:
                $.datepicker._adjustDate(event.target, (event.ctrlKey ? -$.datepicker._get(inst, "stepBigMonths") : -$.datepicker._get(inst, "stepMonths")), "M");
                break;
              case 34:
                $.datepicker._adjustDate(event.target, (event.ctrlKey ? +$.datepicker._get(inst, "stepBigMonths") : +$.datepicker._get(inst, "stepMonths")), "M");
                break;
              case 35:
                if (event.ctrlKey || event.metaKey) {
                  $.datepicker._clearDate(event.target);
                }
                handled = event.ctrlKey || event.metaKey;
                break;
              case 36:
                if (event.ctrlKey || event.metaKey) {
                  $.datepicker._gotoToday(event.target);
                }
                handled = event.ctrlKey || event.metaKey;
                break;
              case 37:
                if (event.ctrlKey || event.metaKey) {
                  $.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), "D");
                }
                handled = event.ctrlKey || event.metaKey;
                if (event.originalEvent.altKey) {
                  $.datepicker._adjustDate(event.target, (event.ctrlKey ? -$.datepicker._get(inst, "stepBigMonths") : -$.datepicker._get(inst, "stepMonths")), "M");
                }
                break;
              case 38:
                if (event.ctrlKey || event.metaKey) {
                  $.datepicker._adjustDate(event.target, -7, "D");
                }
                handled = event.ctrlKey || event.metaKey;
                break;
              case 39:
                if (event.ctrlKey || event.metaKey) {
                  $.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), "D");
                }
                handled = event.ctrlKey || event.metaKey;
                if (event.originalEvent.altKey) {
                  $.datepicker._adjustDate(event.target, (event.ctrlKey ? +$.datepicker._get(inst, "stepBigMonths") : +$.datepicker._get(inst, "stepMonths")), "M");
                }
                break;
              case 40:
                if (event.ctrlKey || event.metaKey) {
                  $.datepicker._adjustDate(event.target, +7, "D");
                }
                handled = event.ctrlKey || event.metaKey;
                break;
              default:
                handled = false;
            }
          } else if (event.keyCode === 36 && event.ctrlKey) {
            $.datepicker._showDatepicker(this);
          } else {
            handled = false;
          }
          if (handled) {
            event.preventDefault();
            event.stopPropagation();
          }
        },
        _doKeyPress: function(event) {
          var chars,
              chr,
              inst = $.datepicker._getInst(event.target);
          if ($.datepicker._get(inst, "constrainInput")) {
            chars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat"));
            chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
            return event.ctrlKey || event.metaKey || (chr < " " || !chars || chars.indexOf(chr) > -1);
          }
        },
        _doKeyUp: function(event) {
          var date,
              inst = $.datepicker._getInst(event.target);
          if (inst.input.val() !== inst.lastVal) {
            try {
              date = $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"), (inst.input ? inst.input.val() : null), $.datepicker._getFormatConfig(inst));
              if (date) {
                $.datepicker._setDateFromField(inst);
                $.datepicker._updateAlternate(inst);
                $.datepicker._updateDatepicker(inst);
              }
            } catch (err) {}
          }
          return true;
        },
        _showDatepicker: function(input) {
          input = input.target || input;
          if (input.nodeName.toLowerCase() !== "input") {
            input = $("input", input.parentNode)[0];
          }
          if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) {
            return ;
          }
          var inst,
              beforeShow,
              beforeShowSettings,
              isFixed,
              offset,
              showAnim,
              duration;
          inst = $.datepicker._getInst(input);
          if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
            $.datepicker._curInst.dpDiv.stop(true, true);
            if (inst && $.datepicker._datepickerShowing) {
              $.datepicker._hideDatepicker($.datepicker._curInst.input[0]);
            }
          }
          beforeShow = $.datepicker._get(inst, "beforeShow");
          beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};
          if (beforeShowSettings === false) {
            return ;
          }
          datepicker_extendRemove(inst.settings, beforeShowSettings);
          inst.lastVal = null;
          $.datepicker._lastInput = input;
          $.datepicker._setDateFromField(inst);
          if ($.datepicker._inDialog) {
            input.value = "";
          }
          if (!$.datepicker._pos) {
            $.datepicker._pos = $.datepicker._findPos(input);
            $.datepicker._pos[1] += input.offsetHeight;
          }
          isFixed = false;
          $(input).parents().each(function() {
            isFixed |= $(this).css("position") === "fixed";
            return !isFixed;
          });
          offset = {
            left: $.datepicker._pos[0],
            top: $.datepicker._pos[1]
          };
          $.datepicker._pos = null;
          inst.dpDiv.empty();
          inst.dpDiv.css({
            position: "absolute",
            display: "block",
            top: "-1000px"
          });
          $.datepicker._updateDatepicker(inst);
          offset = $.datepicker._checkOffset(inst, offset, isFixed);
          inst.dpDiv.css({
            position: ($.datepicker._inDialog && $.blockUI ? "static" : (isFixed ? "fixed" : "absolute")),
            display: "none",
            left: offset.left + "px",
            top: offset.top + "px"
          });
          if (!inst.inline) {
            showAnim = $.datepicker._get(inst, "showAnim");
            duration = $.datepicker._get(inst, "duration");
            inst.dpDiv.css("z-index", datepicker_getZindex($(input)) + 1);
            $.datepicker._datepickerShowing = true;
            if ($.effects && $.effects.effect[showAnim]) {
              inst.dpDiv.show(showAnim, $.datepicker._get(inst, "showOptions"), duration);
            } else {
              inst.dpDiv[showAnim || "show"](showAnim ? duration : null);
            }
            if ($.datepicker._shouldFocusInput(inst)) {
              inst.input.focus();
            }
            $.datepicker._curInst = inst;
          }
        },
        _updateDatepicker: function(inst) {
          this.maxRows = 4;
          datepicker_instActive = inst;
          inst.dpDiv.empty().append(this._generateHTML(inst));
          this._attachHandlers(inst);
          var origyearshtml,
              numMonths = this._getNumberOfMonths(inst),
              cols = numMonths[1],
              width = 17,
              activeCell = inst.dpDiv.find("." + this._dayOverClass + " a");
          if (activeCell.length > 0) {
            datepicker_handleMouseover.apply(activeCell.get(0));
          }
          inst.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width("");
          if (cols > 1) {
            inst.dpDiv.addClass("ui-datepicker-multi-" + cols).css("width", (width * cols) + "em");
          }
          inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? "add" : "remove") + "Class"]("ui-datepicker-multi");
          inst.dpDiv[(this._get(inst, "isRTL") ? "add" : "remove") + "Class"]("ui-datepicker-rtl");
          if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput(inst)) {
            inst.input.focus();
          }
          if (inst.yearshtml) {
            origyearshtml = inst.yearshtml;
            setTimeout(function() {
              if (origyearshtml === inst.yearshtml && inst.yearshtml) {
                inst.dpDiv.find("select.ui-datepicker-year:first").replaceWith(inst.yearshtml);
              }
              origyearshtml = inst.yearshtml = null;
            }, 0);
          }
        },
        _shouldFocusInput: function(inst) {
          return inst.input && inst.input.is(":visible") && !inst.input.is(":disabled") && !inst.input.is(":focus");
        },
        _checkOffset: function(inst, offset, isFixed) {
          var dpWidth = inst.dpDiv.outerWidth(),
              dpHeight = inst.dpDiv.outerHeight(),
              inputWidth = inst.input ? inst.input.outerWidth() : 0,
              inputHeight = inst.input ? inst.input.outerHeight() : 0,
              viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()),
              viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());
          offset.left -= (this._get(inst, "isRTL") ? (dpWidth - inputWidth) : 0);
          offset.left -= (isFixed && offset.left === inst.input.offset().left) ? $(document).scrollLeft() : 0;
          offset.top -= (isFixed && offset.top === (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;
          offset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ? Math.abs(offset.left + dpWidth - viewWidth) : 0);
          offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ? Math.abs(dpHeight + inputHeight) : 0);
          return offset;
        },
        _findPos: function(obj) {
          var position,
              inst = this._getInst(obj),
              isRTL = this._get(inst, "isRTL");
          while (obj && (obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {
            obj = obj[isRTL ? "previousSibling" : "nextSibling"];
          }
          position = $(obj).offset();
          return [position.left, position.top];
        },
        _hideDatepicker: function(input) {
          var showAnim,
              duration,
              postProcess,
              onClose,
              inst = this._curInst;
          if (!inst || (input && inst !== $.data(input, "datepicker"))) {
            return ;
          }
          if (this._datepickerShowing) {
            showAnim = this._get(inst, "showAnim");
            duration = this._get(inst, "duration");
            postProcess = function() {
              $.datepicker._tidyDialog(inst);
            };
            if ($.effects && ($.effects.effect[showAnim] || $.effects[showAnim])) {
              inst.dpDiv.hide(showAnim, $.datepicker._get(inst, "showOptions"), duration, postProcess);
            } else {
              inst.dpDiv[(showAnim === "slideDown" ? "slideUp" : (showAnim === "fadeIn" ? "fadeOut" : "hide"))]((showAnim ? duration : null), postProcess);
            }
            if (!showAnim) {
              postProcess();
            }
            this._datepickerShowing = false;
            onClose = this._get(inst, "onClose");
            if (onClose) {
              onClose.apply((inst.input ? inst.input[0] : null), [(inst.input ? inst.input.val() : ""), inst]);
            }
            this._lastInput = null;
            if (this._inDialog) {
              this._dialogInput.css({
                position: "absolute",
                left: "0",
                top: "-100px"
              });
              if ($.blockUI) {
                $.unblockUI();
                $("body").append(this.dpDiv);
              }
            }
            this._inDialog = false;
          }
        },
        _tidyDialog: function(inst) {
          inst.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar");
        },
        _checkExternalClick: function(event) {
          if (!$.datepicker._curInst) {
            return ;
          }
          var $target = $(event.target),
              inst = $.datepicker._getInst($target[0]);
          if ((($target[0].id !== $.datepicker._mainDivId && $target.parents("#" + $.datepicker._mainDivId).length === 0 && !$target.hasClass($.datepicker.markerClassName) && !$target.closest("." + $.datepicker._triggerClass).length && $.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI))) || ($target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst)) {
            $.datepicker._hideDatepicker();
          }
        },
        _adjustDate: function(id, offset, period) {
          var target = $(id),
              inst = this._getInst(target[0]);
          if (this._isDisabledDatepicker(target[0])) {
            return ;
          }
          this._adjustInstDate(inst, offset + (period === "M" ? this._get(inst, "showCurrentAtPos") : 0), period);
          this._updateDatepicker(inst);
        },
        _gotoToday: function(id) {
          var date,
              target = $(id),
              inst = this._getInst(target[0]);
          if (this._get(inst, "gotoCurrent") && inst.currentDay) {
            inst.selectedDay = inst.currentDay;
            inst.drawMonth = inst.selectedMonth = inst.currentMonth;
            inst.drawYear = inst.selectedYear = inst.currentYear;
          } else {
            date = new Date();
            inst.selectedDay = date.getDate();
            inst.drawMonth = inst.selectedMonth = date.getMonth();
            inst.drawYear = inst.selectedYear = date.getFullYear();
          }
          this._notifyChange(inst);
          this._adjustDate(target);
        },
        _selectMonthYear: function(id, select, period) {
          var target = $(id),
              inst = this._getInst(target[0]);
          inst["selected" + (period === "M" ? "Month" : "Year")] = inst["draw" + (period === "M" ? "Month" : "Year")] = parseInt(select.options[select.selectedIndex].value, 10);
          this._notifyChange(inst);
          this._adjustDate(target);
        },
        _selectDay: function(id, month, year, td) {
          var inst,
              target = $(id);
          if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
            return ;
          }
          inst = this._getInst(target[0]);
          inst.selectedDay = inst.currentDay = $("a", td).html();
          inst.selectedMonth = inst.currentMonth = month;
          inst.selectedYear = inst.currentYear = year;
          this._selectDate(id, this._formatDate(inst, inst.currentDay, inst.currentMonth, inst.currentYear));
        },
        _clearDate: function(id) {
          var target = $(id);
          this._selectDate(target, "");
        },
        _selectDate: function(id, dateStr) {
          var onSelect,
              target = $(id),
              inst = this._getInst(target[0]);
          dateStr = (dateStr != null ? dateStr : this._formatDate(inst));
          if (inst.input) {
            inst.input.val(dateStr);
          }
          this._updateAlternate(inst);
          onSelect = this._get(inst, "onSelect");
          if (onSelect) {
            onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);
          } else if (inst.input) {
            inst.input.trigger("change");
          }
          if (inst.inline) {
            this._updateDatepicker(inst);
          } else {
            this._hideDatepicker();
            this._lastInput = inst.input[0];
            if (typeof(inst.input[0]) !== "object") {
              inst.input.focus();
            }
            this._lastInput = null;
          }
        },
        _updateAlternate: function(inst) {
          var altFormat,
              date,
              dateStr,
              altField = this._get(inst, "altField");
          if (altField) {
            altFormat = this._get(inst, "altFormat") || this._get(inst, "dateFormat");
            date = this._getDate(inst);
            dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
            $(altField).each(function() {
              $(this).val(dateStr);
            });
          }
        },
        noWeekends: function(date) {
          var day = date.getDay();
          return [(day > 0 && day < 6), ""];
        },
        iso8601Week: function(date) {
          var time,
              checkDate = new Date(date.getTime());
          checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
          time = checkDate.getTime();
          checkDate.setMonth(0);
          checkDate.setDate(1);
          return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
        },
        parseDate: function(format, value, settings) {
          if (format == null || value == null) {
            throw "Invalid arguments";
          }
          value = (typeof value === "object" ? value.toString() : value + "");
          if (value === "") {
            return null;
          }
          var iFormat,
              dim,
              extra,
              iValue = 0,
              shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff,
              shortYearCutoff = (typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp : new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10)),
              dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
              dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
              monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
              monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
              year = -1,
              month = -1,
              day = -1,
              doy = -1,
              literal = false,
              date,
              lookAhead = function(match) {
                var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
                if (matches) {
                  iFormat++;
                }
                return matches;
              },
              getNumber = function(match) {
                var isDoubled = lookAhead(match),
                    size = (match === "@" ? 14 : (match === "!" ? 20 : (match === "y" && isDoubled ? 4 : (match === "o" ? 3 : 2)))),
                    minSize = (match === "y" ? size : 1),
                    digits = new RegExp("^\\d{" + minSize + "," + size + "}"),
                    num = value.substring(iValue).match(digits);
                if (!num) {
                  throw "Missing number at position " + iValue;
                }
                iValue += num[0].length;
                return parseInt(num[0], 10);
              },
              getName = function(match, shortNames, longNames) {
                var index = -1,
                    names = $.map(lookAhead(match) ? longNames : shortNames, function(v, k) {
                      return [[k, v]];
                    }).sort(function(a, b) {
                      return -(a[1].length - b[1].length);
                    });
                $.each(names, function(i, pair) {
                  var name = pair[1];
                  if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
                    index = pair[0];
                    iValue += name.length;
                    return false;
                  }
                });
                if (index !== -1) {
                  return index + 1;
                } else {
                  throw "Unknown name at position " + iValue;
                }
              },
              checkLiteral = function() {
                if (value.charAt(iValue) !== format.charAt(iFormat)) {
                  throw "Unexpected literal at position " + iValue;
                }
                iValue++;
              };
          for (iFormat = 0; iFormat < format.length; iFormat++) {
            if (literal) {
              if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                literal = false;
              } else {
                checkLiteral();
              }
            } else {
              switch (format.charAt(iFormat)) {
                case "d":
                  day = getNumber("d");
                  break;
                case "D":
                  getName("D", dayNamesShort, dayNames);
                  break;
                case "o":
                  doy = getNumber("o");
                  break;
                case "m":
                  month = getNumber("m");
                  break;
                case "M":
                  month = getName("M", monthNamesShort, monthNames);
                  break;
                case "y":
                  year = getNumber("y");
                  break;
                case "@":
                  date = new Date(getNumber("@"));
                  year = date.getFullYear();
                  month = date.getMonth() + 1;
                  day = date.getDate();
                  break;
                case "!":
                  date = new Date((getNumber("!") - this._ticksTo1970) / 10000);
                  year = date.getFullYear();
                  month = date.getMonth() + 1;
                  day = date.getDate();
                  break;
                case "'":
                  if (lookAhead("'")) {
                    checkLiteral();
                  } else {
                    literal = true;
                  }
                  break;
                default:
                  checkLiteral();
              }
            }
          }
          if (iValue < value.length) {
            extra = value.substr(iValue);
            if (!/^\s+/.test(extra)) {
              throw "Extra/unparsed characters found in date: " + extra;
            }
          }
          if (year === -1) {
            year = new Date().getFullYear();
          } else if (year < 100) {
            year += new Date().getFullYear() - new Date().getFullYear() % 100 + (year <= shortYearCutoff ? 0 : -100);
          }
          if (doy > -1) {
            month = 1;
            day = doy;
            do {
              dim = this._getDaysInMonth(year, month - 1);
              if (day <= dim) {
                break;
              }
              month++;
              day -= dim;
            } while (true);
          }
          date = this._daylightSavingAdjust(new Date(year, month - 1, day));
          if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
            throw "Invalid date";
          }
          return date;
        },
        ATOM: "yy-mm-dd",
        COOKIE: "D, dd M yy",
        ISO_8601: "yy-mm-dd",
        RFC_822: "D, d M y",
        RFC_850: "DD, dd-M-y",
        RFC_1036: "D, d M y",
        RFC_1123: "D, d M yy",
        RFC_2822: "D, d M yy",
        RSS: "D, d M y",
        TICKS: "!",
        TIMESTAMP: "@",
        W3C: "yy-mm-dd",
        _ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) + Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),
        formatDate: function(format, date, settings) {
          if (!date) {
            return "";
          }
          var iFormat,
              dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
              dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
              monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
              monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
              lookAhead = function(match) {
                var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
                if (matches) {
                  iFormat++;
                }
                return matches;
              },
              formatNumber = function(match, value, len) {
                var num = "" + value;
                if (lookAhead(match)) {
                  while (num.length < len) {
                    num = "0" + num;
                  }
                }
                return num;
              },
              formatName = function(match, value, shortNames, longNames) {
                return (lookAhead(match) ? longNames[value] : shortNames[value]);
              },
              output = "",
              literal = false;
          if (date) {
            for (iFormat = 0; iFormat < format.length; iFormat++) {
              if (literal) {
                if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                  literal = false;
                } else {
                  output += format.charAt(iFormat);
                }
              } else {
                switch (format.charAt(iFormat)) {
                  case "d":
                    output += formatNumber("d", date.getDate(), 2);
                    break;
                  case "D":
                    output += formatName("D", date.getDay(), dayNamesShort, dayNames);
                    break;
                  case "o":
                    output += formatNumber("o", Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
                    break;
                  case "m":
                    output += formatNumber("m", date.getMonth() + 1, 2);
                    break;
                  case "M":
                    output += formatName("M", date.getMonth(), monthNamesShort, monthNames);
                    break;
                  case "y":
                    output += (lookAhead("y") ? date.getFullYear() : (date.getYear() % 100 < 10 ? "0" : "") + date.getYear() % 100);
                    break;
                  case "@":
                    output += date.getTime();
                    break;
                  case "!":
                    output += date.getTime() * 10000 + this._ticksTo1970;
                    break;
                  case "'":
                    if (lookAhead("'")) {
                      output += "'";
                    } else {
                      literal = true;
                    }
                    break;
                  default:
                    output += format.charAt(iFormat);
                }
              }
            }
          }
          return output;
        },
        _possibleChars: function(format) {
          var iFormat,
              chars = "",
              literal = false,
              lookAhead = function(match) {
                var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
                if (matches) {
                  iFormat++;
                }
                return matches;
              };
          for (iFormat = 0; iFormat < format.length; iFormat++) {
            if (literal) {
              if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                literal = false;
              } else {
                chars += format.charAt(iFormat);
              }
            } else {
              switch (format.charAt(iFormat)) {
                case "d":
                case "m":
                case "y":
                case "@":
                  chars += "0123456789";
                  break;
                case "D":
                case "M":
                  return null;
                case "'":
                  if (lookAhead("'")) {
                    chars += "'";
                  } else {
                    literal = true;
                  }
                  break;
                default:
                  chars += format.charAt(iFormat);
              }
            }
          }
          return chars;
        },
        _get: function(inst, name) {
          return inst.settings[name] !== undefined ? inst.settings[name] : this._defaults[name];
        },
        _setDateFromField: function(inst, noDefault) {
          if (inst.input.val() === inst.lastVal) {
            return ;
          }
          var dateFormat = this._get(inst, "dateFormat"),
              dates = inst.lastVal = inst.input ? inst.input.val() : null,
              defaultDate = this._getDefaultDate(inst),
              date = defaultDate,
              settings = this._getFormatConfig(inst);
          try {
            date = this.parseDate(dateFormat, dates, settings) || defaultDate;
          } catch (event) {
            dates = (noDefault ? "" : dates);
          }
          inst.selectedDay = date.getDate();
          inst.drawMonth = inst.selectedMonth = date.getMonth();
          inst.drawYear = inst.selectedYear = date.getFullYear();
          inst.currentDay = (dates ? date.getDate() : 0);
          inst.currentMonth = (dates ? date.getMonth() : 0);
          inst.currentYear = (dates ? date.getFullYear() : 0);
          this._adjustInstDate(inst);
        },
        _getDefaultDate: function(inst) {
          return this._restrictMinMax(inst, this._determineDate(inst, this._get(inst, "defaultDate"), new Date()));
        },
        _determineDate: function(inst, date, defaultDate) {
          var offsetNumeric = function(offset) {
            var date = new Date();
            date.setDate(date.getDate() + offset);
            return date;
          },
              offsetString = function(offset) {
                try {
                  return $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"), offset, $.datepicker._getFormatConfig(inst));
                } catch (e) {}
                var date = (offset.toLowerCase().match(/^c/) ? $.datepicker._getDate(inst) : null) || new Date(),
                    year = date.getFullYear(),
                    month = date.getMonth(),
                    day = date.getDate(),
                    pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
                    matches = pattern.exec(offset);
                while (matches) {
                  switch (matches[2] || "d") {
                    case "d":
                    case "D":
                      day += parseInt(matches[1], 10);
                      break;
                    case "w":
                    case "W":
                      day += parseInt(matches[1], 10) * 7;
                      break;
                    case "m":
                    case "M":
                      month += parseInt(matches[1], 10);
                      day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                      break;
                    case "y":
                    case "Y":
                      year += parseInt(matches[1], 10);
                      day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                      break;
                  }
                  matches = pattern.exec(offset);
                }
                return new Date(year, month, day);
              },
              newDate = (date == null || date === "" ? defaultDate : (typeof date === "string" ? offsetString(date) : (typeof date === "number" ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));
          newDate = (newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate);
          if (newDate) {
            newDate.setHours(0);
            newDate.setMinutes(0);
            newDate.setSeconds(0);
            newDate.setMilliseconds(0);
          }
          return this._daylightSavingAdjust(newDate);
        },
        _daylightSavingAdjust: function(date) {
          if (!date) {
            return null;
          }
          date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
          return date;
        },
        _setDate: function(inst, date, noChange) {
          var clear = !date,
              origMonth = inst.selectedMonth,
              origYear = inst.selectedYear,
              newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));
          inst.selectedDay = inst.currentDay = newDate.getDate();
          inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
          inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
          if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
            this._notifyChange(inst);
          }
          this._adjustInstDate(inst);
          if (inst.input) {
            inst.input.val(clear ? "" : this._formatDate(inst));
          }
        },
        _getDate: function(inst) {
          var startDate = (!inst.currentYear || (inst.input && inst.input.val() === "") ? null : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
          return startDate;
        },
        _attachHandlers: function(inst) {
          var stepMonths = this._get(inst, "stepMonths"),
              id = "#" + inst.id.replace(/\\\\/g, "\\");
          inst.dpDiv.find("[data-handler]").map(function() {
            var handler = {
              prev: function() {
                $.datepicker._adjustDate(id, -stepMonths, "M");
              },
              next: function() {
                $.datepicker._adjustDate(id, +stepMonths, "M");
              },
              hide: function() {
                $.datepicker._hideDatepicker();
              },
              today: function() {
                $.datepicker._gotoToday(id);
              },
              selectDay: function() {
                $.datepicker._selectDay(id, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this);
                return false;
              },
              selectMonth: function() {
                $.datepicker._selectMonthYear(id, this, "M");
                return false;
              },
              selectYear: function() {
                $.datepicker._selectMonthYear(id, this, "Y");
                return false;
              }
            };
            $(this).bind(this.getAttribute("data-event"), handler[this.getAttribute("data-handler")]);
          });
        },
        _generateHTML: function(inst) {
          var maxDraw,
              prevText,
              prev,
              nextText,
              next,
              currentText,
              gotoDate,
              controls,
              buttonPanel,
              firstDay,
              showWeek,
              dayNames,
              dayNamesMin,
              monthNames,
              monthNamesShort,
              beforeShowDay,
              showOtherMonths,
              selectOtherMonths,
              defaultDate,
              html,
              dow,
              row,
              group,
              col,
              selectedDate,
              cornerClass,
              calender,
              thead,
              day,
              daysInMonth,
              leadDays,
              curRows,
              numRows,
              printDate,
              dRow,
              tbody,
              daySettings,
              otherMonth,
              unselectable,
              tempDate = new Date(),
              today = this._daylightSavingAdjust(new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())),
              isRTL = this._get(inst, "isRTL"),
              showButtonPanel = this._get(inst, "showButtonPanel"),
              hideIfNoPrevNext = this._get(inst, "hideIfNoPrevNext"),
              navigationAsDateFormat = this._get(inst, "navigationAsDateFormat"),
              numMonths = this._getNumberOfMonths(inst),
              showCurrentAtPos = this._get(inst, "showCurrentAtPos"),
              stepMonths = this._get(inst, "stepMonths"),
              isMultiMonth = (numMonths[0] !== 1 || numMonths[1] !== 1),
              currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) : new Date(inst.currentYear, inst.currentMonth, inst.currentDay))),
              minDate = this._getMinMaxDate(inst, "min"),
              maxDate = this._getMinMaxDate(inst, "max"),
              drawMonth = inst.drawMonth - showCurrentAtPos,
              drawYear = inst.drawYear;
          if (drawMonth < 0) {
            drawMonth += 12;
            drawYear--;
          }
          if (maxDate) {
            maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(), maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));
            maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);
            while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
              drawMonth--;
              if (drawMonth < 0) {
                drawMonth = 11;
                drawYear--;
              }
            }
          }
          inst.drawMonth = drawMonth;
          inst.drawYear = drawYear;
          prevText = this._get(inst, "prevText");
          prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText, this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)), this._getFormatConfig(inst)));
          prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ? "<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" + " title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "e" : "w") + "'>" + prevText + "</span></a>" : (hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "e" : "w") + "'>" + prevText + "</span></a>"));
          nextText = this._get(inst, "nextText");
          nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText, this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)), this._getFormatConfig(inst)));
          next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ? "<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" + " title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "w" : "e") + "'>" + nextText + "</span></a>" : (hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "w" : "e") + "'>" + nextText + "</span></a>"));
          currentText = this._get(inst, "currentText");
          gotoDate = (this._get(inst, "gotoCurrent") && inst.currentDay ? currentDate : today);
          currentText = (!navigationAsDateFormat ? currentText : this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));
          controls = (!inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" + this._get(inst, "closeText") + "</button>" : "");
          buttonPanel = (showButtonPanel) ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (isRTL ? controls : "") + (this._isInRange(inst, gotoDate) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" + ">" + currentText + "</button>" : "") + (isRTL ? "" : controls) + "</div>" : "";
          firstDay = parseInt(this._get(inst, "firstDay"), 10);
          firstDay = (isNaN(firstDay) ? 0 : firstDay);
          showWeek = this._get(inst, "showWeek");
          dayNames = this._get(inst, "dayNames");
          dayNamesMin = this._get(inst, "dayNamesMin");
          monthNames = this._get(inst, "monthNames");
          monthNamesShort = this._get(inst, "monthNamesShort");
          beforeShowDay = this._get(inst, "beforeShowDay");
          showOtherMonths = this._get(inst, "showOtherMonths");
          selectOtherMonths = this._get(inst, "selectOtherMonths");
          defaultDate = this._getDefaultDate(inst);
          html = "";
          dow;
          for (row = 0; row < numMonths[0]; row++) {
            group = "";
            this.maxRows = 4;
            for (col = 0; col < numMonths[1]; col++) {
              selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
              cornerClass = " ui-corner-all";
              calender = "";
              if (isMultiMonth) {
                calender += "<div class='ui-datepicker-group";
                if (numMonths[1] > 1) {
                  switch (col) {
                    case 0:
                      calender += " ui-datepicker-group-first";
                      cornerClass = " ui-corner-" + (isRTL ? "right" : "left");
                      break;
                    case numMonths[1] - 1:
                      calender += " ui-datepicker-group-last";
                      cornerClass = " ui-corner-" + (isRTL ? "left" : "right");
                      break;
                    default:
                      calender += " ui-datepicker-group-middle";
                      cornerClass = "";
                      break;
                  }
                }
                calender += "'>";
              }
              calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" + (/all|left/.test(cornerClass) && row === 0 ? (isRTL ? next : prev) : "") + (/all|right/.test(cornerClass) && row === 0 ? (isRTL ? prev : next) : "") + this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate, row > 0 || col > 0, monthNames, monthNamesShort) + "</div><table class='ui-datepicker-calendar'><thead>" + "<tr>";
              thead = (showWeek ? "<th class='ui-datepicker-week-col'>" + this._get(inst, "weekHeader") + "</th>" : "");
              for (dow = 0; dow < 7; dow++) {
                day = (dow + firstDay) % 7;
                thead += "<th scope='col'" + ((dow + firstDay + 6) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "") + ">" + "<span title='" + dayNames[day] + "'>" + dayNamesMin[day] + "</span></th>";
              }
              calender += thead + "</tr></thead><tbody>";
              daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
              if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
                inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
              }
              leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
              curRows = Math.ceil((leadDays + daysInMonth) / 7);
              numRows = (isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows);
              this.maxRows = numRows;
              printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
              for (dRow = 0; dRow < numRows; dRow++) {
                calender += "<tr>";
                tbody = (!showWeek ? "" : "<td class='ui-datepicker-week-col'>" + this._get(inst, "calculateWeek")(printDate) + "</td>");
                for (dow = 0; dow < 7; dow++) {
                  daySettings = (beforeShowDay ? beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, ""]);
                  otherMonth = (printDate.getMonth() !== drawMonth);
                  unselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] || (minDate && printDate < minDate) || (maxDate && printDate > maxDate);
                  tbody += "<td class='" + ((dow + firstDay + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + (otherMonth ? " ui-datepicker-other-month" : "") + ((printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent) || (defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime()) ? " " + this._dayOverClass : "") + (unselectable ? " " + this._unselectableClass + " ui-state-disabled" : "") + (otherMonth && !showOtherMonths ? "" : " " + daySettings[1] + (printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "") + (printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "")) + "'" + ((!otherMonth || showOtherMonths) && daySettings[2] ? " title='" + daySettings[2].replace(/'/g, "&#39;") + "'" : "") + (unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'") + ">" + (otherMonth && !showOtherMonths ? "&#xa0;" : (unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" + (printDate.getTime() === today.getTime() ? " ui-state-highlight" : "") + (printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "") + (otherMonth ? " ui-priority-secondary" : "") + "' href='#'>" + printDate.getDate() + "</a>")) + "</td>";
                  printDate.setDate(printDate.getDate() + 1);
                  printDate = this._daylightSavingAdjust(printDate);
                }
                calender += tbody + "</tr>";
              }
              drawMonth++;
              if (drawMonth > 11) {
                drawMonth = 0;
                drawYear++;
              }
              calender += "</tbody></table>" + (isMultiMonth ? "</div>" + ((numMonths[0] > 0 && col === numMonths[1] - 1) ? "<div class='ui-datepicker-row-break'></div>" : "") : "");
              group += calender;
            }
            html += group;
          }
          html += buttonPanel;
          inst._keyEvent = false;
          return html;
        },
        _generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate, secondary, monthNames, monthNamesShort) {
          var inMinYear,
              inMaxYear,
              month,
              years,
              thisYear,
              determineYear,
              year,
              endYear,
              changeMonth = this._get(inst, "changeMonth"),
              changeYear = this._get(inst, "changeYear"),
              showMonthAfterYear = this._get(inst, "showMonthAfterYear"),
              html = "<div class='ui-datepicker-title'>",
              monthHtml = "";
          if (secondary || !changeMonth) {
            monthHtml += "<span class='ui-datepicker-month'>" + monthNames[drawMonth] + "</span>";
          } else {
            inMinYear = (minDate && minDate.getFullYear() === drawYear);
            inMaxYear = (maxDate && maxDate.getFullYear() === drawYear);
            monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
            for (month = 0; month < 12; month++) {
              if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
                monthHtml += "<option value='" + month + "'" + (month === drawMonth ? " selected='selected'" : "") + ">" + monthNamesShort[month] + "</option>";
              }
            }
            monthHtml += "</select>";
          }
          if (!showMonthAfterYear) {
            html += monthHtml + (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "");
          }
          if (!inst.yearshtml) {
            inst.yearshtml = "";
            if (secondary || !changeYear) {
              html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
            } else {
              years = this._get(inst, "yearRange").split(":");
              thisYear = new Date().getFullYear();
              determineYear = function(value) {
                var year = (value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) : (value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) : parseInt(value, 10)));
                return (isNaN(year) ? thisYear : year);
              };
              year = determineYear(years[0]);
              endYear = Math.max(year, determineYear(years[1] || ""));
              year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
              endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
              inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
              for (; year <= endYear; year++) {
                inst.yearshtml += "<option value='" + year + "'" + (year === drawYear ? " selected='selected'" : "") + ">" + year + "</option>";
              }
              inst.yearshtml += "</select>";
              html += inst.yearshtml;
              inst.yearshtml = null;
            }
          }
          html += this._get(inst, "yearSuffix");
          if (showMonthAfterYear) {
            html += (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "") + monthHtml;
          }
          html += "</div>";
          return html;
        },
        _adjustInstDate: function(inst, offset, period) {
          var year = inst.drawYear + (period === "Y" ? offset : 0),
              month = inst.drawMonth + (period === "M" ? offset : 0),
              day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === "D" ? offset : 0),
              date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));
          inst.selectedDay = date.getDate();
          inst.drawMonth = inst.selectedMonth = date.getMonth();
          inst.drawYear = inst.selectedYear = date.getFullYear();
          if (period === "M" || period === "Y") {
            this._notifyChange(inst);
          }
        },
        _restrictMinMax: function(inst, date) {
          var minDate = this._getMinMaxDate(inst, "min"),
              maxDate = this._getMinMaxDate(inst, "max"),
              newDate = (minDate && date < minDate ? minDate : date);
          return (maxDate && newDate > maxDate ? maxDate : newDate);
        },
        _notifyChange: function(inst) {
          var onChange = this._get(inst, "onChangeMonthYear");
          if (onChange) {
            onChange.apply((inst.input ? inst.input[0] : null), [inst.selectedYear, inst.selectedMonth + 1, inst]);
          }
        },
        _getNumberOfMonths: function(inst) {
          var numMonths = this._get(inst, "numberOfMonths");
          return (numMonths == null ? [1, 1] : (typeof numMonths === "number" ? [1, numMonths] : numMonths));
        },
        _getMinMaxDate: function(inst, minMax) {
          return this._determineDate(inst, this._get(inst, minMax + "Date"), null);
        },
        _getDaysInMonth: function(year, month) {
          return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
        },
        _getFirstDayOfMonth: function(year, month) {
          return new Date(year, month, 1).getDay();
        },
        _canAdjustMonth: function(inst, offset, curYear, curMonth) {
          var numMonths = this._getNumberOfMonths(inst),
              date = this._daylightSavingAdjust(new Date(curYear, curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));
          if (offset < 0) {
            date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
          }
          return this._isInRange(inst, date);
        },
        _isInRange: function(inst, date) {
          var yearSplit,
              currentYear,
              minDate = this._getMinMaxDate(inst, "min"),
              maxDate = this._getMinMaxDate(inst, "max"),
              minYear = null,
              maxYear = null,
              years = this._get(inst, "yearRange");
          if (years) {
            yearSplit = years.split(":");
            currentYear = new Date().getFullYear();
            minYear = parseInt(yearSplit[0], 10);
            maxYear = parseInt(yearSplit[1], 10);
            if (yearSplit[0].match(/[+\-].*/)) {
              minYear += currentYear;
            }
            if (yearSplit[1].match(/[+\-].*/)) {
              maxYear += currentYear;
            }
          }
          return ((!minDate || date.getTime() >= minDate.getTime()) && (!maxDate || date.getTime() <= maxDate.getTime()) && (!minYear || date.getFullYear() >= minYear) && (!maxYear || date.getFullYear() <= maxYear));
        },
        _getFormatConfig: function(inst) {
          var shortYearCutoff = this._get(inst, "shortYearCutoff");
          shortYearCutoff = (typeof shortYearCutoff !== "string" ? shortYearCutoff : new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
          return {
            shortYearCutoff: shortYearCutoff,
            dayNamesShort: this._get(inst, "dayNamesShort"),
            dayNames: this._get(inst, "dayNames"),
            monthNamesShort: this._get(inst, "monthNamesShort"),
            monthNames: this._get(inst, "monthNames")
          };
        },
        _formatDate: function(inst, day, month, year) {
          if (!day) {
            inst.currentDay = inst.selectedDay;
            inst.currentMonth = inst.selectedMonth;
            inst.currentYear = inst.selectedYear;
          }
          var date = (day ? (typeof day === "object" ? day : this._daylightSavingAdjust(new Date(year, month, day))) : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
          return this.formatDate(this._get(inst, "dateFormat"), date, this._getFormatConfig(inst));
        }
      });
      function datepicker_bindHover(dpDiv) {
        var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
        return dpDiv.delegate(selector, "mouseout", function() {
          $(this).removeClass("ui-state-hover");
          if (this.className.indexOf("ui-datepicker-prev") !== -1) {
            $(this).removeClass("ui-datepicker-prev-hover");
          }
          if (this.className.indexOf("ui-datepicker-next") !== -1) {
            $(this).removeClass("ui-datepicker-next-hover");
          }
        }).delegate(selector, "mouseover", datepicker_handleMouseover);
      }
      function datepicker_handleMouseover() {
        if (!$.datepicker._isDisabledDatepicker(datepicker_instActive.inline ? datepicker_instActive.dpDiv.parent()[0] : datepicker_instActive.input[0])) {
          $(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover");
          $(this).addClass("ui-state-hover");
          if (this.className.indexOf("ui-datepicker-prev") !== -1) {
            $(this).addClass("ui-datepicker-prev-hover");
          }
          if (this.className.indexOf("ui-datepicker-next") !== -1) {
            $(this).addClass("ui-datepicker-next-hover");
          }
        }
      }
      function datepicker_extendRemove(target, props) {
        $.extend(target, props);
        for (var name in props) {
          if (props[name] == null) {
            target[name] = props[name];
          }
        }
        return target;
      }
      $.fn.datepicker = function(options) {
        if (!this.length) {
          return this;
        }
        if (!$.datepicker.initialized) {
          $(document).mousedown($.datepicker._checkExternalClick);
          $.datepicker.initialized = true;
        }
        if ($("#" + $.datepicker._mainDivId).length === 0) {
          $("body").append($.datepicker.dpDiv);
        }
        var otherArgs = Array.prototype.slice.call(arguments, 1);
        if (typeof options === "string" && (options === "isDisabled" || options === "getDate" || options === "widget")) {
          return $.datepicker["_" + options + "Datepicker"].apply($.datepicker, [this[0]].concat(otherArgs));
        }
        if (options === "option" && arguments.length === 2 && typeof arguments[1] === "string") {
          return $.datepicker["_" + options + "Datepicker"].apply($.datepicker, [this[0]].concat(otherArgs));
        }
        return this.each(function() {
          typeof options === "string" ? $.datepicker["_" + options + "Datepicker"].apply($.datepicker, [this].concat(otherArgs)) : $.datepicker._attachDatepicker(this, options);
        });
      };
      $.datepicker = new Datepicker();
      $.datepicker.initialized = false;
      $.datepicker.uuid = new Date().getTime();
      $.datepicker.version = "1.11.3";
      var datepicker = $.datepicker;
      $.widget("ui.draggable", $.ui.mouse, {
        version: "1.11.3",
        widgetEventPrefix: "drag",
        options: {
          addClasses: true,
          appendTo: "parent",
          axis: false,
          connectToSortable: false,
          containment: false,
          cursor: "auto",
          cursorAt: false,
          grid: false,
          handle: false,
          helper: "original",
          iframeFix: false,
          opacity: false,
          refreshPositions: false,
          revert: false,
          revertDuration: 500,
          scope: "default",
          scroll: true,
          scrollSensitivity: 20,
          scrollSpeed: 20,
          snap: false,
          snapMode: "both",
          snapTolerance: 20,
          stack: false,
          zIndex: false,
          drag: null,
          start: null,
          stop: null
        },
        _create: function() {
          if (this.options.helper === "original") {
            this._setPositionRelative();
          }
          if (this.options.addClasses) {
            this.element.addClass("ui-draggable");
          }
          if (this.options.disabled) {
            this.element.addClass("ui-draggable-disabled");
          }
          this._setHandleClassName();
          this._mouseInit();
        },
        _setOption: function(key, value) {
          this._super(key, value);
          if (key === "handle") {
            this._removeHandleClassName();
            this._setHandleClassName();
          }
        },
        _destroy: function() {
          if ((this.helper || this.element).is(".ui-draggable-dragging")) {
            this.destroyOnClear = true;
            return ;
          }
          this.element.removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled");
          this._removeHandleClassName();
          this._mouseDestroy();
        },
        _mouseCapture: function(event) {
          var o = this.options;
          this._blurActiveElement(event);
          if (this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0) {
            return false;
          }
          this.handle = this._getHandle(event);
          if (!this.handle) {
            return false;
          }
          this._blockFrames(o.iframeFix === true ? "iframe" : o.iframeFix);
          return true;
        },
        _blockFrames: function(selector) {
          this.iframeBlocks = this.document.find(selector).map(function() {
            var iframe = $(this);
            return $("<div>").css("position", "absolute").appendTo(iframe.parent()).outerWidth(iframe.outerWidth()).outerHeight(iframe.outerHeight()).offset(iframe.offset())[0];
          });
        },
        _unblockFrames: function() {
          if (this.iframeBlocks) {
            this.iframeBlocks.remove();
            delete this.iframeBlocks;
          }
        },
        _blurActiveElement: function(event) {
          var document = this.document[0];
          if (!this.handleElement.is(event.target)) {
            return ;
          }
          try {
            if (document.activeElement && document.activeElement.nodeName.toLowerCase() !== "body") {
              $(document.activeElement).blur();
            }
          } catch (error) {}
        },
        _mouseStart: function(event) {
          var o = this.options;
          this.helper = this._createHelper(event);
          this.helper.addClass("ui-draggable-dragging");
          this._cacheHelperProportions();
          if ($.ui.ddmanager) {
            $.ui.ddmanager.current = this;
          }
          this._cacheMargins();
          this.cssPosition = this.helper.css("position");
          this.scrollParent = this.helper.scrollParent(true);
          this.offsetParent = this.helper.offsetParent();
          this.hasFixedAncestor = this.helper.parents().filter(function() {
            return $(this).css("position") === "fixed";
          }).length > 0;
          this.positionAbs = this.element.offset();
          this._refreshOffsets(event);
          this.originalPosition = this.position = this._generatePosition(event, false);
          this.originalPageX = event.pageX;
          this.originalPageY = event.pageY;
          (o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));
          this._setContainment();
          if (this._trigger("start", event) === false) {
            this._clear();
            return false;
          }
          this._cacheHelperProportions();
          if ($.ui.ddmanager && !o.dropBehaviour) {
            $.ui.ddmanager.prepareOffsets(this, event);
          }
          this._normalizeRightBottom();
          this._mouseDrag(event, true);
          if ($.ui.ddmanager) {
            $.ui.ddmanager.dragStart(this, event);
          }
          return true;
        },
        _refreshOffsets: function(event) {
          this.offset = {
            top: this.positionAbs.top - this.margins.top,
            left: this.positionAbs.left - this.margins.left,
            scroll: false,
            parent: this._getParentOffset(),
            relative: this._getRelativeOffset()
          };
          this.offset.click = {
            left: event.pageX - this.offset.left,
            top: event.pageY - this.offset.top
          };
        },
        _mouseDrag: function(event, noPropagation) {
          if (this.hasFixedAncestor) {
            this.offset.parent = this._getParentOffset();
          }
          this.position = this._generatePosition(event, true);
          this.positionAbs = this._convertPositionTo("absolute");
          if (!noPropagation) {
            var ui = this._uiHash();
            if (this._trigger("drag", event, ui) === false) {
              this._mouseUp({});
              return false;
            }
            this.position = ui.position;
          }
          this.helper[0].style.left = this.position.left + "px";
          this.helper[0].style.top = this.position.top + "px";
          if ($.ui.ddmanager) {
            $.ui.ddmanager.drag(this, event);
          }
          return false;
        },
        _mouseStop: function(event) {
          var that = this,
              dropped = false;
          if ($.ui.ddmanager && !this.options.dropBehaviour) {
            dropped = $.ui.ddmanager.drop(this, event);
          }
          if (this.dropped) {
            dropped = this.dropped;
            this.dropped = false;
          }
          if ((this.options.revert === "invalid" && !dropped) || (this.options.revert === "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
            $(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
              if (that._trigger("stop", event) !== false) {
                that._clear();
              }
            });
          } else {
            if (this._trigger("stop", event) !== false) {
              this._clear();
            }
          }
          return false;
        },
        _mouseUp: function(event) {
          this._unblockFrames();
          if ($.ui.ddmanager) {
            $.ui.ddmanager.dragStop(this, event);
          }
          if (this.handleElement.is(event.target)) {
            this.element.focus();
          }
          return $.ui.mouse.prototype._mouseUp.call(this, event);
        },
        cancel: function() {
          if (this.helper.is(".ui-draggable-dragging")) {
            this._mouseUp({});
          } else {
            this._clear();
          }
          return this;
        },
        _getHandle: function(event) {
          return this.options.handle ? !!$(event.target).closest(this.element.find(this.options.handle)).length : true;
        },
        _setHandleClassName: function() {
          this.handleElement = this.options.handle ? this.element.find(this.options.handle) : this.element;
          this.handleElement.addClass("ui-draggable-handle");
        },
        _removeHandleClassName: function() {
          this.handleElement.removeClass("ui-draggable-handle");
        },
        _createHelper: function(event) {
          var o = this.options,
              helperIsFunction = $.isFunction(o.helper),
              helper = helperIsFunction ? $(o.helper.apply(this.element[0], [event])) : (o.helper === "clone" ? this.element.clone().removeAttr("id") : this.element);
          if (!helper.parents("body").length) {
            helper.appendTo((o.appendTo === "parent" ? this.element[0].parentNode : o.appendTo));
          }
          if (helperIsFunction && helper[0] === this.element[0]) {
            this._setPositionRelative();
          }
          if (helper[0] !== this.element[0] && !(/(fixed|absolute)/).test(helper.css("position"))) {
            helper.css("position", "absolute");
          }
          return helper;
        },
        _setPositionRelative: function() {
          if (!(/^(?:r|a|f)/).test(this.element.css("position"))) {
            this.element[0].style.position = "relative";
          }
        },
        _adjustOffsetFromHelper: function(obj) {
          if (typeof obj === "string") {
            obj = obj.split(" ");
          }
          if ($.isArray(obj)) {
            obj = {
              left: +obj[0],
              top: +obj[1] || 0
            };
          }
          if ("left" in obj) {
            this.offset.click.left = obj.left + this.margins.left;
          }
          if ("right" in obj) {
            this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
          }
          if ("top" in obj) {
            this.offset.click.top = obj.top + this.margins.top;
          }
          if ("bottom" in obj) {
            this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
          }
        },
        _isRootNode: function(element) {
          return (/(html|body)/i).test(element.tagName) || element === this.document[0];
        },
        _getParentOffset: function() {
          var po = this.offsetParent.offset(),
              document = this.document[0];
          if (this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
            po.left += this.scrollParent.scrollLeft();
            po.top += this.scrollParent.scrollTop();
          }
          if (this._isRootNode(this.offsetParent[0])) {
            po = {
              top: 0,
              left: 0
            };
          }
          return {
            top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
            left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
          };
        },
        _getRelativeOffset: function() {
          if (this.cssPosition !== "relative") {
            return {
              top: 0,
              left: 0
            };
          }
          var p = this.element.position(),
              scrollIsRootNode = this._isRootNode(this.scrollParent[0]);
          return {
            top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + (!scrollIsRootNode ? this.scrollParent.scrollTop() : 0),
            left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + (!scrollIsRootNode ? this.scrollParent.scrollLeft() : 0)
          };
        },
        _cacheMargins: function() {
          this.margins = {
            left: (parseInt(this.element.css("marginLeft"), 10) || 0),
            top: (parseInt(this.element.css("marginTop"), 10) || 0),
            right: (parseInt(this.element.css("marginRight"), 10) || 0),
            bottom: (parseInt(this.element.css("marginBottom"), 10) || 0)
          };
        },
        _cacheHelperProportions: function() {
          this.helperProportions = {
            width: this.helper.outerWidth(),
            height: this.helper.outerHeight()
          };
        },
        _setContainment: function() {
          var isUserScrollable,
              c,
              ce,
              o = this.options,
              document = this.document[0];
          this.relativeContainer = null;
          if (!o.containment) {
            this.containment = null;
            return ;
          }
          if (o.containment === "window") {
            this.containment = [$(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left, $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top, $(window).scrollLeft() + $(window).width() - this.helperProportions.width - this.margins.left, $(window).scrollTop() + ($(window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top];
            return ;
          }
          if (o.containment === "document") {
            this.containment = [0, 0, $(document).width() - this.helperProportions.width - this.margins.left, ($(document).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top];
            return ;
          }
          if (o.containment.constructor === Array) {
            this.containment = o.containment;
            return ;
          }
          if (o.containment === "parent") {
            o.containment = this.helper[0].parentNode;
          }
          c = $(o.containment);
          ce = c[0];
          if (!ce) {
            return ;
          }
          isUserScrollable = /(scroll|auto)/.test(c.css("overflow"));
          this.containment = [(parseInt(c.css("borderLeftWidth"), 10) || 0) + (parseInt(c.css("paddingLeft"), 10) || 0), (parseInt(c.css("borderTopWidth"), 10) || 0) + (parseInt(c.css("paddingTop"), 10) || 0), (isUserScrollable ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt(c.css("borderRightWidth"), 10) || 0) - (parseInt(c.css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right, (isUserScrollable ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt(c.css("borderBottomWidth"), 10) || 0) - (parseInt(c.css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top - this.margins.bottom];
          this.relativeContainer = c;
        },
        _convertPositionTo: function(d, pos) {
          if (!pos) {
            pos = this.position;
          }
          var mod = d === "absolute" ? 1 : -1,
              scrollIsRootNode = this._isRootNode(this.scrollParent[0]);
          return {
            top: (pos.top + this.offset.relative.top * mod + this.offset.parent.top * mod - ((this.cssPosition === "fixed" ? -this.offset.scroll.top : (scrollIsRootNode ? 0 : this.offset.scroll.top)) * mod)),
            left: (pos.left + this.offset.relative.left * mod + this.offset.parent.left * mod - ((this.cssPosition === "fixed" ? -this.offset.scroll.left : (scrollIsRootNode ? 0 : this.offset.scroll.left)) * mod))
          };
        },
        _generatePosition: function(event, constrainPosition) {
          var containment,
              co,
              top,
              left,
              o = this.options,
              scrollIsRootNode = this._isRootNode(this.scrollParent[0]),
              pageX = event.pageX,
              pageY = event.pageY;
          if (!scrollIsRootNode || !this.offset.scroll) {
            this.offset.scroll = {
              top: this.scrollParent.scrollTop(),
              left: this.scrollParent.scrollLeft()
            };
          }
          if (constrainPosition) {
            if (this.containment) {
              if (this.relativeContainer) {
                co = this.relativeContainer.offset();
                containment = [this.containment[0] + co.left, this.containment[1] + co.top, this.containment[2] + co.left, this.containment[3] + co.top];
              } else {
                containment = this.containment;
              }
              if (event.pageX - this.offset.click.left < containment[0]) {
                pageX = containment[0] + this.offset.click.left;
              }
              if (event.pageY - this.offset.click.top < containment[1]) {
                pageY = containment[1] + this.offset.click.top;
              }
              if (event.pageX - this.offset.click.left > containment[2]) {
                pageX = containment[2] + this.offset.click.left;
              }
              if (event.pageY - this.offset.click.top > containment[3]) {
                pageY = containment[3] + this.offset.click.top;
              }
            }
            if (o.grid) {
              top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
              pageY = containment ? ((top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3]) ? top : ((top - this.offset.click.top >= containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;
              left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
              pageX = containment ? ((left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2]) ? left : ((left - this.offset.click.left >= containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
            }
            if (o.axis === "y") {
              pageX = this.originalPageX;
            }
            if (o.axis === "x") {
              pageY = this.originalPageY;
            }
          }
          return {
            top: (pageY - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + (this.cssPosition === "fixed" ? -this.offset.scroll.top : (scrollIsRootNode ? 0 : this.offset.scroll.top))),
            left: (pageX - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + (this.cssPosition === "fixed" ? -this.offset.scroll.left : (scrollIsRootNode ? 0 : this.offset.scroll.left)))
          };
        },
        _clear: function() {
          this.helper.removeClass("ui-draggable-dragging");
          if (this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
            this.helper.remove();
          }
          this.helper = null;
          this.cancelHelperRemoval = false;
          if (this.destroyOnClear) {
            this.destroy();
          }
        },
        _normalizeRightBottom: function() {
          if (this.options.axis !== "y" && this.helper.css("right") !== "auto") {
            this.helper.width(this.helper.width());
            this.helper.css("right", "auto");
          }
          if (this.options.axis !== "x" && this.helper.css("bottom") !== "auto") {
            this.helper.height(this.helper.height());
            this.helper.css("bottom", "auto");
          }
        },
        _trigger: function(type, event, ui) {
          ui = ui || this._uiHash();
          $.ui.plugin.call(this, type, [event, ui, this], true);
          if (/^(drag|start|stop)/.test(type)) {
            this.positionAbs = this._convertPositionTo("absolute");
            ui.offset = this.positionAbs;
          }
          return $.Widget.prototype._trigger.call(this, type, event, ui);
        },
        plugins: {},
        _uiHash: function() {
          return {
            helper: this.helper,
            position: this.position,
            originalPosition: this.originalPosition,
            offset: this.positionAbs
          };
        }
      });
      $.ui.plugin.add("draggable", "connectToSortable", {
        start: function(event, ui, draggable) {
          var uiSortable = $.extend({}, ui, {item: draggable.element});
          draggable.sortables = [];
          $(draggable.options.connectToSortable).each(function() {
            var sortable = $(this).sortable("instance");
            if (sortable && !sortable.options.disabled) {
              draggable.sortables.push(sortable);
              sortable.refreshPositions();
              sortable._trigger("activate", event, uiSortable);
            }
          });
        },
        stop: function(event, ui, draggable) {
          var uiSortable = $.extend({}, ui, {item: draggable.element});
          draggable.cancelHelperRemoval = false;
          $.each(draggable.sortables, function() {
            var sortable = this;
            if (sortable.isOver) {
              sortable.isOver = 0;
              draggable.cancelHelperRemoval = true;
              sortable.cancelHelperRemoval = false;
              sortable._storedCSS = {
                position: sortable.placeholder.css("position"),
                top: sortable.placeholder.css("top"),
                left: sortable.placeholder.css("left")
              };
              sortable._mouseStop(event);
              sortable.options.helper = sortable.options._helper;
            } else {
              sortable.cancelHelperRemoval = true;
              sortable._trigger("deactivate", event, uiSortable);
            }
          });
        },
        drag: function(event, ui, draggable) {
          $.each(draggable.sortables, function() {
            var innermostIntersecting = false,
                sortable = this;
            sortable.positionAbs = draggable.positionAbs;
            sortable.helperProportions = draggable.helperProportions;
            sortable.offset.click = draggable.offset.click;
            if (sortable._intersectsWith(sortable.containerCache)) {
              innermostIntersecting = true;
              $.each(draggable.sortables, function() {
                this.positionAbs = draggable.positionAbs;
                this.helperProportions = draggable.helperProportions;
                this.offset.click = draggable.offset.click;
                if (this !== sortable && this._intersectsWith(this.containerCache) && $.contains(sortable.element[0], this.element[0])) {
                  innermostIntersecting = false;
                }
                return innermostIntersecting;
              });
            }
            if (innermostIntersecting) {
              if (!sortable.isOver) {
                sortable.isOver = 1;
                sortable.currentItem = ui.helper.appendTo(sortable.element).data("ui-sortable-item", true);
                sortable.options._helper = sortable.options.helper;
                sortable.options.helper = function() {
                  return ui.helper[0];
                };
                event.target = sortable.currentItem[0];
                sortable._mouseCapture(event, true);
                sortable._mouseStart(event, true, true);
                sortable.offset.click.top = draggable.offset.click.top;
                sortable.offset.click.left = draggable.offset.click.left;
                sortable.offset.parent.left -= draggable.offset.parent.left - sortable.offset.parent.left;
                sortable.offset.parent.top -= draggable.offset.parent.top - sortable.offset.parent.top;
                draggable._trigger("toSortable", event);
                draggable.dropped = sortable.element;
                $.each(draggable.sortables, function() {
                  this.refreshPositions();
                });
                draggable.currentItem = draggable.element;
                sortable.fromOutside = draggable;
              }
              if (sortable.currentItem) {
                sortable._mouseDrag(event);
                ui.position = sortable.position;
              }
            } else {
              if (sortable.isOver) {
                sortable.isOver = 0;
                sortable.cancelHelperRemoval = true;
                sortable.options._revert = sortable.options.revert;
                sortable.options.revert = false;
                sortable._trigger("out", event, sortable._uiHash(sortable));
                sortable._mouseStop(event, true);
                sortable.options.revert = sortable.options._revert;
                sortable.options.helper = sortable.options._helper;
                if (sortable.placeholder) {
                  sortable.placeholder.remove();
                }
                draggable._refreshOffsets(event);
                ui.position = draggable._generatePosition(event, true);
                draggable._trigger("fromSortable", event);
                draggable.dropped = false;
                $.each(draggable.sortables, function() {
                  this.refreshPositions();
                });
              }
            }
          });
        }
      });
      $.ui.plugin.add("draggable", "cursor", {
        start: function(event, ui, instance) {
          var t = $("body"),
              o = instance.options;
          if (t.css("cursor")) {
            o._cursor = t.css("cursor");
          }
          t.css("cursor", o.cursor);
        },
        stop: function(event, ui, instance) {
          var o = instance.options;
          if (o._cursor) {
            $("body").css("cursor", o._cursor);
          }
        }
      });
      $.ui.plugin.add("draggable", "opacity", {
        start: function(event, ui, instance) {
          var t = $(ui.helper),
              o = instance.options;
          if (t.css("opacity")) {
            o._opacity = t.css("opacity");
          }
          t.css("opacity", o.opacity);
        },
        stop: function(event, ui, instance) {
          var o = instance.options;
          if (o._opacity) {
            $(ui.helper).css("opacity", o._opacity);
          }
        }
      });
      $.ui.plugin.add("draggable", "scroll", {
        start: function(event, ui, i) {
          if (!i.scrollParentNotHidden) {
            i.scrollParentNotHidden = i.helper.scrollParent(false);
          }
          if (i.scrollParentNotHidden[0] !== i.document[0] && i.scrollParentNotHidden[0].tagName !== "HTML") {
            i.overflowOffset = i.scrollParentNotHidden.offset();
          }
        },
        drag: function(event, ui, i) {
          var o = i.options,
              scrolled = false,
              scrollParent = i.scrollParentNotHidden[0],
              document = i.document[0];
          if (scrollParent !== document && scrollParent.tagName !== "HTML") {
            if (!o.axis || o.axis !== "x") {
              if ((i.overflowOffset.top + scrollParent.offsetHeight) - event.pageY < o.scrollSensitivity) {
                scrollParent.scrollTop = scrolled = scrollParent.scrollTop + o.scrollSpeed;
              } else if (event.pageY - i.overflowOffset.top < o.scrollSensitivity) {
                scrollParent.scrollTop = scrolled = scrollParent.scrollTop - o.scrollSpeed;
              }
            }
            if (!o.axis || o.axis !== "y") {
              if ((i.overflowOffset.left + scrollParent.offsetWidth) - event.pageX < o.scrollSensitivity) {
                scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + o.scrollSpeed;
              } else if (event.pageX - i.overflowOffset.left < o.scrollSensitivity) {
                scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - o.scrollSpeed;
              }
            }
          } else {
            if (!o.axis || o.axis !== "x") {
              if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
                scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
              } else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
                scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
              }
            }
            if (!o.axis || o.axis !== "y") {
              if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
                scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
              } else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
                scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
              }
            }
          }
          if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
            $.ui.ddmanager.prepareOffsets(i, event);
          }
        }
      });
      $.ui.plugin.add("draggable", "snap", {
        start: function(event, ui, i) {
          var o = i.options;
          i.snapElements = [];
          $(o.snap.constructor !== String ? (o.snap.items || ":data(ui-draggable)") : o.snap).each(function() {
            var $t = $(this),
                $o = $t.offset();
            if (this !== i.element[0]) {
              i.snapElements.push({
                item: this,
                width: $t.outerWidth(),
                height: $t.outerHeight(),
                top: $o.top,
                left: $o.left
              });
            }
          });
        },
        drag: function(event, ui, inst) {
          var ts,
              bs,
              ls,
              rs,
              l,
              r,
              t,
              b,
              i,
              first,
              o = inst.options,
              d = o.snapTolerance,
              x1 = ui.offset.left,
              x2 = x1 + inst.helperProportions.width,
              y1 = ui.offset.top,
              y2 = y1 + inst.helperProportions.height;
          for (i = inst.snapElements.length - 1; i >= 0; i--) {
            l = inst.snapElements[i].left - inst.margins.left;
            r = l + inst.snapElements[i].width;
            t = inst.snapElements[i].top - inst.margins.top;
            b = t + inst.snapElements[i].height;
            if (x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains(inst.snapElements[i].item.ownerDocument, inst.snapElements[i].item)) {
              if (inst.snapElements[i].snapping) {
                (inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), {snapItem: inst.snapElements[i].item})));
              }
              inst.snapElements[i].snapping = false;
              continue;
            }
            if (o.snapMode !== "inner") {
              ts = Math.abs(t - y2) <= d;
              bs = Math.abs(b - y1) <= d;
              ls = Math.abs(l - x2) <= d;
              rs = Math.abs(r - x1) <= d;
              if (ts) {
                ui.position.top = inst._convertPositionTo("relative", {
                  top: t - inst.helperProportions.height,
                  left: 0
                }).top;
              }
              if (bs) {
                ui.position.top = inst._convertPositionTo("relative", {
                  top: b,
                  left: 0
                }).top;
              }
              if (ls) {
                ui.position.left = inst._convertPositionTo("relative", {
                  top: 0,
                  left: l - inst.helperProportions.width
                }).left;
              }
              if (rs) {
                ui.position.left = inst._convertPositionTo("relative", {
                  top: 0,
                  left: r
                }).left;
              }
            }
            first = (ts || bs || ls || rs);
            if (o.snapMode !== "outer") {
              ts = Math.abs(t - y1) <= d;
              bs = Math.abs(b - y2) <= d;
              ls = Math.abs(l - x1) <= d;
              rs = Math.abs(r - x2) <= d;
              if (ts) {
                ui.position.top = inst._convertPositionTo("relative", {
                  top: t,
                  left: 0
                }).top;
              }
              if (bs) {
                ui.position.top = inst._convertPositionTo("relative", {
                  top: b - inst.helperProportions.height,
                  left: 0
                }).top;
              }
              if (ls) {
                ui.position.left = inst._convertPositionTo("relative", {
                  top: 0,
                  left: l
                }).left;
              }
              if (rs) {
                ui.position.left = inst._convertPositionTo("relative", {
                  top: 0,
                  left: r - inst.helperProportions.width
                }).left;
              }
            }
            if (!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
              (inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), {snapItem: inst.snapElements[i].item})));
            }
            inst.snapElements[i].snapping = (ts || bs || ls || rs || first);
          }
        }
      });
      $.ui.plugin.add("draggable", "stack", {start: function(event, ui, instance) {
          var min,
              o = instance.options,
              group = $.makeArray($(o.stack)).sort(function(a, b) {
                return (parseInt($(a).css("zIndex"), 10) || 0) - (parseInt($(b).css("zIndex"), 10) || 0);
              });
          if (!group.length) {
            return ;
          }
          min = parseInt($(group[0]).css("zIndex"), 10) || 0;
          $(group).each(function(i) {
            $(this).css("zIndex", min + i);
          });
          this.css("zIndex", (min + group.length));
        }});
      $.ui.plugin.add("draggable", "zIndex", {
        start: function(event, ui, instance) {
          var t = $(ui.helper),
              o = instance.options;
          if (t.css("zIndex")) {
            o._zIndex = t.css("zIndex");
          }
          t.css("zIndex", o.zIndex);
        },
        stop: function(event, ui, instance) {
          var o = instance.options;
          if (o._zIndex) {
            $(ui.helper).css("zIndex", o._zIndex);
          }
        }
      });
      var draggable = $.ui.draggable;
      $.widget("ui.resizable", $.ui.mouse, {
        version: "1.11.3",
        widgetEventPrefix: "resize",
        options: {
          alsoResize: false,
          animate: false,
          animateDuration: "slow",
          animateEasing: "swing",
          aspectRatio: false,
          autoHide: false,
          containment: false,
          ghost: false,
          grid: false,
          handles: "e,s,se",
          helper: false,
          maxHeight: null,
          maxWidth: null,
          minHeight: 10,
          minWidth: 10,
          zIndex: 90,
          resize: null,
          start: null,
          stop: null
        },
        _num: function(value) {
          return parseInt(value, 10) || 0;
        },
        _isNumber: function(value) {
          return !isNaN(parseInt(value, 10));
        },
        _hasScroll: function(el, a) {
          if ($(el).css("overflow") === "hidden") {
            return false;
          }
          var scroll = (a && a === "left") ? "scrollLeft" : "scrollTop",
              has = false;
          if (el[scroll] > 0) {
            return true;
          }
          el[scroll] = 1;
          has = (el[scroll] > 0);
          el[scroll] = 0;
          return has;
        },
        _create: function() {
          var n,
              i,
              handle,
              axis,
              hname,
              that = this,
              o = this.options;
          this.element.addClass("ui-resizable");
          $.extend(this, {
            _aspectRatio: !!(o.aspectRatio),
            aspectRatio: o.aspectRatio,
            originalElement: this.element,
            _proportionallyResizeElements: [],
            _helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
          });
          if (this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i)) {
            this.element.wrap($("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
              position: this.element.css("position"),
              width: this.element.outerWidth(),
              height: this.element.outerHeight(),
              top: this.element.css("top"),
              left: this.element.css("left")
            }));
            this.element = this.element.parent().data("ui-resizable", this.element.resizable("instance"));
            this.elementIsWrapper = true;
            this.element.css({
              marginLeft: this.originalElement.css("marginLeft"),
              marginTop: this.originalElement.css("marginTop"),
              marginRight: this.originalElement.css("marginRight"),
              marginBottom: this.originalElement.css("marginBottom")
            });
            this.originalElement.css({
              marginLeft: 0,
              marginTop: 0,
              marginRight: 0,
              marginBottom: 0
            });
            this.originalResizeStyle = this.originalElement.css("resize");
            this.originalElement.css("resize", "none");
            this._proportionallyResizeElements.push(this.originalElement.css({
              position: "static",
              zoom: 1,
              display: "block"
            }));
            this.originalElement.css({margin: this.originalElement.css("margin")});
            this._proportionallyResize();
          }
          this.handles = o.handles || (!$(".ui-resizable-handle", this.element).length ? "e,s,se" : {
            n: ".ui-resizable-n",
            e: ".ui-resizable-e",
            s: ".ui-resizable-s",
            w: ".ui-resizable-w",
            se: ".ui-resizable-se",
            sw: ".ui-resizable-sw",
            ne: ".ui-resizable-ne",
            nw: ".ui-resizable-nw"
          });
          if (this.handles.constructor === String) {
            if (this.handles === "all") {
              this.handles = "n,e,s,w,se,sw,ne,nw";
            }
            n = this.handles.split(",");
            this.handles = {};
            for (i = 0; i < n.length; i++) {
              handle = $.trim(n[i]);
              hname = "ui-resizable-" + handle;
              axis = $("<div class='ui-resizable-handle " + hname + "'></div>");
              axis.css({zIndex: o.zIndex});
              if ("se" === handle) {
                axis.addClass("ui-icon ui-icon-gripsmall-diagonal-se");
              }
              this.handles[handle] = ".ui-resizable-" + handle;
              this.element.append(axis);
            }
          }
          this._renderAxis = function(target) {
            var i,
                axis,
                padPos,
                padWrapper;
            target = target || this.element;
            for (i in this.handles) {
              if (this.handles[i].constructor === String) {
                this.handles[i] = this.element.children(this.handles[i]).first().show();
              }
              if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i)) {
                axis = $(this.handles[i], this.element);
                padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();
                padPos = ["padding", /ne|nw|n/.test(i) ? "Top" : /se|sw|s/.test(i) ? "Bottom" : /^e$/.test(i) ? "Right" : "Left"].join("");
                target.css(padPos, padWrapper);
                this._proportionallyResize();
              }
              if (!$(this.handles[i]).length) {
                continue;
              }
            }
          };
          this._renderAxis(this.element);
          this._handles = $(".ui-resizable-handle", this.element).disableSelection();
          this._handles.mouseover(function() {
            if (!that.resizing) {
              if (this.className) {
                axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
              }
              that.axis = axis && axis[1] ? axis[1] : "se";
            }
          });
          if (o.autoHide) {
            this._handles.hide();
            $(this.element).addClass("ui-resizable-autohide").mouseenter(function() {
              if (o.disabled) {
                return ;
              }
              $(this).removeClass("ui-resizable-autohide");
              that._handles.show();
            }).mouseleave(function() {
              if (o.disabled) {
                return ;
              }
              if (!that.resizing) {
                $(this).addClass("ui-resizable-autohide");
                that._handles.hide();
              }
            });
          }
          this._mouseInit();
        },
        _destroy: function() {
          this._mouseDestroy();
          var wrapper,
              _destroy = function(exp) {
                $(exp).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing").removeData("resizable").removeData("ui-resizable").unbind(".resizable").find(".ui-resizable-handle").remove();
              };
          if (this.elementIsWrapper) {
            _destroy(this.element);
            wrapper = this.element;
            this.originalElement.css({
              position: wrapper.css("position"),
              width: wrapper.outerWidth(),
              height: wrapper.outerHeight(),
              top: wrapper.css("top"),
              left: wrapper.css("left")
            }).insertAfter(wrapper);
            wrapper.remove();
          }
          this.originalElement.css("resize", this.originalResizeStyle);
          _destroy(this.originalElement);
          return this;
        },
        _mouseCapture: function(event) {
          var i,
              handle,
              capture = false;
          for (i in this.handles) {
            handle = $(this.handles[i])[0];
            if (handle === event.target || $.contains(handle, event.target)) {
              capture = true;
            }
          }
          return !this.options.disabled && capture;
        },
        _mouseStart: function(event) {
          var curleft,
              curtop,
              cursor,
              o = this.options,
              el = this.element;
          this.resizing = true;
          this._renderProxy();
          curleft = this._num(this.helper.css("left"));
          curtop = this._num(this.helper.css("top"));
          if (o.containment) {
            curleft += $(o.containment).scrollLeft() || 0;
            curtop += $(o.containment).scrollTop() || 0;
          }
          this.offset = this.helper.offset();
          this.position = {
            left: curleft,
            top: curtop
          };
          this.size = this._helper ? {
            width: this.helper.width(),
            height: this.helper.height()
          } : {
            width: el.width(),
            height: el.height()
          };
          this.originalSize = this._helper ? {
            width: el.outerWidth(),
            height: el.outerHeight()
          } : {
            width: el.width(),
            height: el.height()
          };
          this.sizeDiff = {
            width: el.outerWidth() - el.width(),
            height: el.outerHeight() - el.height()
          };
          this.originalPosition = {
            left: curleft,
            top: curtop
          };
          this.originalMousePosition = {
            left: event.pageX,
            top: event.pageY
          };
          this.aspectRatio = (typeof o.aspectRatio === "number") ? o.aspectRatio : ((this.originalSize.width / this.originalSize.height) || 1);
          cursor = $(".ui-resizable-" + this.axis).css("cursor");
          $("body").css("cursor", cursor === "auto" ? this.axis + "-resize" : cursor);
          el.addClass("ui-resizable-resizing");
          this._propagate("start", event);
          return true;
        },
        _mouseDrag: function(event) {
          var data,
              props,
              smp = this.originalMousePosition,
              a = this.axis,
              dx = (event.pageX - smp.left) || 0,
              dy = (event.pageY - smp.top) || 0,
              trigger = this._change[a];
          this._updatePrevProperties();
          if (!trigger) {
            return false;
          }
          data = trigger.apply(this, [event, dx, dy]);
          this._updateVirtualBoundaries(event.shiftKey);
          if (this._aspectRatio || event.shiftKey) {
            data = this._updateRatio(data, event);
          }
          data = this._respectSize(data, event);
          this._updateCache(data);
          this._propagate("resize", event);
          props = this._applyChanges();
          if (!this._helper && this._proportionallyResizeElements.length) {
            this._proportionallyResize();
          }
          if (!$.isEmptyObject(props)) {
            this._updatePrevProperties();
            this._trigger("resize", event, this.ui());
            this._applyChanges();
          }
          return false;
        },
        _mouseStop: function(event) {
          this.resizing = false;
          var pr,
              ista,
              soffseth,
              soffsetw,
              s,
              left,
              top,
              o = this.options,
              that = this;
          if (this._helper) {
            pr = this._proportionallyResizeElements;
            ista = pr.length && (/textarea/i).test(pr[0].nodeName);
            soffseth = ista && this._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height;
            soffsetw = ista ? 0 : that.sizeDiff.width;
            s = {
              width: (that.helper.width() - soffsetw),
              height: (that.helper.height() - soffseth)
            };
            left = (parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left)) || null;
            top = (parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top)) || null;
            if (!o.animate) {
              this.element.css($.extend(s, {
                top: top,
                left: left
              }));
            }
            that.helper.height(that.size.height);
            that.helper.width(that.size.width);
            if (this._helper && !o.animate) {
              this._proportionallyResize();
            }
          }
          $("body").css("cursor", "auto");
          this.element.removeClass("ui-resizable-resizing");
          this._propagate("stop", event);
          if (this._helper) {
            this.helper.remove();
          }
          return false;
        },
        _updatePrevProperties: function() {
          this.prevPosition = {
            top: this.position.top,
            left: this.position.left
          };
          this.prevSize = {
            width: this.size.width,
            height: this.size.height
          };
        },
        _applyChanges: function() {
          var props = {};
          if (this.position.top !== this.prevPosition.top) {
            props.top = this.position.top + "px";
          }
          if (this.position.left !== this.prevPosition.left) {
            props.left = this.position.left + "px";
          }
          if (this.size.width !== this.prevSize.width) {
            props.width = this.size.width + "px";
          }
          if (this.size.height !== this.prevSize.height) {
            props.height = this.size.height + "px";
          }
          this.helper.css(props);
          return props;
        },
        _updateVirtualBoundaries: function(forceAspectRatio) {
          var pMinWidth,
              pMaxWidth,
              pMinHeight,
              pMaxHeight,
              b,
              o = this.options;
          b = {
            minWidth: this._isNumber(o.minWidth) ? o.minWidth : 0,
            maxWidth: this._isNumber(o.maxWidth) ? o.maxWidth : Infinity,
            minHeight: this._isNumber(o.minHeight) ? o.minHeight : 0,
            maxHeight: this._isNumber(o.maxHeight) ? o.maxHeight : Infinity
          };
          if (this._aspectRatio || forceAspectRatio) {
            pMinWidth = b.minHeight * this.aspectRatio;
            pMinHeight = b.minWidth / this.aspectRatio;
            pMaxWidth = b.maxHeight * this.aspectRatio;
            pMaxHeight = b.maxWidth / this.aspectRatio;
            if (pMinWidth > b.minWidth) {
              b.minWidth = pMinWidth;
            }
            if (pMinHeight > b.minHeight) {
              b.minHeight = pMinHeight;
            }
            if (pMaxWidth < b.maxWidth) {
              b.maxWidth = pMaxWidth;
            }
            if (pMaxHeight < b.maxHeight) {
              b.maxHeight = pMaxHeight;
            }
          }
          this._vBoundaries = b;
        },
        _updateCache: function(data) {
          this.offset = this.helper.offset();
          if (this._isNumber(data.left)) {
            this.position.left = data.left;
          }
          if (this._isNumber(data.top)) {
            this.position.top = data.top;
          }
          if (this._isNumber(data.height)) {
            this.size.height = data.height;
          }
          if (this._isNumber(data.width)) {
            this.size.width = data.width;
          }
        },
        _updateRatio: function(data) {
          var cpos = this.position,
              csize = this.size,
              a = this.axis;
          if (this._isNumber(data.height)) {
            data.width = (data.height * this.aspectRatio);
          } else if (this._isNumber(data.width)) {
            data.height = (data.width / this.aspectRatio);
          }
          if (a === "sw") {
            data.left = cpos.left + (csize.width - data.width);
            data.top = null;
          }
          if (a === "nw") {
            data.top = cpos.top + (csize.height - data.height);
            data.left = cpos.left + (csize.width - data.width);
          }
          return data;
        },
        _respectSize: function(data) {
          var o = this._vBoundaries,
              a = this.axis,
              ismaxw = this._isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width),
              ismaxh = this._isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),
              isminw = this._isNumber(data.width) && o.minWidth && (o.minWidth > data.width),
              isminh = this._isNumber(data.height) && o.minHeight && (o.minHeight > data.height),
              dw = this.originalPosition.left + this.originalSize.width,
              dh = this.position.top + this.size.height,
              cw = /sw|nw|w/.test(a),
              ch = /nw|ne|n/.test(a);
          if (isminw) {
            data.width = o.minWidth;
          }
          if (isminh) {
            data.height = o.minHeight;
          }
          if (ismaxw) {
            data.width = o.maxWidth;
          }
          if (ismaxh) {
            data.height = o.maxHeight;
          }
          if (isminw && cw) {
            data.left = dw - o.minWidth;
          }
          if (ismaxw && cw) {
            data.left = dw - o.maxWidth;
          }
          if (isminh && ch) {
            data.top = dh - o.minHeight;
          }
          if (ismaxh && ch) {
            data.top = dh - o.maxHeight;
          }
          if (!data.width && !data.height && !data.left && data.top) {
            data.top = null;
          } else if (!data.width && !data.height && !data.top && data.left) {
            data.left = null;
          }
          return data;
        },
        _getPaddingPlusBorderDimensions: function(element) {
          var i = 0,
              widths = [],
              borders = [element.css("borderTopWidth"), element.css("borderRightWidth"), element.css("borderBottomWidth"), element.css("borderLeftWidth")],
              paddings = [element.css("paddingTop"), element.css("paddingRight"), element.css("paddingBottom"), element.css("paddingLeft")];
          for (; i < 4; i++) {
            widths[i] = (parseInt(borders[i], 10) || 0);
            widths[i] += (parseInt(paddings[i], 10) || 0);
          }
          return {
            height: widths[0] + widths[2],
            width: widths[1] + widths[3]
          };
        },
        _proportionallyResize: function() {
          if (!this._proportionallyResizeElements.length) {
            return ;
          }
          var prel,
              i = 0,
              element = this.helper || this.element;
          for (; i < this._proportionallyResizeElements.length; i++) {
            prel = this._proportionallyResizeElements[i];
            if (!this.outerDimensions) {
              this.outerDimensions = this._getPaddingPlusBorderDimensions(prel);
            }
            prel.css({
              height: (element.height() - this.outerDimensions.height) || 0,
              width: (element.width() - this.outerDimensions.width) || 0
            });
          }
        },
        _renderProxy: function() {
          var el = this.element,
              o = this.options;
          this.elementOffset = el.offset();
          if (this._helper) {
            this.helper = this.helper || $("<div style='overflow:hidden;'></div>");
            this.helper.addClass(this._helper).css({
              width: this.element.outerWidth() - 1,
              height: this.element.outerHeight() - 1,
              position: "absolute",
              left: this.elementOffset.left + "px",
              top: this.elementOffset.top + "px",
              zIndex: ++o.zIndex
            });
            this.helper.appendTo("body").disableSelection();
          } else {
            this.helper = this.element;
          }
        },
        _change: {
          e: function(event, dx) {
            return {width: this.originalSize.width + dx};
          },
          w: function(event, dx) {
            var cs = this.originalSize,
                sp = this.originalPosition;
            return {
              left: sp.left + dx,
              width: cs.width - dx
            };
          },
          n: function(event, dx, dy) {
            var cs = this.originalSize,
                sp = this.originalPosition;
            return {
              top: sp.top + dy,
              height: cs.height - dy
            };
          },
          s: function(event, dx, dy) {
            return {height: this.originalSize.height + dy};
          },
          se: function(event, dx, dy) {
            return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
          },
          sw: function(event, dx, dy) {
            return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
          },
          ne: function(event, dx, dy) {
            return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
          },
          nw: function(event, dx, dy) {
            return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
          }
        },
        _propagate: function(n, event) {
          $.ui.plugin.call(this, n, [event, this.ui()]);
          (n !== "resize" && this._trigger(n, event, this.ui()));
        },
        plugins: {},
        ui: function() {
          return {
            originalElement: this.originalElement,
            element: this.element,
            helper: this.helper,
            position: this.position,
            size: this.size,
            originalSize: this.originalSize,
            originalPosition: this.originalPosition
          };
        }
      });
      $.ui.plugin.add("resizable", "animate", {stop: function(event) {
          var that = $(this).resizable("instance"),
              o = that.options,
              pr = that._proportionallyResizeElements,
              ista = pr.length && (/textarea/i).test(pr[0].nodeName),
              soffseth = ista && that._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height,
              soffsetw = ista ? 0 : that.sizeDiff.width,
              style = {
                width: (that.size.width - soffsetw),
                height: (that.size.height - soffseth)
              },
              left = (parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left)) || null,
              top = (parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top)) || null;
          that.element.animate($.extend(style, top && left ? {
            top: top,
            left: left
          } : {}), {
            duration: o.animateDuration,
            easing: o.animateEasing,
            step: function() {
              var data = {
                width: parseInt(that.element.css("width"), 10),
                height: parseInt(that.element.css("height"), 10),
                top: parseInt(that.element.css("top"), 10),
                left: parseInt(that.element.css("left"), 10)
              };
              if (pr && pr.length) {
                $(pr[0]).css({
                  width: data.width,
                  height: data.height
                });
              }
              that._updateCache(data);
              that._propagate("resize", event);
            }
          });
        }});
      $.ui.plugin.add("resizable", "containment", {
        start: function() {
          var element,
              p,
              co,
              ch,
              cw,
              width,
              height,
              that = $(this).resizable("instance"),
              o = that.options,
              el = that.element,
              oc = o.containment,
              ce = (oc instanceof $) ? oc.get(0) : (/parent/.test(oc)) ? el.parent().get(0) : oc;
          if (!ce) {
            return ;
          }
          that.containerElement = $(ce);
          if (/document/.test(oc) || oc === document) {
            that.containerOffset = {
              left: 0,
              top: 0
            };
            that.containerPosition = {
              left: 0,
              top: 0
            };
            that.parentData = {
              element: $(document),
              left: 0,
              top: 0,
              width: $(document).width(),
              height: $(document).height() || document.body.parentNode.scrollHeight
            };
          } else {
            element = $(ce);
            p = [];
            $(["Top", "Right", "Left", "Bottom"]).each(function(i, name) {
              p[i] = that._num(element.css("padding" + name));
            });
            that.containerOffset = element.offset();
            that.containerPosition = element.position();
            that.containerSize = {
              height: (element.innerHeight() - p[3]),
              width: (element.innerWidth() - p[1])
            };
            co = that.containerOffset;
            ch = that.containerSize.height;
            cw = that.containerSize.width;
            width = (that._hasScroll(ce, "left") ? ce.scrollWidth : cw);
            height = (that._hasScroll(ce) ? ce.scrollHeight : ch);
            that.parentData = {
              element: ce,
              left: co.left,
              top: co.top,
              width: width,
              height: height
            };
          }
        },
        resize: function(event) {
          var woset,
              hoset,
              isParent,
              isOffsetRelative,
              that = $(this).resizable("instance"),
              o = that.options,
              co = that.containerOffset,
              cp = that.position,
              pRatio = that._aspectRatio || event.shiftKey,
              cop = {
                top: 0,
                left: 0
              },
              ce = that.containerElement,
              continueResize = true;
          if (ce[0] !== document && (/static/).test(ce.css("position"))) {
            cop = co;
          }
          if (cp.left < (that._helper ? co.left : 0)) {
            that.size.width = that.size.width + (that._helper ? (that.position.left - co.left) : (that.position.left - cop.left));
            if (pRatio) {
              that.size.height = that.size.width / that.aspectRatio;
              continueResize = false;
            }
            that.position.left = o.helper ? co.left : 0;
          }
          if (cp.top < (that._helper ? co.top : 0)) {
            that.size.height = that.size.height + (that._helper ? (that.position.top - co.top) : that.position.top);
            if (pRatio) {
              that.size.width = that.size.height * that.aspectRatio;
              continueResize = false;
            }
            that.position.top = that._helper ? co.top : 0;
          }
          isParent = that.containerElement.get(0) === that.element.parent().get(0);
          isOffsetRelative = /relative|absolute/.test(that.containerElement.css("position"));
          if (isParent && isOffsetRelative) {
            that.offset.left = that.parentData.left + that.position.left;
            that.offset.top = that.parentData.top + that.position.top;
          } else {
            that.offset.left = that.element.offset().left;
            that.offset.top = that.element.offset().top;
          }
          woset = Math.abs(that.sizeDiff.width + (that._helper ? that.offset.left - cop.left : (that.offset.left - co.left)));
          hoset = Math.abs(that.sizeDiff.height + (that._helper ? that.offset.top - cop.top : (that.offset.top - co.top)));
          if (woset + that.size.width >= that.parentData.width) {
            that.size.width = that.parentData.width - woset;
            if (pRatio) {
              that.size.height = that.size.width / that.aspectRatio;
              continueResize = false;
            }
          }
          if (hoset + that.size.height >= that.parentData.height) {
            that.size.height = that.parentData.height - hoset;
            if (pRatio) {
              that.size.width = that.size.height * that.aspectRatio;
              continueResize = false;
            }
          }
          if (!continueResize) {
            that.position.left = that.prevPosition.left;
            that.position.top = that.prevPosition.top;
            that.size.width = that.prevSize.width;
            that.size.height = that.prevSize.height;
          }
        },
        stop: function() {
          var that = $(this).resizable("instance"),
              o = that.options,
              co = that.containerOffset,
              cop = that.containerPosition,
              ce = that.containerElement,
              helper = $(that.helper),
              ho = helper.offset(),
              w = helper.outerWidth() - that.sizeDiff.width,
              h = helper.outerHeight() - that.sizeDiff.height;
          if (that._helper && !o.animate && (/relative/).test(ce.css("position"))) {
            $(this).css({
              left: ho.left - cop.left - co.left,
              width: w,
              height: h
            });
          }
          if (that._helper && !o.animate && (/static/).test(ce.css("position"))) {
            $(this).css({
              left: ho.left - cop.left - co.left,
              width: w,
              height: h
            });
          }
        }
      });
      $.ui.plugin.add("resizable", "alsoResize", {
        start: function() {
          var that = $(this).resizable("instance"),
              o = that.options,
              _store = function(exp) {
                $(exp).each(function() {
                  var el = $(this);
                  el.data("ui-resizable-alsoresize", {
                    width: parseInt(el.width(), 10),
                    height: parseInt(el.height(), 10),
                    left: parseInt(el.css("left"), 10),
                    top: parseInt(el.css("top"), 10)
                  });
                });
              };
          if (typeof(o.alsoResize) === "object" && !o.alsoResize.parentNode) {
            if (o.alsoResize.length) {
              o.alsoResize = o.alsoResize[0];
              _store(o.alsoResize);
            } else {
              $.each(o.alsoResize, function(exp) {
                _store(exp);
              });
            }
          } else {
            _store(o.alsoResize);
          }
        },
        resize: function(event, ui) {
          var that = $(this).resizable("instance"),
              o = that.options,
              os = that.originalSize,
              op = that.originalPosition,
              delta = {
                height: (that.size.height - os.height) || 0,
                width: (that.size.width - os.width) || 0,
                top: (that.position.top - op.top) || 0,
                left: (that.position.left - op.left) || 0
              },
              _alsoResize = function(exp, c) {
                $(exp).each(function() {
                  var el = $(this),
                      start = $(this).data("ui-resizable-alsoresize"),
                      style = {},
                      css = c && c.length ? c : el.parents(ui.originalElement[0]).length ? ["width", "height"] : ["width", "height", "top", "left"];
                  $.each(css, function(i, prop) {
                    var sum = (start[prop] || 0) + (delta[prop] || 0);
                    if (sum && sum >= 0) {
                      style[prop] = sum || null;
                    }
                  });
                  el.css(style);
                });
              };
          if (typeof(o.alsoResize) === "object" && !o.alsoResize.nodeType) {
            $.each(o.alsoResize, function(exp, c) {
              _alsoResize(exp, c);
            });
          } else {
            _alsoResize(o.alsoResize);
          }
        },
        stop: function() {
          $(this).removeData("resizable-alsoresize");
        }
      });
      $.ui.plugin.add("resizable", "ghost", {
        start: function() {
          var that = $(this).resizable("instance"),
              o = that.options,
              cs = that.size;
          that.ghost = that.originalElement.clone();
          that.ghost.css({
            opacity: 0.25,
            display: "block",
            position: "relative",
            height: cs.height,
            width: cs.width,
            margin: 0,
            left: 0,
            top: 0
          }).addClass("ui-resizable-ghost").addClass(typeof o.ghost === "string" ? o.ghost : "");
          that.ghost.appendTo(that.helper);
        },
        resize: function() {
          var that = $(this).resizable("instance");
          if (that.ghost) {
            that.ghost.css({
              position: "relative",
              height: that.size.height,
              width: that.size.width
            });
          }
        },
        stop: function() {
          var that = $(this).resizable("instance");
          if (that.ghost && that.helper) {
            that.helper.get(0).removeChild(that.ghost.get(0));
          }
        }
      });
      $.ui.plugin.add("resizable", "grid", {resize: function() {
          var outerDimensions,
              that = $(this).resizable("instance"),
              o = that.options,
              cs = that.size,
              os = that.originalSize,
              op = that.originalPosition,
              a = that.axis,
              grid = typeof o.grid === "number" ? [o.grid, o.grid] : o.grid,
              gridX = (grid[0] || 1),
              gridY = (grid[1] || 1),
              ox = Math.round((cs.width - os.width) / gridX) * gridX,
              oy = Math.round((cs.height - os.height) / gridY) * gridY,
              newWidth = os.width + ox,
              newHeight = os.height + oy,
              isMaxWidth = o.maxWidth && (o.maxWidth < newWidth),
              isMaxHeight = o.maxHeight && (o.maxHeight < newHeight),
              isMinWidth = o.minWidth && (o.minWidth > newWidth),
              isMinHeight = o.minHeight && (o.minHeight > newHeight);
          o.grid = grid;
          if (isMinWidth) {
            newWidth += gridX;
          }
          if (isMinHeight) {
            newHeight += gridY;
          }
          if (isMaxWidth) {
            newWidth -= gridX;
          }
          if (isMaxHeight) {
            newHeight -= gridY;
          }
          if (/^(se|s|e)$/.test(a)) {
            that.size.width = newWidth;
            that.size.height = newHeight;
          } else if (/^(ne)$/.test(a)) {
            that.size.width = newWidth;
            that.size.height = newHeight;
            that.position.top = op.top - oy;
          } else if (/^(sw)$/.test(a)) {
            that.size.width = newWidth;
            that.size.height = newHeight;
            that.position.left = op.left - ox;
          } else {
            if (newHeight - gridY <= 0 || newWidth - gridX <= 0) {
              outerDimensions = that._getPaddingPlusBorderDimensions(this);
            }
            if (newHeight - gridY > 0) {
              that.size.height = newHeight;
              that.position.top = op.top - oy;
            } else {
              newHeight = gridY - outerDimensions.height;
              that.size.height = newHeight;
              that.position.top = op.top + os.height - newHeight;
            }
            if (newWidth - gridX > 0) {
              that.size.width = newWidth;
              that.position.left = op.left - ox;
            } else {
              newWidth = gridX - outerDimensions.width;
              that.size.width = newWidth;
              that.position.left = op.left + os.width - newWidth;
            }
          }
        }});
      var resizable = $.ui.resizable;
      var dialog = $.widget("ui.dialog", {
        version: "1.11.3",
        options: {
          appendTo: "body",
          autoOpen: true,
          buttons: [],
          closeOnEscape: true,
          closeText: "Close",
          dialogClass: "",
          draggable: true,
          hide: null,
          height: "auto",
          maxHeight: null,
          maxWidth: null,
          minHeight: 150,
          minWidth: 150,
          modal: false,
          position: {
            my: "center",
            at: "center",
            of: window,
            collision: "fit",
            using: function(pos) {
              var topOffset = $(this).css(pos).offset().top;
              if (topOffset < 0) {
                $(this).css("top", pos.top - topOffset);
              }
            }
          },
          resizable: true,
          show: null,
          title: null,
          width: 300,
          beforeClose: null,
          close: null,
          drag: null,
          dragStart: null,
          dragStop: null,
          focus: null,
          open: null,
          resize: null,
          resizeStart: null,
          resizeStop: null
        },
        sizeRelatedOptions: {
          buttons: true,
          height: true,
          maxHeight: true,
          maxWidth: true,
          minHeight: true,
          minWidth: true,
          width: true
        },
        resizableRelatedOptions: {
          maxHeight: true,
          maxWidth: true,
          minHeight: true,
          minWidth: true
        },
        _create: function() {
          this.originalCss = {
            display: this.element[0].style.display,
            width: this.element[0].style.width,
            minHeight: this.element[0].style.minHeight,
            maxHeight: this.element[0].style.maxHeight,
            height: this.element[0].style.height
          };
          this.originalPosition = {
            parent: this.element.parent(),
            index: this.element.parent().children().index(this.element)
          };
          this.originalTitle = this.element.attr("title");
          this.options.title = this.options.title || this.originalTitle;
          this._createWrapper();
          this.element.show().removeAttr("title").addClass("ui-dialog-content ui-widget-content").appendTo(this.uiDialog);
          this._createTitlebar();
          this._createButtonPane();
          if (this.options.draggable && $.fn.draggable) {
            this._makeDraggable();
          }
          if (this.options.resizable && $.fn.resizable) {
            this._makeResizable();
          }
          this._isOpen = false;
          this._trackFocus();
        },
        _init: function() {
          if (this.options.autoOpen) {
            this.open();
          }
        },
        _appendTo: function() {
          var element = this.options.appendTo;
          if (element && (element.jquery || element.nodeType)) {
            return $(element);
          }
          return this.document.find(element || "body").eq(0);
        },
        _destroy: function() {
          var next,
              originalPosition = this.originalPosition;
          this._destroyOverlay();
          this.element.removeUniqueId().removeClass("ui-dialog-content ui-widget-content").css(this.originalCss).detach();
          this.uiDialog.stop(true, true).remove();
          if (this.originalTitle) {
            this.element.attr("title", this.originalTitle);
          }
          next = originalPosition.parent.children().eq(originalPosition.index);
          if (next.length && next[0] !== this.element[0]) {
            next.before(this.element);
          } else {
            originalPosition.parent.append(this.element);
          }
        },
        widget: function() {
          return this.uiDialog;
        },
        disable: $.noop,
        enable: $.noop,
        close: function(event) {
          var activeElement,
              that = this;
          if (!this._isOpen || this._trigger("beforeClose", event) === false) {
            return ;
          }
          this._isOpen = false;
          this._focusedElement = null;
          this._destroyOverlay();
          this._untrackInstance();
          if (!this.opener.filter(":focusable").focus().length) {
            try {
              activeElement = this.document[0].activeElement;
              if (activeElement && activeElement.nodeName.toLowerCase() !== "body") {
                $(activeElement).blur();
              }
            } catch (error) {}
          }
          this._hide(this.uiDialog, this.options.hide, function() {
            that._trigger("close", event);
          });
        },
        isOpen: function() {
          return this._isOpen;
        },
        moveToTop: function() {
          this._moveToTop();
        },
        _moveToTop: function(event, silent) {
          var moved = false,
              zIndicies = this.uiDialog.siblings(".ui-front:visible").map(function() {
                return +$(this).css("z-index");
              }).get(),
              zIndexMax = Math.max.apply(null, zIndicies);
          if (zIndexMax >= +this.uiDialog.css("z-index")) {
            this.uiDialog.css("z-index", zIndexMax + 1);
            moved = true;
          }
          if (moved && !silent) {
            this._trigger("focus", event);
          }
          return moved;
        },
        open: function() {
          var that = this;
          if (this._isOpen) {
            if (this._moveToTop()) {
              this._focusTabbable();
            }
            return ;
          }
          this._isOpen = true;
          this.opener = $(this.document[0].activeElement);
          this._size();
          this._position();
          this._createOverlay();
          this._moveToTop(null, true);
          if (this.overlay) {
            this.overlay.css("z-index", this.uiDialog.css("z-index") - 1);
          }
          this._show(this.uiDialog, this.options.show, function() {
            that._focusTabbable();
            that._trigger("focus");
          });
          this._makeFocusTarget();
          this._trigger("open");
        },
        _focusTabbable: function() {
          var hasFocus = this._focusedElement;
          if (!hasFocus) {
            hasFocus = this.element.find("[autofocus]");
          }
          if (!hasFocus.length) {
            hasFocus = this.element.find(":tabbable");
          }
          if (!hasFocus.length) {
            hasFocus = this.uiDialogButtonPane.find(":tabbable");
          }
          if (!hasFocus.length) {
            hasFocus = this.uiDialogTitlebarClose.filter(":tabbable");
          }
          if (!hasFocus.length) {
            hasFocus = this.uiDialog;
          }
          hasFocus.eq(0).focus();
        },
        _keepFocus: function(event) {
          function checkFocus() {
            var activeElement = this.document[0].activeElement,
                isActive = this.uiDialog[0] === activeElement || $.contains(this.uiDialog[0], activeElement);
            if (!isActive) {
              this._focusTabbable();
            }
          }
          event.preventDefault();
          checkFocus.call(this);
          this._delay(checkFocus);
        },
        _createWrapper: function() {
          this.uiDialog = $("<div>").addClass("ui-dialog ui-widget ui-widget-content ui-corner-all ui-front " + this.options.dialogClass).hide().attr({
            tabIndex: -1,
            role: "dialog"
          }).appendTo(this._appendTo());
          this._on(this.uiDialog, {
            keydown: function(event) {
              if (this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode && event.keyCode === $.ui.keyCode.ESCAPE) {
                event.preventDefault();
                this.close(event);
                return ;
              }
              if (event.keyCode !== $.ui.keyCode.TAB || event.isDefaultPrevented()) {
                return ;
              }
              var tabbables = this.uiDialog.find(":tabbable"),
                  first = tabbables.filter(":first"),
                  last = tabbables.filter(":last");
              if ((event.target === last[0] || event.target === this.uiDialog[0]) && !event.shiftKey) {
                this._delay(function() {
                  first.focus();
                });
                event.preventDefault();
              } else if ((event.target === first[0] || event.target === this.uiDialog[0]) && event.shiftKey) {
                this._delay(function() {
                  last.focus();
                });
                event.preventDefault();
              }
            },
            mousedown: function(event) {
              if (this._moveToTop(event)) {
                this._focusTabbable();
              }
            }
          });
          if (!this.element.find("[aria-describedby]").length) {
            this.uiDialog.attr({"aria-describedby": this.element.uniqueId().attr("id")});
          }
        },
        _createTitlebar: function() {
          var uiDialogTitle;
          this.uiDialogTitlebar = $("<div>").addClass("ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix").prependTo(this.uiDialog);
          this._on(this.uiDialogTitlebar, {mousedown: function(event) {
              if (!$(event.target).closest(".ui-dialog-titlebar-close")) {
                this.uiDialog.focus();
              }
            }});
          this.uiDialogTitlebarClose = $("<button type='button'></button>").button({
            label: this.options.closeText,
            icons: {primary: "ui-icon-closethick"},
            text: false
          }).addClass("ui-dialog-titlebar-close").appendTo(this.uiDialogTitlebar);
          this._on(this.uiDialogTitlebarClose, {click: function(event) {
              event.preventDefault();
              this.close(event);
            }});
          uiDialogTitle = $("<span>").uniqueId().addClass("ui-dialog-title").prependTo(this.uiDialogTitlebar);
          this._title(uiDialogTitle);
          this.uiDialog.attr({"aria-labelledby": uiDialogTitle.attr("id")});
        },
        _title: function(title) {
          if (!this.options.title) {
            title.html("&#160;");
          }
          title.text(this.options.title);
        },
        _createButtonPane: function() {
          this.uiDialogButtonPane = $("<div>").addClass("ui-dialog-buttonpane ui-widget-content ui-helper-clearfix");
          this.uiButtonSet = $("<div>").addClass("ui-dialog-buttonset").appendTo(this.uiDialogButtonPane);
          this._createButtons();
        },
        _createButtons: function() {
          var that = this,
              buttons = this.options.buttons;
          this.uiDialogButtonPane.remove();
          this.uiButtonSet.empty();
          if ($.isEmptyObject(buttons) || ($.isArray(buttons) && !buttons.length)) {
            this.uiDialog.removeClass("ui-dialog-buttons");
            return ;
          }
          $.each(buttons, function(name, props) {
            var click,
                buttonOptions;
            props = $.isFunction(props) ? {
              click: props,
              text: name
            } : props;
            props = $.extend({type: "button"}, props);
            click = props.click;
            props.click = function() {
              click.apply(that.element[0], arguments);
            };
            buttonOptions = {
              icons: props.icons,
              text: props.showText
            };
            delete props.icons;
            delete props.showText;
            $("<button></button>", props).button(buttonOptions).appendTo(that.uiButtonSet);
          });
          this.uiDialog.addClass("ui-dialog-buttons");
          this.uiDialogButtonPane.appendTo(this.uiDialog);
        },
        _makeDraggable: function() {
          var that = this,
              options = this.options;
          function filteredUi(ui) {
            return {
              position: ui.position,
              offset: ui.offset
            };
          }
          this.uiDialog.draggable({
            cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
            handle: ".ui-dialog-titlebar",
            containment: "document",
            start: function(event, ui) {
              $(this).addClass("ui-dialog-dragging");
              that._blockFrames();
              that._trigger("dragStart", event, filteredUi(ui));
            },
            drag: function(event, ui) {
              that._trigger("drag", event, filteredUi(ui));
            },
            stop: function(event, ui) {
              var left = ui.offset.left - that.document.scrollLeft(),
                  top = ui.offset.top - that.document.scrollTop();
              options.position = {
                my: "left top",
                at: "left" + (left >= 0 ? "+" : "") + left + " " + "top" + (top >= 0 ? "+" : "") + top,
                of: that.window
              };
              $(this).removeClass("ui-dialog-dragging");
              that._unblockFrames();
              that._trigger("dragStop", event, filteredUi(ui));
            }
          });
        },
        _makeResizable: function() {
          var that = this,
              options = this.options,
              handles = options.resizable,
              position = this.uiDialog.css("position"),
              resizeHandles = typeof handles === "string" ? handles : "n,e,s,w,se,sw,ne,nw";
          function filteredUi(ui) {
            return {
              originalPosition: ui.originalPosition,
              originalSize: ui.originalSize,
              position: ui.position,
              size: ui.size
            };
          }
          this.uiDialog.resizable({
            cancel: ".ui-dialog-content",
            containment: "document",
            alsoResize: this.element,
            maxWidth: options.maxWidth,
            maxHeight: options.maxHeight,
            minWidth: options.minWidth,
            minHeight: this._minHeight(),
            handles: resizeHandles,
            start: function(event, ui) {
              $(this).addClass("ui-dialog-resizing");
              that._blockFrames();
              that._trigger("resizeStart", event, filteredUi(ui));
            },
            resize: function(event, ui) {
              that._trigger("resize", event, filteredUi(ui));
            },
            stop: function(event, ui) {
              var offset = that.uiDialog.offset(),
                  left = offset.left - that.document.scrollLeft(),
                  top = offset.top - that.document.scrollTop();
              options.height = that.uiDialog.height();
              options.width = that.uiDialog.width();
              options.position = {
                my: "left top",
                at: "left" + (left >= 0 ? "+" : "") + left + " " + "top" + (top >= 0 ? "+" : "") + top,
                of: that.window
              };
              $(this).removeClass("ui-dialog-resizing");
              that._unblockFrames();
              that._trigger("resizeStop", event, filteredUi(ui));
            }
          }).css("position", position);
        },
        _trackFocus: function() {
          this._on(this.widget(), {focusin: function(event) {
              this._makeFocusTarget();
              this._focusedElement = $(event.target);
            }});
        },
        _makeFocusTarget: function() {
          this._untrackInstance();
          this._trackingInstances().unshift(this);
        },
        _untrackInstance: function() {
          var instances = this._trackingInstances(),
              exists = $.inArray(this, instances);
          if (exists !== -1) {
            instances.splice(exists, 1);
          }
        },
        _trackingInstances: function() {
          var instances = this.document.data("ui-dialog-instances");
          if (!instances) {
            instances = [];
            this.document.data("ui-dialog-instances", instances);
          }
          return instances;
        },
        _minHeight: function() {
          var options = this.options;
          return options.height === "auto" ? options.minHeight : Math.min(options.minHeight, options.height);
        },
        _position: function() {
          var isVisible = this.uiDialog.is(":visible");
          if (!isVisible) {
            this.uiDialog.show();
          }
          this.uiDialog.position(this.options.position);
          if (!isVisible) {
            this.uiDialog.hide();
          }
        },
        _setOptions: function(options) {
          var that = this,
              resize = false,
              resizableOptions = {};
          $.each(options, function(key, value) {
            that._setOption(key, value);
            if (key in that.sizeRelatedOptions) {
              resize = true;
            }
            if (key in that.resizableRelatedOptions) {
              resizableOptions[key] = value;
            }
          });
          if (resize) {
            this._size();
            this._position();
          }
          if (this.uiDialog.is(":data(ui-resizable)")) {
            this.uiDialog.resizable("option", resizableOptions);
          }
        },
        _setOption: function(key, value) {
          var isDraggable,
              isResizable,
              uiDialog = this.uiDialog;
          if (key === "dialogClass") {
            uiDialog.removeClass(this.options.dialogClass).addClass(value);
          }
          if (key === "disabled") {
            return ;
          }
          this._super(key, value);
          if (key === "appendTo") {
            this.uiDialog.appendTo(this._appendTo());
          }
          if (key === "buttons") {
            this._createButtons();
          }
          if (key === "closeText") {
            this.uiDialogTitlebarClose.button({label: "" + value});
          }
          if (key === "draggable") {
            isDraggable = uiDialog.is(":data(ui-draggable)");
            if (isDraggable && !value) {
              uiDialog.draggable("destroy");
            }
            if (!isDraggable && value) {
              this._makeDraggable();
            }
          }
          if (key === "position") {
            this._position();
          }
          if (key === "resizable") {
            isResizable = uiDialog.is(":data(ui-resizable)");
            if (isResizable && !value) {
              uiDialog.resizable("destroy");
            }
            if (isResizable && typeof value === "string") {
              uiDialog.resizable("option", "handles", value);
            }
            if (!isResizable && value !== false) {
              this._makeResizable();
            }
          }
          if (key === "title") {
            this._title(this.uiDialogTitlebar.find(".ui-dialog-title"));
          }
        },
        _size: function() {
          var nonContentHeight,
              minContentHeight,
              maxContentHeight,
              options = this.options;
          this.element.show().css({
            width: "auto",
            minHeight: 0,
            maxHeight: "none",
            height: 0
          });
          if (options.minWidth > options.width) {
            options.width = options.minWidth;
          }
          nonContentHeight = this.uiDialog.css({
            height: "auto",
            width: options.width
          }).outerHeight();
          minContentHeight = Math.max(0, options.minHeight - nonContentHeight);
          maxContentHeight = typeof options.maxHeight === "number" ? Math.max(0, options.maxHeight - nonContentHeight) : "none";
          if (options.height === "auto") {
            this.element.css({
              minHeight: minContentHeight,
              maxHeight: maxContentHeight,
              height: "auto"
            });
          } else {
            this.element.height(Math.max(0, options.height - nonContentHeight));
          }
          if (this.uiDialog.is(":data(ui-resizable)")) {
            this.uiDialog.resizable("option", "minHeight", this._minHeight());
          }
        },
        _blockFrames: function() {
          this.iframeBlocks = this.document.find("iframe").map(function() {
            var iframe = $(this);
            return $("<div>").css({
              position: "absolute",
              width: iframe.outerWidth(),
              height: iframe.outerHeight()
            }).appendTo(iframe.parent()).offset(iframe.offset())[0];
          });
        },
        _unblockFrames: function() {
          if (this.iframeBlocks) {
            this.iframeBlocks.remove();
            delete this.iframeBlocks;
          }
        },
        _allowInteraction: function(event) {
          if ($(event.target).closest(".ui-dialog").length) {
            return true;
          }
          return !!$(event.target).closest(".ui-datepicker").length;
        },
        _createOverlay: function() {
          if (!this.options.modal) {
            return ;
          }
          var isOpening = true;
          this._delay(function() {
            isOpening = false;
          });
          if (!this.document.data("ui-dialog-overlays")) {
            this._on(this.document, {focusin: function(event) {
                if (isOpening) {
                  return ;
                }
                if (!this._allowInteraction(event)) {
                  event.preventDefault();
                  this._trackingInstances()[0]._focusTabbable();
                }
              }});
          }
          this.overlay = $("<div>").addClass("ui-widget-overlay ui-front").appendTo(this._appendTo());
          this._on(this.overlay, {mousedown: "_keepFocus"});
          this.document.data("ui-dialog-overlays", (this.document.data("ui-dialog-overlays") || 0) + 1);
        },
        _destroyOverlay: function() {
          if (!this.options.modal) {
            return ;
          }
          if (this.overlay) {
            var overlays = this.document.data("ui-dialog-overlays") - 1;
            if (!overlays) {
              this.document.unbind("focusin").removeData("ui-dialog-overlays");
            } else {
              this.document.data("ui-dialog-overlays", overlays);
            }
            this.overlay.remove();
            this.overlay = null;
          }
        }
      });
      $.widget("ui.droppable", {
        version: "1.11.3",
        widgetEventPrefix: "drop",
        options: {
          accept: "*",
          activeClass: false,
          addClasses: true,
          greedy: false,
          hoverClass: false,
          scope: "default",
          tolerance: "intersect",
          activate: null,
          deactivate: null,
          drop: null,
          out: null,
          over: null
        },
        _create: function() {
          var proportions,
              o = this.options,
              accept = o.accept;
          this.isover = false;
          this.isout = true;
          this.accept = $.isFunction(accept) ? accept : function(d) {
            return d.is(accept);
          };
          this.proportions = function() {
            if (arguments.length) {
              proportions = arguments[0];
            } else {
              return proportions ? proportions : proportions = {
                width: this.element[0].offsetWidth,
                height: this.element[0].offsetHeight
              };
            }
          };
          this._addToManager(o.scope);
          o.addClasses && this.element.addClass("ui-droppable");
        },
        _addToManager: function(scope) {
          $.ui.ddmanager.droppables[scope] = $.ui.ddmanager.droppables[scope] || [];
          $.ui.ddmanager.droppables[scope].push(this);
        },
        _splice: function(drop) {
          var i = 0;
          for (; i < drop.length; i++) {
            if (drop[i] === this) {
              drop.splice(i, 1);
            }
          }
        },
        _destroy: function() {
          var drop = $.ui.ddmanager.droppables[this.options.scope];
          this._splice(drop);
          this.element.removeClass("ui-droppable ui-droppable-disabled");
        },
        _setOption: function(key, value) {
          if (key === "accept") {
            this.accept = $.isFunction(value) ? value : function(d) {
              return d.is(value);
            };
          } else if (key === "scope") {
            var drop = $.ui.ddmanager.droppables[this.options.scope];
            this._splice(drop);
            this._addToManager(value);
          }
          this._super(key, value);
        },
        _activate: function(event) {
          var draggable = $.ui.ddmanager.current;
          if (this.options.activeClass) {
            this.element.addClass(this.options.activeClass);
          }
          if (draggable) {
            this._trigger("activate", event, this.ui(draggable));
          }
        },
        _deactivate: function(event) {
          var draggable = $.ui.ddmanager.current;
          if (this.options.activeClass) {
            this.element.removeClass(this.options.activeClass);
          }
          if (draggable) {
            this._trigger("deactivate", event, this.ui(draggable));
          }
        },
        _over: function(event) {
          var draggable = $.ui.ddmanager.current;
          if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
            return ;
          }
          if (this.accept.call(this.element[0], (draggable.currentItem || draggable.element))) {
            if (this.options.hoverClass) {
              this.element.addClass(this.options.hoverClass);
            }
            this._trigger("over", event, this.ui(draggable));
          }
        },
        _out: function(event) {
          var draggable = $.ui.ddmanager.current;
          if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
            return ;
          }
          if (this.accept.call(this.element[0], (draggable.currentItem || draggable.element))) {
            if (this.options.hoverClass) {
              this.element.removeClass(this.options.hoverClass);
            }
            this._trigger("out", event, this.ui(draggable));
          }
        },
        _drop: function(event, custom) {
          var draggable = custom || $.ui.ddmanager.current,
              childrenIntersection = false;
          if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
            return false;
          }
          this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function() {
            var inst = $(this).droppable("instance");
            if (inst.options.greedy && !inst.options.disabled && inst.options.scope === draggable.options.scope && inst.accept.call(inst.element[0], (draggable.currentItem || draggable.element)) && $.ui.intersect(draggable, $.extend(inst, {offset: inst.element.offset()}), inst.options.tolerance, event)) {
              childrenIntersection = true;
              return false;
            }
          });
          if (childrenIntersection) {
            return false;
          }
          if (this.accept.call(this.element[0], (draggable.currentItem || draggable.element))) {
            if (this.options.activeClass) {
              this.element.removeClass(this.options.activeClass);
            }
            if (this.options.hoverClass) {
              this.element.removeClass(this.options.hoverClass);
            }
            this._trigger("drop", event, this.ui(draggable));
            return this.element;
          }
          return false;
        },
        ui: function(c) {
          return {
            draggable: (c.currentItem || c.element),
            helper: c.helper,
            position: c.position,
            offset: c.positionAbs
          };
        }
      });
      $.ui.intersect = (function() {
        function isOverAxis(x, reference, size) {
          return (x >= reference) && (x < (reference + size));
        }
        return function(draggable, droppable, toleranceMode, event) {
          if (!droppable.offset) {
            return false;
          }
          var x1 = (draggable.positionAbs || draggable.position.absolute).left + draggable.margins.left,
              y1 = (draggable.positionAbs || draggable.position.absolute).top + draggable.margins.top,
              x2 = x1 + draggable.helperProportions.width,
              y2 = y1 + draggable.helperProportions.height,
              l = droppable.offset.left,
              t = droppable.offset.top,
              r = l + droppable.proportions().width,
              b = t + droppable.proportions().height;
          switch (toleranceMode) {
            case "fit":
              return (l <= x1 && x2 <= r && t <= y1 && y2 <= b);
            case "intersect":
              return (l < x1 + (draggable.helperProportions.width / 2) && x2 - (draggable.helperProportions.width / 2) < r && t < y1 + (draggable.helperProportions.height / 2) && y2 - (draggable.helperProportions.height / 2) < b);
            case "pointer":
              return isOverAxis(event.pageY, t, droppable.proportions().height) && isOverAxis(event.pageX, l, droppable.proportions().width);
            case "touch":
              return ((y1 >= t && y1 <= b) || (y2 >= t && y2 <= b) || (y1 < t && y2 > b)) && ((x1 >= l && x1 <= r) || (x2 >= l && x2 <= r) || (x1 < l && x2 > r));
            default:
              return false;
          }
        };
      })();
      $.ui.ddmanager = {
        current: null,
        droppables: {"default": []},
        prepareOffsets: function(t, event) {
          var i,
              j,
              m = $.ui.ddmanager.droppables[t.options.scope] || [],
              type = event ? event.type : null,
              list = (t.currentItem || t.element).find(":data(ui-droppable)").addBack();
          droppablesLoop: for (i = 0; i < m.length; i++) {
            if (m[i].options.disabled || (t && !m[i].accept.call(m[i].element[0], (t.currentItem || t.element)))) {
              continue;
            }
            for (j = 0; j < list.length; j++) {
              if (list[j] === m[i].element[0]) {
                m[i].proportions().height = 0;
                continue droppablesLoop;
              }
            }
            m[i].visible = m[i].element.css("display") !== "none";
            if (!m[i].visible) {
              continue;
            }
            if (type === "mousedown") {
              m[i]._activate.call(m[i], event);
            }
            m[i].offset = m[i].element.offset();
            m[i].proportions({
              width: m[i].element[0].offsetWidth,
              height: m[i].element[0].offsetHeight
            });
          }
        },
        drop: function(draggable, event) {
          var dropped = false;
          $.each(($.ui.ddmanager.droppables[draggable.options.scope] || []).slice(), function() {
            if (!this.options) {
              return ;
            }
            if (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance, event)) {
              dropped = this._drop.call(this, event) || dropped;
            }
            if (!this.options.disabled && this.visible && this.accept.call(this.element[0], (draggable.currentItem || draggable.element))) {
              this.isout = true;
              this.isover = false;
              this._deactivate.call(this, event);
            }
          });
          return dropped;
        },
        dragStart: function(draggable, event) {
          draggable.element.parentsUntil("body").bind("scroll.droppable", function() {
            if (!draggable.options.refreshPositions) {
              $.ui.ddmanager.prepareOffsets(draggable, event);
            }
          });
        },
        drag: function(draggable, event) {
          if (draggable.options.refreshPositions) {
            $.ui.ddmanager.prepareOffsets(draggable, event);
          }
          $.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {
            if (this.options.disabled || this.greedyChild || !this.visible) {
              return ;
            }
            var parentInstance,
                scope,
                parent,
                intersects = $.ui.intersect(draggable, this, this.options.tolerance, event),
                c = !intersects && this.isover ? "isout" : (intersects && !this.isover ? "isover" : null);
            if (!c) {
              return ;
            }
            if (this.options.greedy) {
              scope = this.options.scope;
              parent = this.element.parents(":data(ui-droppable)").filter(function() {
                return $(this).droppable("instance").options.scope === scope;
              });
              if (parent.length) {
                parentInstance = $(parent[0]).droppable("instance");
                parentInstance.greedyChild = (c === "isover");
              }
            }
            if (parentInstance && c === "isover") {
              parentInstance.isover = false;
              parentInstance.isout = true;
              parentInstance._out.call(parentInstance, event);
            }
            this[c] = true;
            this[c === "isout" ? "isover" : "isout"] = false;
            this[c === "isover" ? "_over" : "_out"].call(this, event);
            if (parentInstance && c === "isout") {
              parentInstance.isout = false;
              parentInstance.isover = true;
              parentInstance._over.call(parentInstance, event);
            }
          });
        },
        dragStop: function(draggable, event) {
          draggable.element.parentsUntil("body").unbind("scroll.droppable");
          if (!draggable.options.refreshPositions) {
            $.ui.ddmanager.prepareOffsets(draggable, event);
          }
        }
      };
      var droppable = $.ui.droppable;
      var dataSpace = "ui-effects-",
          jQuery = $;
      $.effects = {effect: {}};
      (function(jQuery, undefined) {
        var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",
            rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,
            stringParsers = [{
              re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
              parse: function(execResult) {
                return [execResult[1], execResult[2], execResult[3], execResult[4]];
              }
            }, {
              re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
              parse: function(execResult) {
                return [execResult[1] * 2.55, execResult[2] * 2.55, execResult[3] * 2.55, execResult[4]];
              }
            }, {
              re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
              parse: function(execResult) {
                return [parseInt(execResult[1], 16), parseInt(execResult[2], 16), parseInt(execResult[3], 16)];
              }
            }, {
              re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
              parse: function(execResult) {
                return [parseInt(execResult[1] + execResult[1], 16), parseInt(execResult[2] + execResult[2], 16), parseInt(execResult[3] + execResult[3], 16)];
              }
            }, {
              re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
              space: "hsla",
              parse: function(execResult) {
                return [execResult[1], execResult[2] / 100, execResult[3] / 100, execResult[4]];
              }
            }],
            color = jQuery.Color = function(color, green, blue, alpha) {
              return new jQuery.Color.fn.parse(color, green, blue, alpha);
            },
            spaces = {
              rgba: {props: {
                  red: {
                    idx: 0,
                    type: "byte"
                  },
                  green: {
                    idx: 1,
                    type: "byte"
                  },
                  blue: {
                    idx: 2,
                    type: "byte"
                  }
                }},
              hsla: {props: {
                  hue: {
                    idx: 0,
                    type: "degrees"
                  },
                  saturation: {
                    idx: 1,
                    type: "percent"
                  },
                  lightness: {
                    idx: 2,
                    type: "percent"
                  }
                }}
            },
            propTypes = {
              "byte": {
                floor: true,
                max: 255
              },
              "percent": {max: 1},
              "degrees": {
                mod: 360,
                floor: true
              }
            },
            support = color.support = {},
            supportElem = jQuery("<p>")[0],
            colors,
            each = jQuery.each;
        supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
        support.rgba = supportElem.style.backgroundColor.indexOf("rgba") > -1;
        each(spaces, function(spaceName, space) {
          space.cache = "_" + spaceName;
          space.props.alpha = {
            idx: 3,
            type: "percent",
            def: 1
          };
        });
        function clamp(value, prop, allowEmpty) {
          var type = propTypes[prop.type] || {};
          if (value == null) {
            return (allowEmpty || !prop.def) ? null : prop.def;
          }
          value = type.floor ? ~~value : parseFloat(value);
          if (isNaN(value)) {
            return prop.def;
          }
          if (type.mod) {
            return (value + type.mod) % type.mod;
          }
          return 0 > value ? 0 : type.max < value ? type.max : value;
        }
        function stringParse(string) {
          var inst = color(),
              rgba = inst._rgba = [];
          string = string.toLowerCase();
          each(stringParsers, function(i, parser) {
            var parsed,
                match = parser.re.exec(string),
                values = match && parser.parse(match),
                spaceName = parser.space || "rgba";
            if (values) {
              parsed = inst[spaceName](values);
              inst[spaces[spaceName].cache] = parsed[spaces[spaceName].cache];
              rgba = inst._rgba = parsed._rgba;
              return false;
            }
          });
          if (rgba.length) {
            if (rgba.join() === "0,0,0,0") {
              jQuery.extend(rgba, colors.transparent);
            }
            return inst;
          }
          return colors[string];
        }
        color.fn = jQuery.extend(color.prototype, {
          parse: function(red, green, blue, alpha) {
            if (red === undefined) {
              this._rgba = [null, null, null, null];
              return this;
            }
            if (red.jquery || red.nodeType) {
              red = jQuery(red).css(green);
              green = undefined;
            }
            var inst = this,
                type = jQuery.type(red),
                rgba = this._rgba = [];
            if (green !== undefined) {
              red = [red, green, blue, alpha];
              type = "array";
            }
            if (type === "string") {
              return this.parse(stringParse(red) || colors._default);
            }
            if (type === "array") {
              each(spaces.rgba.props, function(key, prop) {
                rgba[prop.idx] = clamp(red[prop.idx], prop);
              });
              return this;
            }
            if (type === "object") {
              if (red instanceof color) {
                each(spaces, function(spaceName, space) {
                  if (red[space.cache]) {
                    inst[space.cache] = red[space.cache].slice();
                  }
                });
              } else {
                each(spaces, function(spaceName, space) {
                  var cache = space.cache;
                  each(space.props, function(key, prop) {
                    if (!inst[cache] && space.to) {
                      if (key === "alpha" || red[key] == null) {
                        return ;
                      }
                      inst[cache] = space.to(inst._rgba);
                    }
                    inst[cache][prop.idx] = clamp(red[key], prop, true);
                  });
                  if (inst[cache] && jQuery.inArray(null, inst[cache].slice(0, 3)) < 0) {
                    inst[cache][3] = 1;
                    if (space.from) {
                      inst._rgba = space.from(inst[cache]);
                    }
                  }
                });
              }
              return this;
            }
          },
          is: function(compare) {
            var is = color(compare),
                same = true,
                inst = this;
            each(spaces, function(_, space) {
              var localCache,
                  isCache = is[space.cache];
              if (isCache) {
                localCache = inst[space.cache] || space.to && space.to(inst._rgba) || [];
                each(space.props, function(_, prop) {
                  if (isCache[prop.idx] != null) {
                    same = (isCache[prop.idx] === localCache[prop.idx]);
                    return same;
                  }
                });
              }
              return same;
            });
            return same;
          },
          _space: function() {
            var used = [],
                inst = this;
            each(spaces, function(spaceName, space) {
              if (inst[space.cache]) {
                used.push(spaceName);
              }
            });
            return used.pop();
          },
          transition: function(other, distance) {
            var end = color(other),
                spaceName = end._space(),
                space = spaces[spaceName],
                startColor = this.alpha() === 0 ? color("transparent") : this,
                start = startColor[space.cache] || space.to(startColor._rgba),
                result = start.slice();
            end = end[space.cache];
            each(space.props, function(key, prop) {
              var index = prop.idx,
                  startValue = start[index],
                  endValue = end[index],
                  type = propTypes[prop.type] || {};
              if (endValue === null) {
                return ;
              }
              if (startValue === null) {
                result[index] = endValue;
              } else {
                if (type.mod) {
                  if (endValue - startValue > type.mod / 2) {
                    startValue += type.mod;
                  } else if (startValue - endValue > type.mod / 2) {
                    startValue -= type.mod;
                  }
                }
                result[index] = clamp((endValue - startValue) * distance + startValue, prop);
              }
            });
            return this[spaceName](result);
          },
          blend: function(opaque) {
            if (this._rgba[3] === 1) {
              return this;
            }
            var rgb = this._rgba.slice(),
                a = rgb.pop(),
                blend = color(opaque)._rgba;
            return color(jQuery.map(rgb, function(v, i) {
              return (1 - a) * blend[i] + a * v;
            }));
          },
          toRgbaString: function() {
            var prefix = "rgba(",
                rgba = jQuery.map(this._rgba, function(v, i) {
                  return v == null ? (i > 2 ? 1 : 0) : v;
                });
            if (rgba[3] === 1) {
              rgba.pop();
              prefix = "rgb(";
            }
            return prefix + rgba.join() + ")";
          },
          toHslaString: function() {
            var prefix = "hsla(",
                hsla = jQuery.map(this.hsla(), function(v, i) {
                  if (v == null) {
                    v = i > 2 ? 1 : 0;
                  }
                  if (i && i < 3) {
                    v = Math.round(v * 100) + "%";
                  }
                  return v;
                });
            if (hsla[3] === 1) {
              hsla.pop();
              prefix = "hsl(";
            }
            return prefix + hsla.join() + ")";
          },
          toHexString: function(includeAlpha) {
            var rgba = this._rgba.slice(),
                alpha = rgba.pop();
            if (includeAlpha) {
              rgba.push(~~(alpha * 255));
            }
            return "#" + jQuery.map(rgba, function(v) {
              v = (v || 0).toString(16);
              return v.length === 1 ? "0" + v : v;
            }).join("");
          },
          toString: function() {
            return this._rgba[3] === 0 ? "transparent" : this.toRgbaString();
          }
        });
        color.fn.parse.prototype = color.fn;
        function hue2rgb(p, q, h) {
          h = (h + 1) % 1;
          if (h * 6 < 1) {
            return p + (q - p) * h * 6;
          }
          if (h * 2 < 1) {
            return q;
          }
          if (h * 3 < 2) {
            return p + (q - p) * ((2 / 3) - h) * 6;
          }
          return p;
        }
        spaces.hsla.to = function(rgba) {
          if (rgba[0] == null || rgba[1] == null || rgba[2] == null) {
            return [null, null, null, rgba[3]];
          }
          var r = rgba[0] / 255,
              g = rgba[1] / 255,
              b = rgba[2] / 255,
              a = rgba[3],
              max = Math.max(r, g, b),
              min = Math.min(r, g, b),
              diff = max - min,
              add = max + min,
              l = add * 0.5,
              h,
              s;
          if (min === max) {
            h = 0;
          } else if (r === max) {
            h = (60 * (g - b) / diff) + 360;
          } else if (g === max) {
            h = (60 * (b - r) / diff) + 120;
          } else {
            h = (60 * (r - g) / diff) + 240;
          }
          if (diff === 0) {
            s = 0;
          } else if (l <= 0.5) {
            s = diff / add;
          } else {
            s = diff / (2 - add);
          }
          return [Math.round(h) % 360, s, l, a == null ? 1 : a];
        };
        spaces.hsla.from = function(hsla) {
          if (hsla[0] == null || hsla[1] == null || hsla[2] == null) {
            return [null, null, null, hsla[3]];
          }
          var h = hsla[0] / 360,
              s = hsla[1],
              l = hsla[2],
              a = hsla[3],
              q = l <= 0.5 ? l * (1 + s) : l + s - l * s,
              p = 2 * l - q;
          return [Math.round(hue2rgb(p, q, h + (1 / 3)) * 255), Math.round(hue2rgb(p, q, h) * 255), Math.round(hue2rgb(p, q, h - (1 / 3)) * 255), a];
        };
        each(spaces, function(spaceName, space) {
          var props = space.props,
              cache = space.cache,
              to = space.to,
              from = space.from;
          color.fn[spaceName] = function(value) {
            if (to && !this[cache]) {
              this[cache] = to(this._rgba);
            }
            if (value === undefined) {
              return this[cache].slice();
            }
            var ret,
                type = jQuery.type(value),
                arr = (type === "array" || type === "object") ? value : arguments,
                local = this[cache].slice();
            each(props, function(key, prop) {
              var val = arr[type === "object" ? key : prop.idx];
              if (val == null) {
                val = local[prop.idx];
              }
              local[prop.idx] = clamp(val, prop);
            });
            if (from) {
              ret = color(from(local));
              ret[cache] = local;
              return ret;
            } else {
              return color(local);
            }
          };
          each(props, function(key, prop) {
            if (color.fn[key]) {
              return ;
            }
            color.fn[key] = function(value) {
              var vtype = jQuery.type(value),
                  fn = (key === "alpha" ? (this._hsla ? "hsla" : "rgba") : spaceName),
                  local = this[fn](),
                  cur = local[prop.idx],
                  match;
              if (vtype === "undefined") {
                return cur;
              }
              if (vtype === "function") {
                value = value.call(this, cur);
                vtype = jQuery.type(value);
              }
              if (value == null && prop.empty) {
                return this;
              }
              if (vtype === "string") {
                match = rplusequals.exec(value);
                if (match) {
                  value = cur + parseFloat(match[2]) * (match[1] === "+" ? 1 : -1);
                }
              }
              local[prop.idx] = value;
              return this[fn](local);
            };
          });
        });
        color.hook = function(hook) {
          var hooks = hook.split(" ");
          each(hooks, function(i, hook) {
            jQuery.cssHooks[hook] = {set: function(elem, value) {
                var parsed,
                    curElem,
                    backgroundColor = "";
                if (value !== "transparent" && (jQuery.type(value) !== "string" || (parsed = stringParse(value)))) {
                  value = color(parsed || value);
                  if (!support.rgba && value._rgba[3] !== 1) {
                    curElem = hook === "backgroundColor" ? elem.parentNode : elem;
                    while ((backgroundColor === "" || backgroundColor === "transparent") && curElem && curElem.style) {
                      try {
                        backgroundColor = jQuery.css(curElem, "backgroundColor");
                        curElem = curElem.parentNode;
                      } catch (e) {}
                    }
                    value = value.blend(backgroundColor && backgroundColor !== "transparent" ? backgroundColor : "_default");
                  }
                  value = value.toRgbaString();
                }
                try {
                  elem.style[hook] = value;
                } catch (e) {}
              }};
            jQuery.fx.step[hook] = function(fx) {
              if (!fx.colorInit) {
                fx.start = color(fx.elem, hook);
                fx.end = color(fx.end);
                fx.colorInit = true;
              }
              jQuery.cssHooks[hook].set(fx.elem, fx.start.transition(fx.end, fx.pos));
            };
          });
        };
        color.hook(stepHooks);
        jQuery.cssHooks.borderColor = {expand: function(value) {
            var expanded = {};
            each(["Top", "Right", "Bottom", "Left"], function(i, part) {
              expanded["border" + part + "Color"] = value;
            });
            return expanded;
          }};
        colors = jQuery.Color.names = {
          aqua: "#00ffff",
          black: "#000000",
          blue: "#0000ff",
          fuchsia: "#ff00ff",
          gray: "#808080",
          green: "#008000",
          lime: "#00ff00",
          maroon: "#800000",
          navy: "#000080",
          olive: "#808000",
          purple: "#800080",
          red: "#ff0000",
          silver: "#c0c0c0",
          teal: "#008080",
          white: "#ffffff",
          yellow: "#ffff00",
          transparent: [null, null, null, 0],
          _default: "#ffffff"
        };
      })(jQuery);
      (function() {
        var classAnimationActions = ["add", "remove", "toggle"],
            shorthandStyles = {
              border: 1,
              borderBottom: 1,
              borderColor: 1,
              borderLeft: 1,
              borderRight: 1,
              borderTop: 1,
              borderWidth: 1,
              margin: 1,
              padding: 1
            };
        $.each(["borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle"], function(_, prop) {
          $.fx.step[prop] = function(fx) {
            if (fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr) {
              jQuery.style(fx.elem, prop, fx.end);
              fx.setAttr = true;
            }
          };
        });
        function getElementStyles(elem) {
          var key,
              len,
              style = elem.ownerDocument.defaultView ? elem.ownerDocument.defaultView.getComputedStyle(elem, null) : elem.currentStyle,
              styles = {};
          if (style && style.length && style[0] && style[style[0]]) {
            len = style.length;
            while (len--) {
              key = style[len];
              if (typeof style[key] === "string") {
                styles[$.camelCase(key)] = style[key];
              }
            }
          } else {
            for (key in style) {
              if (typeof style[key] === "string") {
                styles[key] = style[key];
              }
            }
          }
          return styles;
        }
        function styleDifference(oldStyle, newStyle) {
          var diff = {},
              name,
              value;
          for (name in newStyle) {
            value = newStyle[name];
            if (oldStyle[name] !== value) {
              if (!shorthandStyles[name]) {
                if ($.fx.step[name] || !isNaN(parseFloat(value))) {
                  diff[name] = value;
                }
              }
            }
          }
          return diff;
        }
        if (!$.fn.addBack) {
          $.fn.addBack = function(selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
          };
        }
        $.effects.animateClass = function(value, duration, easing, callback) {
          var o = $.speed(duration, easing, callback);
          return this.queue(function() {
            var animated = $(this),
                baseClass = animated.attr("class") || "",
                applyClassChange,
                allAnimations = o.children ? animated.find("*").addBack() : animated;
            allAnimations = allAnimations.map(function() {
              var el = $(this);
              return {
                el: el,
                start: getElementStyles(this)
              };
            });
            applyClassChange = function() {
              $.each(classAnimationActions, function(i, action) {
                if (value[action]) {
                  animated[action + "Class"](value[action]);
                }
              });
            };
            applyClassChange();
            allAnimations = allAnimations.map(function() {
              this.end = getElementStyles(this.el[0]);
              this.diff = styleDifference(this.start, this.end);
              return this;
            });
            animated.attr("class", baseClass);
            allAnimations = allAnimations.map(function() {
              var styleInfo = this,
                  dfd = $.Deferred(),
                  opts = $.extend({}, o, {
                    queue: false,
                    complete: function() {
                      dfd.resolve(styleInfo);
                    }
                  });
              this.el.animate(this.diff, opts);
              return dfd.promise();
            });
            $.when.apply($, allAnimations.get()).done(function() {
              applyClassChange();
              $.each(arguments, function() {
                var el = this.el;
                $.each(this.diff, function(key) {
                  el.css(key, "");
                });
              });
              o.complete.call(animated[0]);
            });
          });
        };
        $.fn.extend({
          addClass: (function(orig) {
            return function(classNames, speed, easing, callback) {
              return speed ? $.effects.animateClass.call(this, {add: classNames}, speed, easing, callback) : orig.apply(this, arguments);
            };
          })($.fn.addClass),
          removeClass: (function(orig) {
            return function(classNames, speed, easing, callback) {
              return arguments.length > 1 ? $.effects.animateClass.call(this, {remove: classNames}, speed, easing, callback) : orig.apply(this, arguments);
            };
          })($.fn.removeClass),
          toggleClass: (function(orig) {
            return function(classNames, force, speed, easing, callback) {
              if (typeof force === "boolean" || force === undefined) {
                if (!speed) {
                  return orig.apply(this, arguments);
                } else {
                  return $.effects.animateClass.call(this, (force ? {add: classNames} : {remove: classNames}), speed, easing, callback);
                }
              } else {
                return $.effects.animateClass.call(this, {toggle: classNames}, force, speed, easing);
              }
            };
          })($.fn.toggleClass),
          switchClass: function(remove, add, speed, easing, callback) {
            return $.effects.animateClass.call(this, {
              add: add,
              remove: remove
            }, speed, easing, callback);
          }
        });
      })();
      (function() {
        $.extend($.effects, {
          version: "1.11.3",
          save: function(element, set) {
            for (var i = 0; i < set.length; i++) {
              if (set[i] !== null) {
                element.data(dataSpace + set[i], element[0].style[set[i]]);
              }
            }
          },
          restore: function(element, set) {
            var val,
                i;
            for (i = 0; i < set.length; i++) {
              if (set[i] !== null) {
                val = element.data(dataSpace + set[i]);
                if (val === undefined) {
                  val = "";
                }
                element.css(set[i], val);
              }
            }
          },
          setMode: function(el, mode) {
            if (mode === "toggle") {
              mode = el.is(":hidden") ? "show" : "hide";
            }
            return mode;
          },
          getBaseline: function(origin, original) {
            var y,
                x;
            switch (origin[0]) {
              case "top":
                y = 0;
                break;
              case "middle":
                y = 0.5;
                break;
              case "bottom":
                y = 1;
                break;
              default:
                y = origin[0] / original.height;
            }
            switch (origin[1]) {
              case "left":
                x = 0;
                break;
              case "center":
                x = 0.5;
                break;
              case "right":
                x = 1;
                break;
              default:
                x = origin[1] / original.width;
            }
            return {
              x: x,
              y: y
            };
          },
          createWrapper: function(element) {
            if (element.parent().is(".ui-effects-wrapper")) {
              return element.parent();
            }
            var props = {
              width: element.outerWidth(true),
              height: element.outerHeight(true),
              "float": element.css("float")
            },
                wrapper = $("<div></div>").addClass("ui-effects-wrapper").css({
                  fontSize: "100%",
                  background: "transparent",
                  border: "none",
                  margin: 0,
                  padding: 0
                }),
                size = {
                  width: element.width(),
                  height: element.height()
                },
                active = document.activeElement;
            try {
              active.id;
            } catch (e) {
              active = document.body;
            }
            element.wrap(wrapper);
            if (element[0] === active || $.contains(element[0], active)) {
              $(active).focus();
            }
            wrapper = element.parent();
            if (element.css("position") === "static") {
              wrapper.css({position: "relative"});
              element.css({position: "relative"});
            } else {
              $.extend(props, {
                position: element.css("position"),
                zIndex: element.css("z-index")
              });
              $.each(["top", "left", "bottom", "right"], function(i, pos) {
                props[pos] = element.css(pos);
                if (isNaN(parseInt(props[pos], 10))) {
                  props[pos] = "auto";
                }
              });
              element.css({
                position: "relative",
                top: 0,
                left: 0,
                right: "auto",
                bottom: "auto"
              });
            }
            element.css(size);
            return wrapper.css(props).show();
          },
          removeWrapper: function(element) {
            var active = document.activeElement;
            if (element.parent().is(".ui-effects-wrapper")) {
              element.parent().replaceWith(element);
              if (element[0] === active || $.contains(element[0], active)) {
                $(active).focus();
              }
            }
            return element;
          },
          setTransition: function(element, list, factor, value) {
            value = value || {};
            $.each(list, function(i, x) {
              var unit = element.cssUnit(x);
              if (unit[0] > 0) {
                value[x] = unit[0] * factor + unit[1];
              }
            });
            return value;
          }
        });
        function _normalizeArguments(effect, options, speed, callback) {
          if ($.isPlainObject(effect)) {
            options = effect;
            effect = effect.effect;
          }
          effect = {effect: effect};
          if (options == null) {
            options = {};
          }
          if ($.isFunction(options)) {
            callback = options;
            speed = null;
            options = {};
          }
          if (typeof options === "number" || $.fx.speeds[options]) {
            callback = speed;
            speed = options;
            options = {};
          }
          if ($.isFunction(speed)) {
            callback = speed;
            speed = null;
          }
          if (options) {
            $.extend(effect, options);
          }
          speed = speed || options.duration;
          effect.duration = $.fx.off ? 0 : typeof speed === "number" ? speed : speed in $.fx.speeds ? $.fx.speeds[speed] : $.fx.speeds._default;
          effect.complete = callback || options.complete;
          return effect;
        }
        function standardAnimationOption(option) {
          if (!option || typeof option === "number" || $.fx.speeds[option]) {
            return true;
          }
          if (typeof option === "string" && !$.effects.effect[option]) {
            return true;
          }
          if ($.isFunction(option)) {
            return true;
          }
          if (typeof option === "object" && !option.effect) {
            return true;
          }
          return false;
        }
        $.fn.extend({
          effect: function() {
            var args = _normalizeArguments.apply(this, arguments),
                mode = args.mode,
                queue = args.queue,
                effectMethod = $.effects.effect[args.effect];
            if ($.fx.off || !effectMethod) {
              if (mode) {
                return this[mode](args.duration, args.complete);
              } else {
                return this.each(function() {
                  if (args.complete) {
                    args.complete.call(this);
                  }
                });
              }
            }
            function run(next) {
              var elem = $(this),
                  complete = args.complete,
                  mode = args.mode;
              function done() {
                if ($.isFunction(complete)) {
                  complete.call(elem[0]);
                }
                if ($.isFunction(next)) {
                  next();
                }
              }
              if (elem.is(":hidden") ? mode === "hide" : mode === "show") {
                elem[mode]();
                done();
              } else {
                effectMethod.call(elem[0], args, done);
              }
            }
            return queue === false ? this.each(run) : this.queue(queue || "fx", run);
          },
          show: (function(orig) {
            return function(option) {
              if (standardAnimationOption(option)) {
                return orig.apply(this, arguments);
              } else {
                var args = _normalizeArguments.apply(this, arguments);
                args.mode = "show";
                return this.effect.call(this, args);
              }
            };
          })($.fn.show),
          hide: (function(orig) {
            return function(option) {
              if (standardAnimationOption(option)) {
                return orig.apply(this, arguments);
              } else {
                var args = _normalizeArguments.apply(this, arguments);
                args.mode = "hide";
                return this.effect.call(this, args);
              }
            };
          })($.fn.hide),
          toggle: (function(orig) {
            return function(option) {
              if (standardAnimationOption(option) || typeof option === "boolean") {
                return orig.apply(this, arguments);
              } else {
                var args = _normalizeArguments.apply(this, arguments);
                args.mode = "toggle";
                return this.effect.call(this, args);
              }
            };
          })($.fn.toggle),
          cssUnit: function(key) {
            var style = this.css(key),
                val = [];
            $.each(["em", "px", "%", "pt"], function(i, unit) {
              if (style.indexOf(unit) > 0) {
                val = [parseFloat(style), unit];
              }
            });
            return val;
          }
        });
      })();
      (function() {
        var baseEasings = {};
        $.each(["Quad", "Cubic", "Quart", "Quint", "Expo"], function(i, name) {
          baseEasings[name] = function(p) {
            return Math.pow(p, i + 2);
          };
        });
        $.extend(baseEasings, {
          Sine: function(p) {
            return 1 - Math.cos(p * Math.PI / 2);
          },
          Circ: function(p) {
            return 1 - Math.sqrt(1 - p * p);
          },
          Elastic: function(p) {
            return p === 0 || p === 1 ? p : -Math.pow(2, 8 * (p - 1)) * Math.sin(((p - 1) * 80 - 7.5) * Math.PI / 15);
          },
          Back: function(p) {
            return p * p * (3 * p - 2);
          },
          Bounce: function(p) {
            var pow2,
                bounce = 4;
            while (p < ((pow2 = Math.pow(2, --bounce)) - 1) / 11) {}
            return 1 / Math.pow(4, 3 - bounce) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - p, 2);
          }
        });
        $.each(baseEasings, function(name, easeIn) {
          $.easing["easeIn" + name] = easeIn;
          $.easing["easeOut" + name] = function(p) {
            return 1 - easeIn(1 - p);
          };
          $.easing["easeInOut" + name] = function(p) {
            return p < 0.5 ? easeIn(p * 2) / 2 : 1 - easeIn(p * -2 + 2) / 2;
          };
        });
      })();
      var effect = $.effects;
      var effectBlind = $.effects.effect.blind = function(o, done) {
        var el = $(this),
            rvertical = /up|down|vertical/,
            rpositivemotion = /up|left|vertical|horizontal/,
            props = ["position", "top", "bottom", "left", "right", "height", "width"],
            mode = $.effects.setMode(el, o.mode || "hide"),
            direction = o.direction || "up",
            vertical = rvertical.test(direction),
            ref = vertical ? "height" : "width",
            ref2 = vertical ? "top" : "left",
            motion = rpositivemotion.test(direction),
            animation = {},
            show = mode === "show",
            wrapper,
            distance,
            margin;
        if (el.parent().is(".ui-effects-wrapper")) {
          $.effects.save(el.parent(), props);
        } else {
          $.effects.save(el, props);
        }
        el.show();
        wrapper = $.effects.createWrapper(el).css({overflow: "hidden"});
        distance = wrapper[ref]();
        margin = parseFloat(wrapper.css(ref2)) || 0;
        animation[ref] = show ? distance : 0;
        if (!motion) {
          el.css(vertical ? "bottom" : "right", 0).css(vertical ? "top" : "left", "auto").css({position: "absolute"});
          animation[ref2] = show ? margin : distance + margin;
        }
        if (show) {
          wrapper.css(ref, 0);
          if (!motion) {
            wrapper.css(ref2, margin + distance);
          }
        }
        wrapper.animate(animation, {
          duration: o.duration,
          easing: o.easing,
          queue: false,
          complete: function() {
            if (mode === "hide") {
              el.hide();
            }
            $.effects.restore(el, props);
            $.effects.removeWrapper(el);
            done();
          }
        });
      };
      var effectBounce = $.effects.effect.bounce = function(o, done) {
        var el = $(this),
            props = ["position", "top", "bottom", "left", "right", "height", "width"],
            mode = $.effects.setMode(el, o.mode || "effect"),
            hide = mode === "hide",
            show = mode === "show",
            direction = o.direction || "up",
            distance = o.distance,
            times = o.times || 5,
            anims = times * 2 + (show || hide ? 1 : 0),
            speed = o.duration / anims,
            easing = o.easing,
            ref = (direction === "up" || direction === "down") ? "top" : "left",
            motion = (direction === "up" || direction === "left"),
            i,
            upAnim,
            downAnim,
            queue = el.queue(),
            queuelen = queue.length;
        if (show || hide) {
          props.push("opacity");
        }
        $.effects.save(el, props);
        el.show();
        $.effects.createWrapper(el);
        if (!distance) {
          distance = el[ref === "top" ? "outerHeight" : "outerWidth"]() / 3;
        }
        if (show) {
          downAnim = {opacity: 1};
          downAnim[ref] = 0;
          el.css("opacity", 0).css(ref, motion ? -distance * 2 : distance * 2).animate(downAnim, speed, easing);
        }
        if (hide) {
          distance = distance / Math.pow(2, times - 1);
        }
        downAnim = {};
        downAnim[ref] = 0;
        for (i = 0; i < times; i++) {
          upAnim = {};
          upAnim[ref] = (motion ? "-=" : "+=") + distance;
          el.animate(upAnim, speed, easing).animate(downAnim, speed, easing);
          distance = hide ? distance * 2 : distance / 2;
        }
        if (hide) {
          upAnim = {opacity: 0};
          upAnim[ref] = (motion ? "-=" : "+=") + distance;
          el.animate(upAnim, speed, easing);
        }
        el.queue(function() {
          if (hide) {
            el.hide();
          }
          $.effects.restore(el, props);
          $.effects.removeWrapper(el);
          done();
        });
        if (queuelen > 1) {
          queue.splice.apply(queue, [1, 0].concat(queue.splice(queuelen, anims + 1)));
        }
        el.dequeue();
      };
      var effectClip = $.effects.effect.clip = function(o, done) {
        var el = $(this),
            props = ["position", "top", "bottom", "left", "right", "height", "width"],
            mode = $.effects.setMode(el, o.mode || "hide"),
            show = mode === "show",
            direction = o.direction || "vertical",
            vert = direction === "vertical",
            size = vert ? "height" : "width",
            position = vert ? "top" : "left",
            animation = {},
            wrapper,
            animate,
            distance;
        $.effects.save(el, props);
        el.show();
        wrapper = $.effects.createWrapper(el).css({overflow: "hidden"});
        animate = (el[0].tagName === "IMG") ? wrapper : el;
        distance = animate[size]();
        if (show) {
          animate.css(size, 0);
          animate.css(position, distance / 2);
        }
        animation[size] = show ? distance : 0;
        animation[position] = show ? 0 : distance / 2;
        animate.animate(animation, {
          queue: false,
          duration: o.duration,
          easing: o.easing,
          complete: function() {
            if (!show) {
              el.hide();
            }
            $.effects.restore(el, props);
            $.effects.removeWrapper(el);
            done();
          }
        });
      };
      var effectDrop = $.effects.effect.drop = function(o, done) {
        var el = $(this),
            props = ["position", "top", "bottom", "left", "right", "opacity", "height", "width"],
            mode = $.effects.setMode(el, o.mode || "hide"),
            show = mode === "show",
            direction = o.direction || "left",
            ref = (direction === "up" || direction === "down") ? "top" : "left",
            motion = (direction === "up" || direction === "left") ? "pos" : "neg",
            animation = {opacity: show ? 1 : 0},
            distance;
        $.effects.save(el, props);
        el.show();
        $.effects.createWrapper(el);
        distance = o.distance || el[ref === "top" ? "outerHeight" : "outerWidth"](true) / 2;
        if (show) {
          el.css("opacity", 0).css(ref, motion === "pos" ? -distance : distance);
        }
        animation[ref] = (show ? (motion === "pos" ? "+=" : "-=") : (motion === "pos" ? "-=" : "+=")) + distance;
        el.animate(animation, {
          queue: false,
          duration: o.duration,
          easing: o.easing,
          complete: function() {
            if (mode === "hide") {
              el.hide();
            }
            $.effects.restore(el, props);
            $.effects.removeWrapper(el);
            done();
          }
        });
      };
      var effectExplode = $.effects.effect.explode = function(o, done) {
        var rows = o.pieces ? Math.round(Math.sqrt(o.pieces)) : 3,
            cells = rows,
            el = $(this),
            mode = $.effects.setMode(el, o.mode || "hide"),
            show = mode === "show",
            offset = el.show().css("visibility", "hidden").offset(),
            width = Math.ceil(el.outerWidth() / cells),
            height = Math.ceil(el.outerHeight() / rows),
            pieces = [],
            i,
            j,
            left,
            top,
            mx,
            my;
        function childComplete() {
          pieces.push(this);
          if (pieces.length === rows * cells) {
            animComplete();
          }
        }
        for (i = 0; i < rows; i++) {
          top = offset.top + i * height;
          my = i - (rows - 1) / 2;
          for (j = 0; j < cells; j++) {
            left = offset.left + j * width;
            mx = j - (cells - 1) / 2;
            el.clone().appendTo("body").wrap("<div></div>").css({
              position: "absolute",
              visibility: "visible",
              left: -j * width,
              top: -i * height
            }).parent().addClass("ui-effects-explode").css({
              position: "absolute",
              overflow: "hidden",
              width: width,
              height: height,
              left: left + (show ? mx * width : 0),
              top: top + (show ? my * height : 0),
              opacity: show ? 0 : 1
            }).animate({
              left: left + (show ? 0 : mx * width),
              top: top + (show ? 0 : my * height),
              opacity: show ? 1 : 0
            }, o.duration || 500, o.easing, childComplete);
          }
        }
        function animComplete() {
          el.css({visibility: "visible"});
          $(pieces).remove();
          if (!show) {
            el.hide();
          }
          done();
        }
      };
      var effectFade = $.effects.effect.fade = function(o, done) {
        var el = $(this),
            mode = $.effects.setMode(el, o.mode || "toggle");
        el.animate({opacity: mode}, {
          queue: false,
          duration: o.duration,
          easing: o.easing,
          complete: done
        });
      };
      var effectFold = $.effects.effect.fold = function(o, done) {
        var el = $(this),
            props = ["position", "top", "bottom", "left", "right", "height", "width"],
            mode = $.effects.setMode(el, o.mode || "hide"),
            show = mode === "show",
            hide = mode === "hide",
            size = o.size || 15,
            percent = /([0-9]+)%/.exec(size),
            horizFirst = !!o.horizFirst,
            widthFirst = show !== horizFirst,
            ref = widthFirst ? ["width", "height"] : ["height", "width"],
            duration = o.duration / 2,
            wrapper,
            distance,
            animation1 = {},
            animation2 = {};
        $.effects.save(el, props);
        el.show();
        wrapper = $.effects.createWrapper(el).css({overflow: "hidden"});
        distance = widthFirst ? [wrapper.width(), wrapper.height()] : [wrapper.height(), wrapper.width()];
        if (percent) {
          size = parseInt(percent[1], 10) / 100 * distance[hide ? 0 : 1];
        }
        if (show) {
          wrapper.css(horizFirst ? {
            height: 0,
            width: size
          } : {
            height: size,
            width: 0
          });
        }
        animation1[ref[0]] = show ? distance[0] : size;
        animation2[ref[1]] = show ? distance[1] : 0;
        wrapper.animate(animation1, duration, o.easing).animate(animation2, duration, o.easing, function() {
          if (hide) {
            el.hide();
          }
          $.effects.restore(el, props);
          $.effects.removeWrapper(el);
          done();
        });
      };
      var effectHighlight = $.effects.effect.highlight = function(o, done) {
        var elem = $(this),
            props = ["backgroundImage", "backgroundColor", "opacity"],
            mode = $.effects.setMode(elem, o.mode || "show"),
            animation = {backgroundColor: elem.css("backgroundColor")};
        if (mode === "hide") {
          animation.opacity = 0;
        }
        $.effects.save(elem, props);
        elem.show().css({
          backgroundImage: "none",
          backgroundColor: o.color || "#ffff99"
        }).animate(animation, {
          queue: false,
          duration: o.duration,
          easing: o.easing,
          complete: function() {
            if (mode === "hide") {
              elem.hide();
            }
            $.effects.restore(elem, props);
            done();
          }
        });
      };
      var effectSize = $.effects.effect.size = function(o, done) {
        var original,
            baseline,
            factor,
            el = $(this),
            props0 = ["position", "top", "bottom", "left", "right", "width", "height", "overflow", "opacity"],
            props1 = ["position", "top", "bottom", "left", "right", "overflow", "opacity"],
            props2 = ["width", "height", "overflow"],
            cProps = ["fontSize"],
            vProps = ["borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom"],
            hProps = ["borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight"],
            mode = $.effects.setMode(el, o.mode || "effect"),
            restore = o.restore || mode !== "effect",
            scale = o.scale || "both",
            origin = o.origin || ["middle", "center"],
            position = el.css("position"),
            props = restore ? props0 : props1,
            zero = {
              height: 0,
              width: 0,
              outerHeight: 0,
              outerWidth: 0
            };
        if (mode === "show") {
          el.show();
        }
        original = {
          height: el.height(),
          width: el.width(),
          outerHeight: el.outerHeight(),
          outerWidth: el.outerWidth()
        };
        if (o.mode === "toggle" && mode === "show") {
          el.from = o.to || zero;
          el.to = o.from || original;
        } else {
          el.from = o.from || (mode === "show" ? zero : original);
          el.to = o.to || (mode === "hide" ? zero : original);
        }
        factor = {
          from: {
            y: el.from.height / original.height,
            x: el.from.width / original.width
          },
          to: {
            y: el.to.height / original.height,
            x: el.to.width / original.width
          }
        };
        if (scale === "box" || scale === "both") {
          if (factor.from.y !== factor.to.y) {
            props = props.concat(vProps);
            el.from = $.effects.setTransition(el, vProps, factor.from.y, el.from);
            el.to = $.effects.setTransition(el, vProps, factor.to.y, el.to);
          }
          if (factor.from.x !== factor.to.x) {
            props = props.concat(hProps);
            el.from = $.effects.setTransition(el, hProps, factor.from.x, el.from);
            el.to = $.effects.setTransition(el, hProps, factor.to.x, el.to);
          }
        }
        if (scale === "content" || scale === "both") {
          if (factor.from.y !== factor.to.y) {
            props = props.concat(cProps).concat(props2);
            el.from = $.effects.setTransition(el, cProps, factor.from.y, el.from);
            el.to = $.effects.setTransition(el, cProps, factor.to.y, el.to);
          }
        }
        $.effects.save(el, props);
        el.show();
        $.effects.createWrapper(el);
        el.css("overflow", "hidden").css(el.from);
        if (origin) {
          baseline = $.effects.getBaseline(origin, original);
          el.from.top = (original.outerHeight - el.outerHeight()) * baseline.y;
          el.from.left = (original.outerWidth - el.outerWidth()) * baseline.x;
          el.to.top = (original.outerHeight - el.to.outerHeight) * baseline.y;
          el.to.left = (original.outerWidth - el.to.outerWidth) * baseline.x;
        }
        el.css(el.from);
        if (scale === "content" || scale === "both") {
          vProps = vProps.concat(["marginTop", "marginBottom"]).concat(cProps);
          hProps = hProps.concat(["marginLeft", "marginRight"]);
          props2 = props0.concat(vProps).concat(hProps);
          el.find("*[width]").each(function() {
            var child = $(this),
                c_original = {
                  height: child.height(),
                  width: child.width(),
                  outerHeight: child.outerHeight(),
                  outerWidth: child.outerWidth()
                };
            if (restore) {
              $.effects.save(child, props2);
            }
            child.from = {
              height: c_original.height * factor.from.y,
              width: c_original.width * factor.from.x,
              outerHeight: c_original.outerHeight * factor.from.y,
              outerWidth: c_original.outerWidth * factor.from.x
            };
            child.to = {
              height: c_original.height * factor.to.y,
              width: c_original.width * factor.to.x,
              outerHeight: c_original.height * factor.to.y,
              outerWidth: c_original.width * factor.to.x
            };
            if (factor.from.y !== factor.to.y) {
              child.from = $.effects.setTransition(child, vProps, factor.from.y, child.from);
              child.to = $.effects.setTransition(child, vProps, factor.to.y, child.to);
            }
            if (factor.from.x !== factor.to.x) {
              child.from = $.effects.setTransition(child, hProps, factor.from.x, child.from);
              child.to = $.effects.setTransition(child, hProps, factor.to.x, child.to);
            }
            child.css(child.from);
            child.animate(child.to, o.duration, o.easing, function() {
              if (restore) {
                $.effects.restore(child, props2);
              }
            });
          });
        }
        el.animate(el.to, {
          queue: false,
          duration: o.duration,
          easing: o.easing,
          complete: function() {
            if (el.to.opacity === 0) {
              el.css("opacity", el.from.opacity);
            }
            if (mode === "hide") {
              el.hide();
            }
            $.effects.restore(el, props);
            if (!restore) {
              if (position === "static") {
                el.css({
                  position: "relative",
                  top: el.to.top,
                  left: el.to.left
                });
              } else {
                $.each(["top", "left"], function(idx, pos) {
                  el.css(pos, function(_, str) {
                    var val = parseInt(str, 10),
                        toRef = idx ? el.to.left : el.to.top;
                    if (str === "auto") {
                      return toRef + "px";
                    }
                    return val + toRef + "px";
                  });
                });
              }
            }
            $.effects.removeWrapper(el);
            done();
          }
        });
      };
      var effectScale = $.effects.effect.scale = function(o, done) {
        var el = $(this),
            options = $.extend(true, {}, o),
            mode = $.effects.setMode(el, o.mode || "effect"),
            percent = parseInt(o.percent, 10) || (parseInt(o.percent, 10) === 0 ? 0 : (mode === "hide" ? 0 : 100)),
            direction = o.direction || "both",
            origin = o.origin,
            original = {
              height: el.height(),
              width: el.width(),
              outerHeight: el.outerHeight(),
              outerWidth: el.outerWidth()
            },
            factor = {
              y: direction !== "horizontal" ? (percent / 100) : 1,
              x: direction !== "vertical" ? (percent / 100) : 1
            };
        options.effect = "size";
        options.queue = false;
        options.complete = done;
        if (mode !== "effect") {
          options.origin = origin || ["middle", "center"];
          options.restore = true;
        }
        options.from = o.from || (mode === "show" ? {
          height: 0,
          width: 0,
          outerHeight: 0,
          outerWidth: 0
        } : original);
        options.to = {
          height: original.height * factor.y,
          width: original.width * factor.x,
          outerHeight: original.outerHeight * factor.y,
          outerWidth: original.outerWidth * factor.x
        };
        if (options.fade) {
          if (mode === "show") {
            options.from.opacity = 0;
            options.to.opacity = 1;
          }
          if (mode === "hide") {
            options.from.opacity = 1;
            options.to.opacity = 0;
          }
        }
        el.effect(options);
      };
      var effectPuff = $.effects.effect.puff = function(o, done) {
        var elem = $(this),
            mode = $.effects.setMode(elem, o.mode || "hide"),
            hide = mode === "hide",
            percent = parseInt(o.percent, 10) || 150,
            factor = percent / 100,
            original = {
              height: elem.height(),
              width: elem.width(),
              outerHeight: elem.outerHeight(),
              outerWidth: elem.outerWidth()
            };
        $.extend(o, {
          effect: "scale",
          queue: false,
          fade: true,
          mode: mode,
          complete: done,
          percent: hide ? percent : 100,
          from: hide ? original : {
            height: original.height * factor,
            width: original.width * factor,
            outerHeight: original.outerHeight * factor,
            outerWidth: original.outerWidth * factor
          }
        });
        elem.effect(o);
      };
      var effectPulsate = $.effects.effect.pulsate = function(o, done) {
        var elem = $(this),
            mode = $.effects.setMode(elem, o.mode || "show"),
            show = mode === "show",
            hide = mode === "hide",
            showhide = (show || mode === "hide"),
            anims = ((o.times || 5) * 2) + (showhide ? 1 : 0),
            duration = o.duration / anims,
            animateTo = 0,
            queue = elem.queue(),
            queuelen = queue.length,
            i;
        if (show || !elem.is(":visible")) {
          elem.css("opacity", 0).show();
          animateTo = 1;
        }
        for (i = 1; i < anims; i++) {
          elem.animate({opacity: animateTo}, duration, o.easing);
          animateTo = 1 - animateTo;
        }
        elem.animate({opacity: animateTo}, duration, o.easing);
        elem.queue(function() {
          if (hide) {
            elem.hide();
          }
          done();
        });
        if (queuelen > 1) {
          queue.splice.apply(queue, [1, 0].concat(queue.splice(queuelen, anims + 1)));
        }
        elem.dequeue();
      };
      var effectShake = $.effects.effect.shake = function(o, done) {
        var el = $(this),
            props = ["position", "top", "bottom", "left", "right", "height", "width"],
            mode = $.effects.setMode(el, o.mode || "effect"),
            direction = o.direction || "left",
            distance = o.distance || 20,
            times = o.times || 3,
            anims = times * 2 + 1,
            speed = Math.round(o.duration / anims),
            ref = (direction === "up" || direction === "down") ? "top" : "left",
            positiveMotion = (direction === "up" || direction === "left"),
            animation = {},
            animation1 = {},
            animation2 = {},
            i,
            queue = el.queue(),
            queuelen = queue.length;
        $.effects.save(el, props);
        el.show();
        $.effects.createWrapper(el);
        animation[ref] = (positiveMotion ? "-=" : "+=") + distance;
        animation1[ref] = (positiveMotion ? "+=" : "-=") + distance * 2;
        animation2[ref] = (positiveMotion ? "-=" : "+=") + distance * 2;
        el.animate(animation, speed, o.easing);
        for (i = 1; i < times; i++) {
          el.animate(animation1, speed, o.easing).animate(animation2, speed, o.easing);
        }
        el.animate(animation1, speed, o.easing).animate(animation, speed / 2, o.easing).queue(function() {
          if (mode === "hide") {
            el.hide();
          }
          $.effects.restore(el, props);
          $.effects.removeWrapper(el);
          done();
        });
        if (queuelen > 1) {
          queue.splice.apply(queue, [1, 0].concat(queue.splice(queuelen, anims + 1)));
        }
        el.dequeue();
      };
      var effectSlide = $.effects.effect.slide = function(o, done) {
        var el = $(this),
            props = ["position", "top", "bottom", "left", "right", "width", "height"],
            mode = $.effects.setMode(el, o.mode || "show"),
            show = mode === "show",
            direction = o.direction || "left",
            ref = (direction === "up" || direction === "down") ? "top" : "left",
            positiveMotion = (direction === "up" || direction === "left"),
            distance,
            animation = {};
        $.effects.save(el, props);
        el.show();
        distance = o.distance || el[ref === "top" ? "outerHeight" : "outerWidth"](true);
        $.effects.createWrapper(el).css({overflow: "hidden"});
        if (show) {
          el.css(ref, positiveMotion ? (isNaN(distance) ? "-" + distance : -distance) : distance);
        }
        animation[ref] = (show ? (positiveMotion ? "+=" : "-=") : (positiveMotion ? "-=" : "+=")) + distance;
        el.animate(animation, {
          queue: false,
          duration: o.duration,
          easing: o.easing,
          complete: function() {
            if (mode === "hide") {
              el.hide();
            }
            $.effects.restore(el, props);
            $.effects.removeWrapper(el);
            done();
          }
        });
      };
      var effectTransfer = $.effects.effect.transfer = function(o, done) {
        var elem = $(this),
            target = $(o.to),
            targetFixed = target.css("position") === "fixed",
            body = $("body"),
            fixTop = targetFixed ? body.scrollTop() : 0,
            fixLeft = targetFixed ? body.scrollLeft() : 0,
            endPosition = target.offset(),
            animation = {
              top: endPosition.top - fixTop,
              left: endPosition.left - fixLeft,
              height: target.innerHeight(),
              width: target.innerWidth()
            },
            startPosition = elem.offset(),
            transfer = $("<div class='ui-effects-transfer'></div>").appendTo(document.body).addClass(o.className).css({
              top: startPosition.top - fixTop,
              left: startPosition.left - fixLeft,
              height: elem.innerHeight(),
              width: elem.innerWidth(),
              position: targetFixed ? "fixed" : "absolute"
            }).animate(animation, o.duration, o.easing, function() {
              transfer.remove();
              done();
            });
      };
      var progressbar = $.widget("ui.progressbar", {
        version: "1.11.3",
        options: {
          max: 100,
          value: 0,
          change: null,
          complete: null
        },
        min: 0,
        _create: function() {
          this.oldValue = this.options.value = this._constrainedValue();
          this.element.addClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").attr({
            role: "progressbar",
            "aria-valuemin": this.min
          });
          this.valueDiv = $("<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>").appendTo(this.element);
          this._refreshValue();
        },
        _destroy: function() {
          this.element.removeClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").removeAttr("role").removeAttr("aria-valuemin").removeAttr("aria-valuemax").removeAttr("aria-valuenow");
          this.valueDiv.remove();
        },
        value: function(newValue) {
          if (newValue === undefined) {
            return this.options.value;
          }
          this.options.value = this._constrainedValue(newValue);
          this._refreshValue();
        },
        _constrainedValue: function(newValue) {
          if (newValue === undefined) {
            newValue = this.options.value;
          }
          this.indeterminate = newValue === false;
          if (typeof newValue !== "number") {
            newValue = 0;
          }
          return this.indeterminate ? false : Math.min(this.options.max, Math.max(this.min, newValue));
        },
        _setOptions: function(options) {
          var value = options.value;
          delete options.value;
          this._super(options);
          this.options.value = this._constrainedValue(value);
          this._refreshValue();
        },
        _setOption: function(key, value) {
          if (key === "max") {
            value = Math.max(this.min, value);
          }
          if (key === "disabled") {
            this.element.toggleClass("ui-state-disabled", !!value).attr("aria-disabled", value);
          }
          this._super(key, value);
        },
        _percentage: function() {
          return this.indeterminate ? 100 : 100 * (this.options.value - this.min) / (this.options.max - this.min);
        },
        _refreshValue: function() {
          var value = this.options.value,
              percentage = this._percentage();
          this.valueDiv.toggle(this.indeterminate || value > this.min).toggleClass("ui-corner-right", value === this.options.max).width(percentage.toFixed(0) + "%");
          this.element.toggleClass("ui-progressbar-indeterminate", this.indeterminate);
          if (this.indeterminate) {
            this.element.removeAttr("aria-valuenow");
            if (!this.overlayDiv) {
              this.overlayDiv = $("<div class='ui-progressbar-overlay'></div>").appendTo(this.valueDiv);
            }
          } else {
            this.element.attr({
              "aria-valuemax": this.options.max,
              "aria-valuenow": value
            });
            if (this.overlayDiv) {
              this.overlayDiv.remove();
              this.overlayDiv = null;
            }
          }
          if (this.oldValue !== value) {
            this.oldValue = value;
            this._trigger("change");
          }
          if (value === this.options.max) {
            this._trigger("complete");
          }
        }
      });
      var selectable = $.widget("ui.selectable", $.ui.mouse, {
        version: "1.11.3",
        options: {
          appendTo: "body",
          autoRefresh: true,
          distance: 0,
          filter: "*",
          tolerance: "touch",
          selected: null,
          selecting: null,
          start: null,
          stop: null,
          unselected: null,
          unselecting: null
        },
        _create: function() {
          var selectees,
              that = this;
          this.element.addClass("ui-selectable");
          this.dragged = false;
          this.refresh = function() {
            selectees = $(that.options.filter, that.element[0]);
            selectees.addClass("ui-selectee");
            selectees.each(function() {
              var $this = $(this),
                  pos = $this.offset();
              $.data(this, "selectable-item", {
                element: this,
                $element: $this,
                left: pos.left,
                top: pos.top,
                right: pos.left + $this.outerWidth(),
                bottom: pos.top + $this.outerHeight(),
                startselected: false,
                selected: $this.hasClass("ui-selected"),
                selecting: $this.hasClass("ui-selecting"),
                unselecting: $this.hasClass("ui-unselecting")
              });
            });
          };
          this.refresh();
          this.selectees = selectees.addClass("ui-selectee");
          this._mouseInit();
          this.helper = $("<div class='ui-selectable-helper'></div>");
        },
        _destroy: function() {
          this.selectees.removeClass("ui-selectee").removeData("selectable-item");
          this.element.removeClass("ui-selectable ui-selectable-disabled");
          this._mouseDestroy();
        },
        _mouseStart: function(event) {
          var that = this,
              options = this.options;
          this.opos = [event.pageX, event.pageY];
          if (this.options.disabled) {
            return ;
          }
          this.selectees = $(options.filter, this.element[0]);
          this._trigger("start", event);
          $(options.appendTo).append(this.helper);
          this.helper.css({
            "left": event.pageX,
            "top": event.pageY,
            "width": 0,
            "height": 0
          });
          if (options.autoRefresh) {
            this.refresh();
          }
          this.selectees.filter(".ui-selected").each(function() {
            var selectee = $.data(this, "selectable-item");
            selectee.startselected = true;
            if (!event.metaKey && !event.ctrlKey) {
              selectee.$element.removeClass("ui-selected");
              selectee.selected = false;
              selectee.$element.addClass("ui-unselecting");
              selectee.unselecting = true;
              that._trigger("unselecting", event, {unselecting: selectee.element});
            }
          });
          $(event.target).parents().addBack().each(function() {
            var doSelect,
                selectee = $.data(this, "selectable-item");
            if (selectee) {
              doSelect = (!event.metaKey && !event.ctrlKey) || !selectee.$element.hasClass("ui-selected");
              selectee.$element.removeClass(doSelect ? "ui-unselecting" : "ui-selected").addClass(doSelect ? "ui-selecting" : "ui-unselecting");
              selectee.unselecting = !doSelect;
              selectee.selecting = doSelect;
              selectee.selected = doSelect;
              if (doSelect) {
                that._trigger("selecting", event, {selecting: selectee.element});
              } else {
                that._trigger("unselecting", event, {unselecting: selectee.element});
              }
              return false;
            }
          });
        },
        _mouseDrag: function(event) {
          this.dragged = true;
          if (this.options.disabled) {
            return ;
          }
          var tmp,
              that = this,
              options = this.options,
              x1 = this.opos[0],
              y1 = this.opos[1],
              x2 = event.pageX,
              y2 = event.pageY;
          if (x1 > x2) {
            tmp = x2;
            x2 = x1;
            x1 = tmp;
          }
          if (y1 > y2) {
            tmp = y2;
            y2 = y1;
            y1 = tmp;
          }
          this.helper.css({
            left: x1,
            top: y1,
            width: x2 - x1,
            height: y2 - y1
          });
          this.selectees.each(function() {
            var selectee = $.data(this, "selectable-item"),
                hit = false;
            if (!selectee || selectee.element === that.element[0]) {
              return ;
            }
            if (options.tolerance === "touch") {
              hit = (!(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1));
            } else if (options.tolerance === "fit") {
              hit = (selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2);
            }
            if (hit) {
              if (selectee.selected) {
                selectee.$element.removeClass("ui-selected");
                selectee.selected = false;
              }
              if (selectee.unselecting) {
                selectee.$element.removeClass("ui-unselecting");
                selectee.unselecting = false;
              }
              if (!selectee.selecting) {
                selectee.$element.addClass("ui-selecting");
                selectee.selecting = true;
                that._trigger("selecting", event, {selecting: selectee.element});
              }
            } else {
              if (selectee.selecting) {
                if ((event.metaKey || event.ctrlKey) && selectee.startselected) {
                  selectee.$element.removeClass("ui-selecting");
                  selectee.selecting = false;
                  selectee.$element.addClass("ui-selected");
                  selectee.selected = true;
                } else {
                  selectee.$element.removeClass("ui-selecting");
                  selectee.selecting = false;
                  if (selectee.startselected) {
                    selectee.$element.addClass("ui-unselecting");
                    selectee.unselecting = true;
                  }
                  that._trigger("unselecting", event, {unselecting: selectee.element});
                }
              }
              if (selectee.selected) {
                if (!event.metaKey && !event.ctrlKey && !selectee.startselected) {
                  selectee.$element.removeClass("ui-selected");
                  selectee.selected = false;
                  selectee.$element.addClass("ui-unselecting");
                  selectee.unselecting = true;
                  that._trigger("unselecting", event, {unselecting: selectee.element});
                }
              }
            }
          });
          return false;
        },
        _mouseStop: function(event) {
          var that = this;
          this.dragged = false;
          $(".ui-unselecting", this.element[0]).each(function() {
            var selectee = $.data(this, "selectable-item");
            selectee.$element.removeClass("ui-unselecting");
            selectee.unselecting = false;
            selectee.startselected = false;
            that._trigger("unselected", event, {unselected: selectee.element});
          });
          $(".ui-selecting", this.element[0]).each(function() {
            var selectee = $.data(this, "selectable-item");
            selectee.$element.removeClass("ui-selecting").addClass("ui-selected");
            selectee.selecting = false;
            selectee.selected = true;
            selectee.startselected = true;
            that._trigger("selected", event, {selected: selectee.element});
          });
          this._trigger("stop", event);
          this.helper.remove();
          return false;
        }
      });
      var selectmenu = $.widget("ui.selectmenu", {
        version: "1.11.3",
        defaultElement: "<select>",
        options: {
          appendTo: null,
          disabled: null,
          icons: {button: "ui-icon-triangle-1-s"},
          position: {
            my: "left top",
            at: "left bottom",
            collision: "none"
          },
          width: null,
          change: null,
          close: null,
          focus: null,
          open: null,
          select: null
        },
        _create: function() {
          var selectmenuId = this.element.uniqueId().attr("id");
          this.ids = {
            element: selectmenuId,
            button: selectmenuId + "-button",
            menu: selectmenuId + "-menu"
          };
          this._drawButton();
          this._drawMenu();
          if (this.options.disabled) {
            this.disable();
          }
        },
        _drawButton: function() {
          var that = this;
          this.label = $("label[for='" + this.ids.element + "']").attr("for", this.ids.button);
          this._on(this.label, {click: function(event) {
              this.button.focus();
              event.preventDefault();
            }});
          this.element.hide();
          this.button = $("<span>", {
            "class": "ui-selectmenu-button ui-widget ui-state-default ui-corner-all",
            tabindex: this.options.disabled ? -1 : 0,
            id: this.ids.button,
            role: "combobox",
            "aria-expanded": "false",
            "aria-autocomplete": "list",
            "aria-owns": this.ids.menu,
            "aria-haspopup": "true"
          }).insertAfter(this.element);
          $("<span>", {"class": "ui-icon " + this.options.icons.button}).prependTo(this.button);
          this.buttonText = $("<span>", {"class": "ui-selectmenu-text"}).appendTo(this.button);
          this._setText(this.buttonText, this.element.find("option:selected").text());
          this._resizeButton();
          this._on(this.button, this._buttonEvents);
          this.button.one("focusin", function() {
            if (!that.menuItems) {
              that._refreshMenu();
            }
          });
          this._hoverable(this.button);
          this._focusable(this.button);
        },
        _drawMenu: function() {
          var that = this;
          this.menu = $("<ul>", {
            "aria-hidden": "true",
            "aria-labelledby": this.ids.button,
            id: this.ids.menu
          });
          this.menuWrap = $("<div>", {"class": "ui-selectmenu-menu ui-front"}).append(this.menu).appendTo(this._appendTo());
          this.menuInstance = this.menu.menu({
            role: "listbox",
            select: function(event, ui) {
              event.preventDefault();
              that._setSelection();
              that._select(ui.item.data("ui-selectmenu-item"), event);
            },
            focus: function(event, ui) {
              var item = ui.item.data("ui-selectmenu-item");
              if (that.focusIndex != null && item.index !== that.focusIndex) {
                that._trigger("focus", event, {item: item});
                if (!that.isOpen) {
                  that._select(item, event);
                }
              }
              that.focusIndex = item.index;
              that.button.attr("aria-activedescendant", that.menuItems.eq(item.index).attr("id"));
            }
          }).menu("instance");
          this.menu.addClass("ui-corner-bottom").removeClass("ui-corner-all");
          this.menuInstance._off(this.menu, "mouseleave");
          this.menuInstance._closeOnDocumentClick = function() {
            return false;
          };
          this.menuInstance._isDivider = function() {
            return false;
          };
        },
        refresh: function() {
          this._refreshMenu();
          this._setText(this.buttonText, this._getSelectedItem().text());
          if (!this.options.width) {
            this._resizeButton();
          }
        },
        _refreshMenu: function() {
          this.menu.empty();
          var item,
              options = this.element.find("option");
          if (!options.length) {
            return ;
          }
          this._parseOptions(options);
          this._renderMenu(this.menu, this.items);
          this.menuInstance.refresh();
          this.menuItems = this.menu.find("li").not(".ui-selectmenu-optgroup");
          item = this._getSelectedItem();
          this.menuInstance.focus(null, item);
          this._setAria(item.data("ui-selectmenu-item"));
          this._setOption("disabled", this.element.prop("disabled"));
        },
        open: function(event) {
          if (this.options.disabled) {
            return ;
          }
          if (!this.menuItems) {
            this._refreshMenu();
          } else {
            this.menu.find(".ui-state-focus").removeClass("ui-state-focus");
            this.menuInstance.focus(null, this._getSelectedItem());
          }
          this.isOpen = true;
          this._toggleAttr();
          this._resizeMenu();
          this._position();
          this._on(this.document, this._documentClick);
          this._trigger("open", event);
        },
        _position: function() {
          this.menuWrap.position($.extend({of: this.button}, this.options.position));
        },
        close: function(event) {
          if (!this.isOpen) {
            return ;
          }
          this.isOpen = false;
          this._toggleAttr();
          this.range = null;
          this._off(this.document);
          this._trigger("close", event);
        },
        widget: function() {
          return this.button;
        },
        menuWidget: function() {
          return this.menu;
        },
        _renderMenu: function(ul, items) {
          var that = this,
              currentOptgroup = "";
          $.each(items, function(index, item) {
            if (item.optgroup !== currentOptgroup) {
              $("<li>", {
                "class": "ui-selectmenu-optgroup ui-menu-divider" + (item.element.parent("optgroup").prop("disabled") ? " ui-state-disabled" : ""),
                text: item.optgroup
              }).appendTo(ul);
              currentOptgroup = item.optgroup;
            }
            that._renderItemData(ul, item);
          });
        },
        _renderItemData: function(ul, item) {
          return this._renderItem(ul, item).data("ui-selectmenu-item", item);
        },
        _renderItem: function(ul, item) {
          var li = $("<li>");
          if (item.disabled) {
            li.addClass("ui-state-disabled");
          }
          this._setText(li, item.label);
          return li.appendTo(ul);
        },
        _setText: function(element, value) {
          if (value) {
            element.text(value);
          } else {
            element.html("&#160;");
          }
        },
        _move: function(direction, event) {
          var item,
              next,
              filter = ".ui-menu-item";
          if (this.isOpen) {
            item = this.menuItems.eq(this.focusIndex);
          } else {
            item = this.menuItems.eq(this.element[0].selectedIndex);
            filter += ":not(.ui-state-disabled)";
          }
          if (direction === "first" || direction === "last") {
            next = item[direction === "first" ? "prevAll" : "nextAll"](filter).eq(-1);
          } else {
            next = item[direction + "All"](filter).eq(0);
          }
          if (next.length) {
            this.menuInstance.focus(event, next);
          }
        },
        _getSelectedItem: function() {
          return this.menuItems.eq(this.element[0].selectedIndex);
        },
        _toggle: function(event) {
          this[this.isOpen ? "close" : "open"](event);
        },
        _setSelection: function() {
          var selection;
          if (!this.range) {
            return ;
          }
          if (window.getSelection) {
            selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(this.range);
          } else {
            this.range.select();
          }
          this.button.focus();
        },
        _documentClick: {mousedown: function(event) {
            if (!this.isOpen) {
              return ;
            }
            if (!$(event.target).closest(".ui-selectmenu-menu, #" + this.ids.button).length) {
              this.close(event);
            }
          }},
        _buttonEvents: {
          mousedown: function() {
            var selection;
            if (window.getSelection) {
              selection = window.getSelection();
              if (selection.rangeCount) {
                this.range = selection.getRangeAt(0);
              }
            } else {
              this.range = document.selection.createRange();
            }
          },
          click: function(event) {
            this._setSelection();
            this._toggle(event);
          },
          keydown: function(event) {
            var preventDefault = true;
            switch (event.keyCode) {
              case $.ui.keyCode.TAB:
              case $.ui.keyCode.ESCAPE:
                this.close(event);
                preventDefault = false;
                break;
              case $.ui.keyCode.ENTER:
                if (this.isOpen) {
                  this._selectFocusedItem(event);
                }
                break;
              case $.ui.keyCode.UP:
                if (event.altKey) {
                  this._toggle(event);
                } else {
                  this._move("prev", event);
                }
                break;
              case $.ui.keyCode.DOWN:
                if (event.altKey) {
                  this._toggle(event);
                } else {
                  this._move("next", event);
                }
                break;
              case $.ui.keyCode.SPACE:
                if (this.isOpen) {
                  this._selectFocusedItem(event);
                } else {
                  this._toggle(event);
                }
                break;
              case $.ui.keyCode.LEFT:
                this._move("prev", event);
                break;
              case $.ui.keyCode.RIGHT:
                this._move("next", event);
                break;
              case $.ui.keyCode.HOME:
              case $.ui.keyCode.PAGE_UP:
                this._move("first", event);
                break;
              case $.ui.keyCode.END:
              case $.ui.keyCode.PAGE_DOWN:
                this._move("last", event);
                break;
              default:
                this.menu.trigger(event);
                preventDefault = false;
            }
            if (preventDefault) {
              event.preventDefault();
            }
          }
        },
        _selectFocusedItem: function(event) {
          var item = this.menuItems.eq(this.focusIndex);
          if (!item.hasClass("ui-state-disabled")) {
            this._select(item.data("ui-selectmenu-item"), event);
          }
        },
        _select: function(item, event) {
          var oldIndex = this.element[0].selectedIndex;
          this.element[0].selectedIndex = item.index;
          this._setText(this.buttonText, item.label);
          this._setAria(item);
          this._trigger("select", event, {item: item});
          if (item.index !== oldIndex) {
            this._trigger("change", event, {item: item});
          }
          this.close(event);
        },
        _setAria: function(item) {
          var id = this.menuItems.eq(item.index).attr("id");
          this.button.attr({
            "aria-labelledby": id,
            "aria-activedescendant": id
          });
          this.menu.attr("aria-activedescendant", id);
        },
        _setOption: function(key, value) {
          if (key === "icons") {
            this.button.find("span.ui-icon").removeClass(this.options.icons.button).addClass(value.button);
          }
          this._super(key, value);
          if (key === "appendTo") {
            this.menuWrap.appendTo(this._appendTo());
          }
          if (key === "disabled") {
            this.menuInstance.option("disabled", value);
            this.button.toggleClass("ui-state-disabled", value).attr("aria-disabled", value);
            this.element.prop("disabled", value);
            if (value) {
              this.button.attr("tabindex", -1);
              this.close();
            } else {
              this.button.attr("tabindex", 0);
            }
          }
          if (key === "width") {
            this._resizeButton();
          }
        },
        _appendTo: function() {
          var element = this.options.appendTo;
          if (element) {
            element = element.jquery || element.nodeType ? $(element) : this.document.find(element).eq(0);
          }
          if (!element || !element[0]) {
            element = this.element.closest(".ui-front");
          }
          if (!element.length) {
            element = this.document[0].body;
          }
          return element;
        },
        _toggleAttr: function() {
          this.button.toggleClass("ui-corner-top", this.isOpen).toggleClass("ui-corner-all", !this.isOpen).attr("aria-expanded", this.isOpen);
          this.menuWrap.toggleClass("ui-selectmenu-open", this.isOpen);
          this.menu.attr("aria-hidden", !this.isOpen);
        },
        _resizeButton: function() {
          var width = this.options.width;
          if (!width) {
            width = this.element.show().outerWidth();
            this.element.hide();
          }
          this.button.outerWidth(width);
        },
        _resizeMenu: function() {
          this.menu.outerWidth(Math.max(this.button.outerWidth(), this.menu.width("").outerWidth() + 1));
        },
        _getCreateOptions: function() {
          return {disabled: this.element.prop("disabled")};
        },
        _parseOptions: function(options) {
          var data = [];
          options.each(function(index, item) {
            var option = $(item),
                optgroup = option.parent("optgroup");
            data.push({
              element: option,
              index: index,
              value: option.val(),
              label: option.text(),
              optgroup: optgroup.attr("label") || "",
              disabled: optgroup.prop("disabled") || option.prop("disabled")
            });
          });
          this.items = data;
        },
        _destroy: function() {
          this.menuWrap.remove();
          this.button.remove();
          this.element.show();
          this.element.removeUniqueId();
          this.label.attr("for", this.ids.element);
        }
      });
      var slider = $.widget("ui.slider", $.ui.mouse, {
        version: "1.11.3",
        widgetEventPrefix: "slide",
        options: {
          animate: false,
          distance: 0,
          max: 100,
          min: 0,
          orientation: "horizontal",
          range: false,
          step: 1,
          value: 0,
          values: null,
          change: null,
          slide: null,
          start: null,
          stop: null
        },
        numPages: 5,
        _create: function() {
          this._keySliding = false;
          this._mouseSliding = false;
          this._animateOff = true;
          this._handleIndex = null;
          this._detectOrientation();
          this._mouseInit();
          this._calculateNewMax();
          this.element.addClass("ui-slider" + " ui-slider-" + this.orientation + " ui-widget" + " ui-widget-content" + " ui-corner-all");
          this._refresh();
          this._setOption("disabled", this.options.disabled);
          this._animateOff = false;
        },
        _refresh: function() {
          this._createRange();
          this._createHandles();
          this._setupEvents();
          this._refreshValue();
        },
        _createHandles: function() {
          var i,
              handleCount,
              options = this.options,
              existingHandles = this.element.find(".ui-slider-handle").addClass("ui-state-default ui-corner-all"),
              handle = "<span class='ui-slider-handle ui-state-default ui-corner-all' tabindex='0'></span>",
              handles = [];
          handleCount = (options.values && options.values.length) || 1;
          if (existingHandles.length > handleCount) {
            existingHandles.slice(handleCount).remove();
            existingHandles = existingHandles.slice(0, handleCount);
          }
          for (i = existingHandles.length; i < handleCount; i++) {
            handles.push(handle);
          }
          this.handles = existingHandles.add($(handles.join("")).appendTo(this.element));
          this.handle = this.handles.eq(0);
          this.handles.each(function(i) {
            $(this).data("ui-slider-handle-index", i);
          });
        },
        _createRange: function() {
          var options = this.options,
              classes = "";
          if (options.range) {
            if (options.range === true) {
              if (!options.values) {
                options.values = [this._valueMin(), this._valueMin()];
              } else if (options.values.length && options.values.length !== 2) {
                options.values = [options.values[0], options.values[0]];
              } else if ($.isArray(options.values)) {
                options.values = options.values.slice(0);
              }
            }
            if (!this.range || !this.range.length) {
              this.range = $("<div></div>").appendTo(this.element);
              classes = "ui-slider-range" + " ui-widget-header ui-corner-all";
            } else {
              this.range.removeClass("ui-slider-range-min ui-slider-range-max").css({
                "left": "",
                "bottom": ""
              });
            }
            this.range.addClass(classes + ((options.range === "min" || options.range === "max") ? " ui-slider-range-" + options.range : ""));
          } else {
            if (this.range) {
              this.range.remove();
            }
            this.range = null;
          }
        },
        _setupEvents: function() {
          this._off(this.handles);
          this._on(this.handles, this._handleEvents);
          this._hoverable(this.handles);
          this._focusable(this.handles);
        },
        _destroy: function() {
          this.handles.remove();
          if (this.range) {
            this.range.remove();
          }
          this.element.removeClass("ui-slider" + " ui-slider-horizontal" + " ui-slider-vertical" + " ui-widget" + " ui-widget-content" + " ui-corner-all");
          this._mouseDestroy();
        },
        _mouseCapture: function(event) {
          var position,
              normValue,
              distance,
              closestHandle,
              index,
              allowed,
              offset,
              mouseOverHandle,
              that = this,
              o = this.options;
          if (o.disabled) {
            return false;
          }
          this.elementSize = {
            width: this.element.outerWidth(),
            height: this.element.outerHeight()
          };
          this.elementOffset = this.element.offset();
          position = {
            x: event.pageX,
            y: event.pageY
          };
          normValue = this._normValueFromMouse(position);
          distance = this._valueMax() - this._valueMin() + 1;
          this.handles.each(function(i) {
            var thisDistance = Math.abs(normValue - that.values(i));
            if ((distance > thisDistance) || (distance === thisDistance && (i === that._lastChangedValue || that.values(i) === o.min))) {
              distance = thisDistance;
              closestHandle = $(this);
              index = i;
            }
          });
          allowed = this._start(event, index);
          if (allowed === false) {
            return false;
          }
          this._mouseSliding = true;
          this._handleIndex = index;
          closestHandle.addClass("ui-state-active").focus();
          offset = closestHandle.offset();
          mouseOverHandle = !$(event.target).parents().addBack().is(".ui-slider-handle");
          this._clickOffset = mouseOverHandle ? {
            left: 0,
            top: 0
          } : {
            left: event.pageX - offset.left - (closestHandle.width() / 2),
            top: event.pageY - offset.top - (closestHandle.height() / 2) - (parseInt(closestHandle.css("borderTopWidth"), 10) || 0) - (parseInt(closestHandle.css("borderBottomWidth"), 10) || 0) + (parseInt(closestHandle.css("marginTop"), 10) || 0)
          };
          if (!this.handles.hasClass("ui-state-hover")) {
            this._slide(event, index, normValue);
          }
          this._animateOff = true;
          return true;
        },
        _mouseStart: function() {
          return true;
        },
        _mouseDrag: function(event) {
          var position = {
            x: event.pageX,
            y: event.pageY
          },
              normValue = this._normValueFromMouse(position);
          this._slide(event, this._handleIndex, normValue);
          return false;
        },
        _mouseStop: function(event) {
          this.handles.removeClass("ui-state-active");
          this._mouseSliding = false;
          this._stop(event, this._handleIndex);
          this._change(event, this._handleIndex);
          this._handleIndex = null;
          this._clickOffset = null;
          this._animateOff = false;
          return false;
        },
        _detectOrientation: function() {
          this.orientation = (this.options.orientation === "vertical") ? "vertical" : "horizontal";
        },
        _normValueFromMouse: function(position) {
          var pixelTotal,
              pixelMouse,
              percentMouse,
              valueTotal,
              valueMouse;
          if (this.orientation === "horizontal") {
            pixelTotal = this.elementSize.width;
            pixelMouse = position.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0);
          } else {
            pixelTotal = this.elementSize.height;
            pixelMouse = position.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0);
          }
          percentMouse = (pixelMouse / pixelTotal);
          if (percentMouse > 1) {
            percentMouse = 1;
          }
          if (percentMouse < 0) {
            percentMouse = 0;
          }
          if (this.orientation === "vertical") {
            percentMouse = 1 - percentMouse;
          }
          valueTotal = this._valueMax() - this._valueMin();
          valueMouse = this._valueMin() + percentMouse * valueTotal;
          return this._trimAlignValue(valueMouse);
        },
        _start: function(event, index) {
          var uiHash = {
            handle: this.handles[index],
            value: this.value()
          };
          if (this.options.values && this.options.values.length) {
            uiHash.value = this.values(index);
            uiHash.values = this.values();
          }
          return this._trigger("start", event, uiHash);
        },
        _slide: function(event, index, newVal) {
          var otherVal,
              newValues,
              allowed;
          if (this.options.values && this.options.values.length) {
            otherVal = this.values(index ? 0 : 1);
            if ((this.options.values.length === 2 && this.options.range === true) && ((index === 0 && newVal > otherVal) || (index === 1 && newVal < otherVal))) {
              newVal = otherVal;
            }
            if (newVal !== this.values(index)) {
              newValues = this.values();
              newValues[index] = newVal;
              allowed = this._trigger("slide", event, {
                handle: this.handles[index],
                value: newVal,
                values: newValues
              });
              otherVal = this.values(index ? 0 : 1);
              if (allowed !== false) {
                this.values(index, newVal);
              }
            }
          } else {
            if (newVal !== this.value()) {
              allowed = this._trigger("slide", event, {
                handle: this.handles[index],
                value: newVal
              });
              if (allowed !== false) {
                this.value(newVal);
              }
            }
          }
        },
        _stop: function(event, index) {
          var uiHash = {
            handle: this.handles[index],
            value: this.value()
          };
          if (this.options.values && this.options.values.length) {
            uiHash.value = this.values(index);
            uiHash.values = this.values();
          }
          this._trigger("stop", event, uiHash);
        },
        _change: function(event, index) {
          if (!this._keySliding && !this._mouseSliding) {
            var uiHash = {
              handle: this.handles[index],
              value: this.value()
            };
            if (this.options.values && this.options.values.length) {
              uiHash.value = this.values(index);
              uiHash.values = this.values();
            }
            this._lastChangedValue = index;
            this._trigger("change", event, uiHash);
          }
        },
        value: function(newValue) {
          if (arguments.length) {
            this.options.value = this._trimAlignValue(newValue);
            this._refreshValue();
            this._change(null, 0);
            return ;
          }
          return this._value();
        },
        values: function(index, newValue) {
          var vals,
              newValues,
              i;
          if (arguments.length > 1) {
            this.options.values[index] = this._trimAlignValue(newValue);
            this._refreshValue();
            this._change(null, index);
            return ;
          }
          if (arguments.length) {
            if ($.isArray(arguments[0])) {
              vals = this.options.values;
              newValues = arguments[0];
              for (i = 0; i < vals.length; i += 1) {
                vals[i] = this._trimAlignValue(newValues[i]);
                this._change(null, i);
              }
              this._refreshValue();
            } else {
              if (this.options.values && this.options.values.length) {
                return this._values(index);
              } else {
                return this.value();
              }
            }
          } else {
            return this._values();
          }
        },
        _setOption: function(key, value) {
          var i,
              valsLength = 0;
          if (key === "range" && this.options.range === true) {
            if (value === "min") {
              this.options.value = this._values(0);
              this.options.values = null;
            } else if (value === "max") {
              this.options.value = this._values(this.options.values.length - 1);
              this.options.values = null;
            }
          }
          if ($.isArray(this.options.values)) {
            valsLength = this.options.values.length;
          }
          if (key === "disabled") {
            this.element.toggleClass("ui-state-disabled", !!value);
          }
          this._super(key, value);
          switch (key) {
            case "orientation":
              this._detectOrientation();
              this.element.removeClass("ui-slider-horizontal ui-slider-vertical").addClass("ui-slider-" + this.orientation);
              this._refreshValue();
              this.handles.css(value === "horizontal" ? "bottom" : "left", "");
              break;
            case "value":
              this._animateOff = true;
              this._refreshValue();
              this._change(null, 0);
              this._animateOff = false;
              break;
            case "values":
              this._animateOff = true;
              this._refreshValue();
              for (i = 0; i < valsLength; i += 1) {
                this._change(null, i);
              }
              this._animateOff = false;
              break;
            case "step":
            case "min":
            case "max":
              this._animateOff = true;
              this._calculateNewMax();
              this._refreshValue();
              this._animateOff = false;
              break;
            case "range":
              this._animateOff = true;
              this._refresh();
              this._animateOff = false;
              break;
          }
        },
        _value: function() {
          var val = this.options.value;
          val = this._trimAlignValue(val);
          return val;
        },
        _values: function(index) {
          var val,
              vals,
              i;
          if (arguments.length) {
            val = this.options.values[index];
            val = this._trimAlignValue(val);
            return val;
          } else if (this.options.values && this.options.values.length) {
            vals = this.options.values.slice();
            for (i = 0; i < vals.length; i += 1) {
              vals[i] = this._trimAlignValue(vals[i]);
            }
            return vals;
          } else {
            return [];
          }
        },
        _trimAlignValue: function(val) {
          if (val <= this._valueMin()) {
            return this._valueMin();
          }
          if (val >= this._valueMax()) {
            return this._valueMax();
          }
          var step = (this.options.step > 0) ? this.options.step : 1,
              valModStep = (val - this._valueMin()) % step,
              alignValue = val - valModStep;
          if (Math.abs(valModStep) * 2 >= step) {
            alignValue += (valModStep > 0) ? step : (-step);
          }
          return parseFloat(alignValue.toFixed(5));
        },
        _calculateNewMax: function() {
          var max = this.options.max,
              min = this._valueMin(),
              step = this.options.step,
              aboveMin = Math.floor((max - min) / step) * step;
          max = aboveMin + min;
          this.max = parseFloat(max.toFixed(this._precision()));
        },
        _precision: function() {
          var precision = this._precisionOf(this.options.step);
          if (this.options.min !== null) {
            precision = Math.max(precision, this._precisionOf(this.options.min));
          }
          return precision;
        },
        _precisionOf: function(num) {
          var str = num.toString(),
              decimal = str.indexOf(".");
          return decimal === -1 ? 0 : str.length - decimal - 1;
        },
        _valueMin: function() {
          return this.options.min;
        },
        _valueMax: function() {
          return this.max;
        },
        _refreshValue: function() {
          var lastValPercent,
              valPercent,
              value,
              valueMin,
              valueMax,
              oRange = this.options.range,
              o = this.options,
              that = this,
              animate = (!this._animateOff) ? o.animate : false,
              _set = {};
          if (this.options.values && this.options.values.length) {
            this.handles.each(function(i) {
              valPercent = (that.values(i) - that._valueMin()) / (that._valueMax() - that._valueMin()) * 100;
              _set[that.orientation === "horizontal" ? "left" : "bottom"] = valPercent + "%";
              $(this).stop(1, 1)[animate ? "animate" : "css"](_set, o.animate);
              if (that.options.range === true) {
                if (that.orientation === "horizontal") {
                  if (i === 0) {
                    that.range.stop(1, 1)[animate ? "animate" : "css"]({left: valPercent + "%"}, o.animate);
                  }
                  if (i === 1) {
                    that.range[animate ? "animate" : "css"]({width: (valPercent - lastValPercent) + "%"}, {
                      queue: false,
                      duration: o.animate
                    });
                  }
                } else {
                  if (i === 0) {
                    that.range.stop(1, 1)[animate ? "animate" : "css"]({bottom: (valPercent) + "%"}, o.animate);
                  }
                  if (i === 1) {
                    that.range[animate ? "animate" : "css"]({height: (valPercent - lastValPercent) + "%"}, {
                      queue: false,
                      duration: o.animate
                    });
                  }
                }
              }
              lastValPercent = valPercent;
            });
          } else {
            value = this.value();
            valueMin = this._valueMin();
            valueMax = this._valueMax();
            valPercent = (valueMax !== valueMin) ? (value - valueMin) / (valueMax - valueMin) * 100 : 0;
            _set[this.orientation === "horizontal" ? "left" : "bottom"] = valPercent + "%";
            this.handle.stop(1, 1)[animate ? "animate" : "css"](_set, o.animate);
            if (oRange === "min" && this.orientation === "horizontal") {
              this.range.stop(1, 1)[animate ? "animate" : "css"]({width: valPercent + "%"}, o.animate);
            }
            if (oRange === "max" && this.orientation === "horizontal") {
              this.range[animate ? "animate" : "css"]({width: (100 - valPercent) + "%"}, {
                queue: false,
                duration: o.animate
              });
            }
            if (oRange === "min" && this.orientation === "vertical") {
              this.range.stop(1, 1)[animate ? "animate" : "css"]({height: valPercent + "%"}, o.animate);
            }
            if (oRange === "max" && this.orientation === "vertical") {
              this.range[animate ? "animate" : "css"]({height: (100 - valPercent) + "%"}, {
                queue: false,
                duration: o.animate
              });
            }
          }
        },
        _handleEvents: {
          keydown: function(event) {
            var allowed,
                curVal,
                newVal,
                step,
                index = $(event.target).data("ui-slider-handle-index");
            switch (event.keyCode) {
              case $.ui.keyCode.HOME:
              case $.ui.keyCode.END:
              case $.ui.keyCode.PAGE_UP:
              case $.ui.keyCode.PAGE_DOWN:
              case $.ui.keyCode.UP:
              case $.ui.keyCode.RIGHT:
              case $.ui.keyCode.DOWN:
              case $.ui.keyCode.LEFT:
                event.preventDefault();
                if (!this._keySliding) {
                  this._keySliding = true;
                  $(event.target).addClass("ui-state-active");
                  allowed = this._start(event, index);
                  if (allowed === false) {
                    return ;
                  }
                }
                break;
            }
            step = this.options.step;
            if (this.options.values && this.options.values.length) {
              curVal = newVal = this.values(index);
            } else {
              curVal = newVal = this.value();
            }
            switch (event.keyCode) {
              case $.ui.keyCode.HOME:
                newVal = this._valueMin();
                break;
              case $.ui.keyCode.END:
                newVal = this._valueMax();
                break;
              case $.ui.keyCode.PAGE_UP:
                newVal = this._trimAlignValue(curVal + ((this._valueMax() - this._valueMin()) / this.numPages));
                break;
              case $.ui.keyCode.PAGE_DOWN:
                newVal = this._trimAlignValue(curVal - ((this._valueMax() - this._valueMin()) / this.numPages));
                break;
              case $.ui.keyCode.UP:
              case $.ui.keyCode.RIGHT:
                if (curVal === this._valueMax()) {
                  return ;
                }
                newVal = this._trimAlignValue(curVal + step);
                break;
              case $.ui.keyCode.DOWN:
              case $.ui.keyCode.LEFT:
                if (curVal === this._valueMin()) {
                  return ;
                }
                newVal = this._trimAlignValue(curVal - step);
                break;
            }
            this._slide(event, index, newVal);
          },
          keyup: function(event) {
            var index = $(event.target).data("ui-slider-handle-index");
            if (this._keySliding) {
              this._keySliding = false;
              this._stop(event, index);
              this._change(event, index);
              $(event.target).removeClass("ui-state-active");
            }
          }
        }
      });
      var sortable = $.widget("ui.sortable", $.ui.mouse, {
        version: "1.11.3",
        widgetEventPrefix: "sort",
        ready: false,
        options: {
          appendTo: "parent",
          axis: false,
          connectWith: false,
          containment: false,
          cursor: "auto",
          cursorAt: false,
          dropOnEmpty: true,
          forcePlaceholderSize: false,
          forceHelperSize: false,
          grid: false,
          handle: false,
          helper: "original",
          items: "> *",
          opacity: false,
          placeholder: false,
          revert: false,
          scroll: true,
          scrollSensitivity: 20,
          scrollSpeed: 20,
          scope: "default",
          tolerance: "intersect",
          zIndex: 1000,
          activate: null,
          beforeStop: null,
          change: null,
          deactivate: null,
          out: null,
          over: null,
          receive: null,
          remove: null,
          sort: null,
          start: null,
          stop: null,
          update: null
        },
        _isOverAxis: function(x, reference, size) {
          return (x >= reference) && (x < (reference + size));
        },
        _isFloating: function(item) {
          return (/left|right/).test(item.css("float")) || (/inline|table-cell/).test(item.css("display"));
        },
        _create: function() {
          var o = this.options;
          this.containerCache = {};
          this.element.addClass("ui-sortable");
          this.refresh();
          this.floating = this.items.length ? o.axis === "x" || this._isFloating(this.items[0].item) : false;
          this.offset = this.element.offset();
          this._mouseInit();
          this._setHandleClassName();
          this.ready = true;
        },
        _setOption: function(key, value) {
          this._super(key, value);
          if (key === "handle") {
            this._setHandleClassName();
          }
        },
        _setHandleClassName: function() {
          this.element.find(".ui-sortable-handle").removeClass("ui-sortable-handle");
          $.each(this.items, function() {
            (this.instance.options.handle ? this.item.find(this.instance.options.handle) : this.item).addClass("ui-sortable-handle");
          });
        },
        _destroy: function() {
          this.element.removeClass("ui-sortable ui-sortable-disabled").find(".ui-sortable-handle").removeClass("ui-sortable-handle");
          this._mouseDestroy();
          for (var i = this.items.length - 1; i >= 0; i--) {
            this.items[i].item.removeData(this.widgetName + "-item");
          }
          return this;
        },
        _mouseCapture: function(event, overrideHandle) {
          var currentItem = null,
              validHandle = false,
              that = this;
          if (this.reverting) {
            return false;
          }
          if (this.options.disabled || this.options.type === "static") {
            return false;
          }
          this._refreshItems(event);
          $(event.target).parents().each(function() {
            if ($.data(this, that.widgetName + "-item") === that) {
              currentItem = $(this);
              return false;
            }
          });
          if ($.data(event.target, that.widgetName + "-item") === that) {
            currentItem = $(event.target);
          }
          if (!currentItem) {
            return false;
          }
          if (this.options.handle && !overrideHandle) {
            $(this.options.handle, currentItem).find("*").addBack().each(function() {
              if (this === event.target) {
                validHandle = true;
              }
            });
            if (!validHandle) {
              return false;
            }
          }
          this.currentItem = currentItem;
          this._removeCurrentsFromItems();
          return true;
        },
        _mouseStart: function(event, overrideHandle, noActivation) {
          var i,
              body,
              o = this.options;
          this.currentContainer = this;
          this.refreshPositions();
          this.helper = this._createHelper(event);
          this._cacheHelperProportions();
          this._cacheMargins();
          this.scrollParent = this.helper.scrollParent();
          this.offset = this.currentItem.offset();
          this.offset = {
            top: this.offset.top - this.margins.top,
            left: this.offset.left - this.margins.left
          };
          $.extend(this.offset, {
            click: {
              left: event.pageX - this.offset.left,
              top: event.pageY - this.offset.top
            },
            parent: this._getParentOffset(),
            relative: this._getRelativeOffset()
          });
          this.helper.css("position", "absolute");
          this.cssPosition = this.helper.css("position");
          this.originalPosition = this._generatePosition(event);
          this.originalPageX = event.pageX;
          this.originalPageY = event.pageY;
          (o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));
          this.domPosition = {
            prev: this.currentItem.prev()[0],
            parent: this.currentItem.parent()[0]
          };
          if (this.helper[0] !== this.currentItem[0]) {
            this.currentItem.hide();
          }
          this._createPlaceholder();
          if (o.containment) {
            this._setContainment();
          }
          if (o.cursor && o.cursor !== "auto") {
            body = this.document.find("body");
            this.storedCursor = body.css("cursor");
            body.css("cursor", o.cursor);
            this.storedStylesheet = $("<style>*{ cursor: " + o.cursor + " !important; }</style>").appendTo(body);
          }
          if (o.opacity) {
            if (this.helper.css("opacity")) {
              this._storedOpacity = this.helper.css("opacity");
            }
            this.helper.css("opacity", o.opacity);
          }
          if (o.zIndex) {
            if (this.helper.css("zIndex")) {
              this._storedZIndex = this.helper.css("zIndex");
            }
            this.helper.css("zIndex", o.zIndex);
          }
          if (this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== "HTML") {
            this.overflowOffset = this.scrollParent.offset();
          }
          this._trigger("start", event, this._uiHash());
          if (!this._preserveHelperProportions) {
            this._cacheHelperProportions();
          }
          if (!noActivation) {
            for (i = this.containers.length - 1; i >= 0; i--) {
              this.containers[i]._trigger("activate", event, this._uiHash(this));
            }
          }
          if ($.ui.ddmanager) {
            $.ui.ddmanager.current = this;
          }
          if ($.ui.ddmanager && !o.dropBehaviour) {
            $.ui.ddmanager.prepareOffsets(this, event);
          }
          this.dragging = true;
          this.helper.addClass("ui-sortable-helper");
          this._mouseDrag(event);
          return true;
        },
        _mouseDrag: function(event) {
          var i,
              item,
              itemElement,
              intersection,
              o = this.options,
              scrolled = false;
          this.position = this._generatePosition(event);
          this.positionAbs = this._convertPositionTo("absolute");
          if (!this.lastPositionAbs) {
            this.lastPositionAbs = this.positionAbs;
          }
          if (this.options.scroll) {
            if (this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== "HTML") {
              if ((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {
                this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
              } else if (event.pageY - this.overflowOffset.top < o.scrollSensitivity) {
                this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;
              }
              if ((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {
                this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
              } else if (event.pageX - this.overflowOffset.left < o.scrollSensitivity) {
                this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;
              }
            } else {
              if (event.pageY - this.document.scrollTop() < o.scrollSensitivity) {
                scrolled = this.document.scrollTop(this.document.scrollTop() - o.scrollSpeed);
              } else if (this.window.height() - (event.pageY - this.document.scrollTop()) < o.scrollSensitivity) {
                scrolled = this.document.scrollTop(this.document.scrollTop() + o.scrollSpeed);
              }
              if (event.pageX - this.document.scrollLeft() < o.scrollSensitivity) {
                scrolled = this.document.scrollLeft(this.document.scrollLeft() - o.scrollSpeed);
              } else if (this.window.width() - (event.pageX - this.document.scrollLeft()) < o.scrollSensitivity) {
                scrolled = this.document.scrollLeft(this.document.scrollLeft() + o.scrollSpeed);
              }
            }
            if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
              $.ui.ddmanager.prepareOffsets(this, event);
            }
          }
          this.positionAbs = this._convertPositionTo("absolute");
          if (!this.options.axis || this.options.axis !== "y") {
            this.helper[0].style.left = this.position.left + "px";
          }
          if (!this.options.axis || this.options.axis !== "x") {
            this.helper[0].style.top = this.position.top + "px";
          }
          for (i = this.items.length - 1; i >= 0; i--) {
            item = this.items[i];
            itemElement = item.item[0];
            intersection = this._intersectsWithPointer(item);
            if (!intersection) {
              continue;
            }
            if (item.instance !== this.currentContainer) {
              continue;
            }
            if (itemElement !== this.currentItem[0] && this.placeholder[intersection === 1 ? "next" : "prev"]()[0] !== itemElement && !$.contains(this.placeholder[0], itemElement) && (this.options.type === "semi-dynamic" ? !$.contains(this.element[0], itemElement) : true)) {
              this.direction = intersection === 1 ? "down" : "up";
              if (this.options.tolerance === "pointer" || this._intersectsWithSides(item)) {
                this._rearrange(event, item);
              } else {
                break;
              }
              this._trigger("change", event, this._uiHash());
              break;
            }
          }
          this._contactContainers(event);
          if ($.ui.ddmanager) {
            $.ui.ddmanager.drag(this, event);
          }
          this._trigger("sort", event, this._uiHash());
          this.lastPositionAbs = this.positionAbs;
          return false;
        },
        _mouseStop: function(event, noPropagation) {
          if (!event) {
            return ;
          }
          if ($.ui.ddmanager && !this.options.dropBehaviour) {
            $.ui.ddmanager.drop(this, event);
          }
          if (this.options.revert) {
            var that = this,
                cur = this.placeholder.offset(),
                axis = this.options.axis,
                animation = {};
            if (!axis || axis === "x") {
              animation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollLeft);
            }
            if (!axis || axis === "y") {
              animation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollTop);
            }
            this.reverting = true;
            $(this.helper).animate(animation, parseInt(this.options.revert, 10) || 500, function() {
              that._clear(event);
            });
          } else {
            this._clear(event, noPropagation);
          }
          return false;
        },
        cancel: function() {
          if (this.dragging) {
            this._mouseUp({target: null});
            if (this.options.helper === "original") {
              this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
            } else {
              this.currentItem.show();
            }
            for (var i = this.containers.length - 1; i >= 0; i--) {
              this.containers[i]._trigger("deactivate", null, this._uiHash(this));
              if (this.containers[i].containerCache.over) {
                this.containers[i]._trigger("out", null, this._uiHash(this));
                this.containers[i].containerCache.over = 0;
              }
            }
          }
          if (this.placeholder) {
            if (this.placeholder[0].parentNode) {
              this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
            }
            if (this.options.helper !== "original" && this.helper && this.helper[0].parentNode) {
              this.helper.remove();
            }
            $.extend(this, {
              helper: null,
              dragging: false,
              reverting: false,
              _noFinalSort: null
            });
            if (this.domPosition.prev) {
              $(this.domPosition.prev).after(this.currentItem);
            } else {
              $(this.domPosition.parent).prepend(this.currentItem);
            }
          }
          return this;
        },
        serialize: function(o) {
          var items = this._getItemsAsjQuery(o && o.connected),
              str = [];
          o = o || {};
          $(items).each(function() {
            var res = ($(o.item || this).attr(o.attribute || "id") || "").match(o.expression || (/(.+)[\-=_](.+)/));
            if (res) {
              str.push((o.key || res[1] + "[]") + "=" + (o.key && o.expression ? res[1] : res[2]));
            }
          });
          if (!str.length && o.key) {
            str.push(o.key + "=");
          }
          return str.join("&");
        },
        toArray: function(o) {
          var items = this._getItemsAsjQuery(o && o.connected),
              ret = [];
          o = o || {};
          items.each(function() {
            ret.push($(o.item || this).attr(o.attribute || "id") || "");
          });
          return ret;
        },
        _intersectsWith: function(item) {
          var x1 = this.positionAbs.left,
              x2 = x1 + this.helperProportions.width,
              y1 = this.positionAbs.top,
              y2 = y1 + this.helperProportions.height,
              l = item.left,
              r = l + item.width,
              t = item.top,
              b = t + item.height,
              dyClick = this.offset.click.top,
              dxClick = this.offset.click.left,
              isOverElementHeight = (this.options.axis === "x") || ((y1 + dyClick) > t && (y1 + dyClick) < b),
              isOverElementWidth = (this.options.axis === "y") || ((x1 + dxClick) > l && (x1 + dxClick) < r),
              isOverElement = isOverElementHeight && isOverElementWidth;
          if (this.options.tolerance === "pointer" || this.options.forcePointerForContainers || (this.options.tolerance !== "pointer" && this.helperProportions[this.floating ? "width" : "height"] > item[this.floating ? "width" : "height"])) {
            return isOverElement;
          } else {
            return (l < x1 + (this.helperProportions.width / 2) && x2 - (this.helperProportions.width / 2) < r && t < y1 + (this.helperProportions.height / 2) && y2 - (this.helperProportions.height / 2) < b);
          }
        },
        _intersectsWithPointer: function(item) {
          var isOverElementHeight = (this.options.axis === "x") || this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
              isOverElementWidth = (this.options.axis === "y") || this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
              isOverElement = isOverElementHeight && isOverElementWidth,
              verticalDirection = this._getDragVerticalDirection(),
              horizontalDirection = this._getDragHorizontalDirection();
          if (!isOverElement) {
            return false;
          }
          return this.floating ? (((horizontalDirection && horizontalDirection === "right") || verticalDirection === "down") ? 2 : 1) : (verticalDirection && (verticalDirection === "down" ? 2 : 1));
        },
        _intersectsWithSides: function(item) {
          var isOverBottomHalf = this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height / 2), item.height),
              isOverRightHalf = this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width / 2), item.width),
              verticalDirection = this._getDragVerticalDirection(),
              horizontalDirection = this._getDragHorizontalDirection();
          if (this.floating && horizontalDirection) {
            return ((horizontalDirection === "right" && isOverRightHalf) || (horizontalDirection === "left" && !isOverRightHalf));
          } else {
            return verticalDirection && ((verticalDirection === "down" && isOverBottomHalf) || (verticalDirection === "up" && !isOverBottomHalf));
          }
        },
        _getDragVerticalDirection: function() {
          var delta = this.positionAbs.top - this.lastPositionAbs.top;
          return delta !== 0 && (delta > 0 ? "down" : "up");
        },
        _getDragHorizontalDirection: function() {
          var delta = this.positionAbs.left - this.lastPositionAbs.left;
          return delta !== 0 && (delta > 0 ? "right" : "left");
        },
        refresh: function(event) {
          this._refreshItems(event);
          this._setHandleClassName();
          this.refreshPositions();
          return this;
        },
        _connectWith: function() {
          var options = this.options;
          return options.connectWith.constructor === String ? [options.connectWith] : options.connectWith;
        },
        _getItemsAsjQuery: function(connected) {
          var i,
              j,
              cur,
              inst,
              items = [],
              queries = [],
              connectWith = this._connectWith();
          if (connectWith && connected) {
            for (i = connectWith.length - 1; i >= 0; i--) {
              cur = $(connectWith[i], this.document[0]);
              for (j = cur.length - 1; j >= 0; j--) {
                inst = $.data(cur[j], this.widgetFullName);
                if (inst && inst !== this && !inst.options.disabled) {
                  queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), inst]);
                }
              }
            }
          }
          queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, {
            options: this.options,
            item: this.currentItem
          }) : $(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]);
          function addItems() {
            items.push(this);
          }
          for (i = queries.length - 1; i >= 0; i--) {
            queries[i][0].each(addItems);
          }
          return $(items);
        },
        _removeCurrentsFromItems: function() {
          var list = this.currentItem.find(":data(" + this.widgetName + "-item)");
          this.items = $.grep(this.items, function(item) {
            for (var j = 0; j < list.length; j++) {
              if (list[j] === item.item[0]) {
                return false;
              }
            }
            return true;
          });
        },
        _refreshItems: function(event) {
          this.items = [];
          this.containers = [this];
          var i,
              j,
              cur,
              inst,
              targetData,
              _queries,
              item,
              queriesLength,
              items = this.items,
              queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, {item: this.currentItem}) : $(this.options.items, this.element), this]],
              connectWith = this._connectWith();
          if (connectWith && this.ready) {
            for (i = connectWith.length - 1; i >= 0; i--) {
              cur = $(connectWith[i], this.document[0]);
              for (j = cur.length - 1; j >= 0; j--) {
                inst = $.data(cur[j], this.widgetFullName);
                if (inst && inst !== this && !inst.options.disabled) {
                  queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, {item: this.currentItem}) : $(inst.options.items, inst.element), inst]);
                  this.containers.push(inst);
                }
              }
            }
          }
          for (i = queries.length - 1; i >= 0; i--) {
            targetData = queries[i][1];
            _queries = queries[i][0];
            for (j = 0, queriesLength = _queries.length; j < queriesLength; j++) {
              item = $(_queries[j]);
              item.data(this.widgetName + "-item", targetData);
              items.push({
                item: item,
                instance: targetData,
                width: 0,
                height: 0,
                left: 0,
                top: 0
              });
            }
          }
        },
        refreshPositions: function(fast) {
          if (this.offsetParent && this.helper) {
            this.offset.parent = this._getParentOffset();
          }
          var i,
              item,
              t,
              p;
          for (i = this.items.length - 1; i >= 0; i--) {
            item = this.items[i];
            if (item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {
              continue;
            }
            t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;
            if (!fast) {
              item.width = t.outerWidth();
              item.height = t.outerHeight();
            }
            p = t.offset();
            item.left = p.left;
            item.top = p.top;
          }
          if (this.options.custom && this.options.custom.refreshContainers) {
            this.options.custom.refreshContainers.call(this);
          } else {
            for (i = this.containers.length - 1; i >= 0; i--) {
              p = this.containers[i].element.offset();
              this.containers[i].containerCache.left = p.left;
              this.containers[i].containerCache.top = p.top;
              this.containers[i].containerCache.width = this.containers[i].element.outerWidth();
              this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
            }
          }
          return this;
        },
        _createPlaceholder: function(that) {
          that = that || this;
          var className,
              o = that.options;
          if (!o.placeholder || o.placeholder.constructor === String) {
            className = o.placeholder;
            o.placeholder = {
              element: function() {
                var nodeName = that.currentItem[0].nodeName.toLowerCase(),
                    element = $("<" + nodeName + ">", that.document[0]).addClass(className || that.currentItem[0].className + " ui-sortable-placeholder").removeClass("ui-sortable-helper");
                if (nodeName === "tr") {
                  that.currentItem.children().each(function() {
                    $("<td>&#160;</td>", that.document[0]).attr("colspan", $(this).attr("colspan") || 1).appendTo(element);
                  });
                } else if (nodeName === "img") {
                  element.attr("src", that.currentItem.attr("src"));
                }
                if (!className) {
                  element.css("visibility", "hidden");
                }
                return element;
              },
              update: function(container, p) {
                if (className && !o.forcePlaceholderSize) {
                  return ;
                }
                if (!p.height()) {
                  p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css("paddingTop") || 0, 10) - parseInt(that.currentItem.css("paddingBottom") || 0, 10));
                }
                if (!p.width()) {
                  p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css("paddingLeft") || 0, 10) - parseInt(that.currentItem.css("paddingRight") || 0, 10));
                }
              }
            };
          }
          that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));
          that.currentItem.after(that.placeholder);
          o.placeholder.update(that, that.placeholder);
        },
        _contactContainers: function(event) {
          var i,
              j,
              dist,
              itemWithLeastDistance,
              posProperty,
              sizeProperty,
              cur,
              nearBottom,
              floating,
              axis,
              innermostContainer = null,
              innermostIndex = null;
          for (i = this.containers.length - 1; i >= 0; i--) {
            if ($.contains(this.currentItem[0], this.containers[i].element[0])) {
              continue;
            }
            if (this._intersectsWith(this.containers[i].containerCache)) {
              if (innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {
                continue;
              }
              innermostContainer = this.containers[i];
              innermostIndex = i;
            } else {
              if (this.containers[i].containerCache.over) {
                this.containers[i]._trigger("out", event, this._uiHash(this));
                this.containers[i].containerCache.over = 0;
              }
            }
          }
          if (!innermostContainer) {
            return ;
          }
          if (this.containers.length === 1) {
            if (!this.containers[innermostIndex].containerCache.over) {
              this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
              this.containers[innermostIndex].containerCache.over = 1;
            }
          } else {
            dist = 10000;
            itemWithLeastDistance = null;
            floating = innermostContainer.floating || this._isFloating(this.currentItem);
            posProperty = floating ? "left" : "top";
            sizeProperty = floating ? "width" : "height";
            axis = floating ? "clientX" : "clientY";
            for (j = this.items.length - 1; j >= 0; j--) {
              if (!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {
                continue;
              }
              if (this.items[j].item[0] === this.currentItem[0]) {
                continue;
              }
              cur = this.items[j].item.offset()[posProperty];
              nearBottom = false;
              if (event[axis] - cur > this.items[j][sizeProperty] / 2) {
                nearBottom = true;
              }
              if (Math.abs(event[axis] - cur) < dist) {
                dist = Math.abs(event[axis] - cur);
                itemWithLeastDistance = this.items[j];
                this.direction = nearBottom ? "up" : "down";
              }
            }
            if (!itemWithLeastDistance && !this.options.dropOnEmpty) {
              return ;
            }
            if (this.currentContainer === this.containers[innermostIndex]) {
              if (!this.currentContainer.containerCache.over) {
                this.containers[innermostIndex]._trigger("over", event, this._uiHash());
                this.currentContainer.containerCache.over = 1;
              }
              return ;
            }
            itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
            this._trigger("change", event, this._uiHash());
            this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));
            this.currentContainer = this.containers[innermostIndex];
            this.options.placeholder.update(this.currentContainer, this.placeholder);
            this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
            this.containers[innermostIndex].containerCache.over = 1;
          }
        },
        _createHelper: function(event) {
          var o = this.options,
              helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper === "clone" ? this.currentItem.clone() : this.currentItem);
          if (!helper.parents("body").length) {
            $(o.appendTo !== "parent" ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);
          }
          if (helper[0] === this.currentItem[0]) {
            this._storedCSS = {
              width: this.currentItem[0].style.width,
              height: this.currentItem[0].style.height,
              position: this.currentItem.css("position"),
              top: this.currentItem.css("top"),
              left: this.currentItem.css("left")
            };
          }
          if (!helper[0].style.width || o.forceHelperSize) {
            helper.width(this.currentItem.width());
          }
          if (!helper[0].style.height || o.forceHelperSize) {
            helper.height(this.currentItem.height());
          }
          return helper;
        },
        _adjustOffsetFromHelper: function(obj) {
          if (typeof obj === "string") {
            obj = obj.split(" ");
          }
          if ($.isArray(obj)) {
            obj = {
              left: +obj[0],
              top: +obj[1] || 0
            };
          }
          if ("left" in obj) {
            this.offset.click.left = obj.left + this.margins.left;
          }
          if ("right" in obj) {
            this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
          }
          if ("top" in obj) {
            this.offset.click.top = obj.top + this.margins.top;
          }
          if ("bottom" in obj) {
            this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
          }
        },
        _getParentOffset: function() {
          this.offsetParent = this.helper.offsetParent();
          var po = this.offsetParent.offset();
          if (this.cssPosition === "absolute" && this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) {
            po.left += this.scrollParent.scrollLeft();
            po.top += this.scrollParent.scrollTop();
          }
          if (this.offsetParent[0] === this.document[0].body || (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {
            po = {
              top: 0,
              left: 0
            };
          }
          return {
            top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
            left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
          };
        },
        _getRelativeOffset: function() {
          if (this.cssPosition === "relative") {
            var p = this.currentItem.position();
            return {
              top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
              left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
            };
          } else {
            return {
              top: 0,
              left: 0
            };
          }
        },
        _cacheMargins: function() {
          this.margins = {
            left: (parseInt(this.currentItem.css("marginLeft"), 10) || 0),
            top: (parseInt(this.currentItem.css("marginTop"), 10) || 0)
          };
        },
        _cacheHelperProportions: function() {
          this.helperProportions = {
            width: this.helper.outerWidth(),
            height: this.helper.outerHeight()
          };
        },
        _setContainment: function() {
          var ce,
              co,
              over,
              o = this.options;
          if (o.containment === "parent") {
            o.containment = this.helper[0].parentNode;
          }
          if (o.containment === "document" || o.containment === "window") {
            this.containment = [0 - this.offset.relative.left - this.offset.parent.left, 0 - this.offset.relative.top - this.offset.parent.top, o.containment === "document" ? this.document.width() : this.window.width() - this.helperProportions.width - this.margins.left, (o.containment === "document" ? this.document.width() : this.window.height() || this.document[0].body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top];
          }
          if (!(/^(document|window|parent)$/).test(o.containment)) {
            ce = $(o.containment)[0];
            co = $(o.containment).offset();
            over = ($(ce).css("overflow") !== "hidden");
            this.containment = [co.left + (parseInt($(ce).css("borderLeftWidth"), 10) || 0) + (parseInt($(ce).css("paddingLeft"), 10) || 0) - this.margins.left, co.top + (parseInt($(ce).css("borderTopWidth"), 10) || 0) + (parseInt($(ce).css("paddingTop"), 10) || 0) - this.margins.top, co.left + (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"), 10) || 0) - (parseInt($(ce).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left, co.top + (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"), 10) || 0) - (parseInt($(ce).css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top];
          }
        },
        _convertPositionTo: function(d, pos) {
          if (!pos) {
            pos = this.position;
          }
          var mod = d === "absolute" ? 1 : -1,
              scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
              scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);
          return {
            top: (pos.top + this.offset.relative.top * mod + this.offset.parent.top * mod - ((this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : (scrollIsRootNode ? 0 : scroll.scrollTop())) * mod)),
            left: (pos.left + this.offset.relative.left * mod + this.offset.parent.left * mod - ((this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft()) * mod))
          };
        },
        _generatePosition: function(event) {
          var top,
              left,
              o = this.options,
              pageX = event.pageX,
              pageY = event.pageY,
              scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
              scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);
          if (this.cssPosition === "relative" && !(this.scrollParent[0] !== this.document[0] && this.scrollParent[0] !== this.offsetParent[0])) {
            this.offset.relative = this._getRelativeOffset();
          }
          if (this.originalPosition) {
            if (this.containment) {
              if (event.pageX - this.offset.click.left < this.containment[0]) {
                pageX = this.containment[0] + this.offset.click.left;
              }
              if (event.pageY - this.offset.click.top < this.containment[1]) {
                pageY = this.containment[1] + this.offset.click.top;
              }
              if (event.pageX - this.offset.click.left > this.containment[2]) {
                pageX = this.containment[2] + this.offset.click.left;
              }
              if (event.pageY - this.offset.click.top > this.containment[3]) {
                pageY = this.containment[3] + this.offset.click.top;
              }
            }
            if (o.grid) {
              top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
              pageY = this.containment ? ((top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3]) ? top : ((top - this.offset.click.top >= this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;
              left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
              pageX = this.containment ? ((left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2]) ? left : ((left - this.offset.click.left >= this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
            }
          }
          return {
            top: (pageY - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + ((this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : (scrollIsRootNode ? 0 : scroll.scrollTop())))),
            left: (pageX - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + ((this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft())))
          };
        },
        _rearrange: function(event, i, a, hardRefresh) {
          a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction === "down" ? i.item[0] : i.item[0].nextSibling));
          this.counter = this.counter ? ++this.counter : 1;
          var counter = this.counter;
          this._delay(function() {
            if (counter === this.counter) {
              this.refreshPositions(!hardRefresh);
            }
          });
        },
        _clear: function(event, noPropagation) {
          this.reverting = false;
          var i,
              delayedTriggers = [];
          if (!this._noFinalSort && this.currentItem.parent().length) {
            this.placeholder.before(this.currentItem);
          }
          this._noFinalSort = null;
          if (this.helper[0] === this.currentItem[0]) {
            for (i in this._storedCSS) {
              if (this._storedCSS[i] === "auto" || this._storedCSS[i] === "static") {
                this._storedCSS[i] = "";
              }
            }
            this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
          } else {
            this.currentItem.show();
          }
          if (this.fromOutside && !noPropagation) {
            delayedTriggers.push(function(event) {
              this._trigger("receive", event, this._uiHash(this.fromOutside));
            });
          }
          if ((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {
            delayedTriggers.push(function(event) {
              this._trigger("update", event, this._uiHash());
            });
          }
          if (this !== this.currentContainer) {
            if (!noPropagation) {
              delayedTriggers.push(function(event) {
                this._trigger("remove", event, this._uiHash());
              });
              delayedTriggers.push((function(c) {
                return function(event) {
                  c._trigger("receive", event, this._uiHash(this));
                };
              }).call(this, this.currentContainer));
              delayedTriggers.push((function(c) {
                return function(event) {
                  c._trigger("update", event, this._uiHash(this));
                };
              }).call(this, this.currentContainer));
            }
          }
          function delayEvent(type, instance, container) {
            return function(event) {
              container._trigger(type, event, instance._uiHash(instance));
            };
          }
          for (i = this.containers.length - 1; i >= 0; i--) {
            if (!noPropagation) {
              delayedTriggers.push(delayEvent("deactivate", this, this.containers[i]));
            }
            if (this.containers[i].containerCache.over) {
              delayedTriggers.push(delayEvent("out", this, this.containers[i]));
              this.containers[i].containerCache.over = 0;
            }
          }
          if (this.storedCursor) {
            this.document.find("body").css("cursor", this.storedCursor);
            this.storedStylesheet.remove();
          }
          if (this._storedOpacity) {
            this.helper.css("opacity", this._storedOpacity);
          }
          if (this._storedZIndex) {
            this.helper.css("zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex);
          }
          this.dragging = false;
          if (!noPropagation) {
            this._trigger("beforeStop", event, this._uiHash());
          }
          this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
          if (!this.cancelHelperRemoval) {
            if (this.helper[0] !== this.currentItem[0]) {
              this.helper.remove();
            }
            this.helper = null;
          }
          if (!noPropagation) {
            for (i = 0; i < delayedTriggers.length; i++) {
              delayedTriggers[i].call(this, event);
            }
            this._trigger("stop", event, this._uiHash());
          }
          this.fromOutside = false;
          return !this.cancelHelperRemoval;
        },
        _trigger: function() {
          if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
            this.cancel();
          }
        },
        _uiHash: function(_inst) {
          var inst = _inst || this;
          return {
            helper: inst.helper,
            placeholder: inst.placeholder || $([]),
            position: inst.position,
            originalPosition: inst.originalPosition,
            offset: inst.positionAbs,
            item: inst.currentItem,
            sender: _inst ? _inst.element : null
          };
        }
      });
      function spinner_modifier(fn) {
        return function() {
          var previous = this.element.val();
          fn.apply(this, arguments);
          this._refresh();
          if (previous !== this.element.val()) {
            this._trigger("change");
          }
        };
      }
      var spinner = $.widget("ui.spinner", {
        version: "1.11.3",
        defaultElement: "<input>",
        widgetEventPrefix: "spin",
        options: {
          culture: null,
          icons: {
            down: "ui-icon-triangle-1-s",
            up: "ui-icon-triangle-1-n"
          },
          incremental: true,
          max: null,
          min: null,
          numberFormat: null,
          page: 10,
          step: 1,
          change: null,
          spin: null,
          start: null,
          stop: null
        },
        _create: function() {
          this._setOption("max", this.options.max);
          this._setOption("min", this.options.min);
          this._setOption("step", this.options.step);
          if (this.value() !== "") {
            this._value(this.element.val(), true);
          }
          this._draw();
          this._on(this._events);
          this._refresh();
          this._on(this.window, {beforeunload: function() {
              this.element.removeAttr("autocomplete");
            }});
        },
        _getCreateOptions: function() {
          var options = {},
              element = this.element;
          $.each(["min", "max", "step"], function(i, option) {
            var value = element.attr(option);
            if (value !== undefined && value.length) {
              options[option] = value;
            }
          });
          return options;
        },
        _events: {
          keydown: function(event) {
            if (this._start(event) && this._keydown(event)) {
              event.preventDefault();
            }
          },
          keyup: "_stop",
          focus: function() {
            this.previous = this.element.val();
          },
          blur: function(event) {
            if (this.cancelBlur) {
              delete this.cancelBlur;
              return ;
            }
            this._stop();
            this._refresh();
            if (this.previous !== this.element.val()) {
              this._trigger("change", event);
            }
          },
          mousewheel: function(event, delta) {
            if (!delta) {
              return ;
            }
            if (!this.spinning && !this._start(event)) {
              return false;
            }
            this._spin((delta > 0 ? 1 : -1) * this.options.step, event);
            clearTimeout(this.mousewheelTimer);
            this.mousewheelTimer = this._delay(function() {
              if (this.spinning) {
                this._stop(event);
              }
            }, 100);
            event.preventDefault();
          },
          "mousedown .ui-spinner-button": function(event) {
            var previous;
            previous = this.element[0] === this.document[0].activeElement ? this.previous : this.element.val();
            function checkFocus() {
              var isActive = this.element[0] === this.document[0].activeElement;
              if (!isActive) {
                this.element.focus();
                this.previous = previous;
                this._delay(function() {
                  this.previous = previous;
                });
              }
            }
            event.preventDefault();
            checkFocus.call(this);
            this.cancelBlur = true;
            this._delay(function() {
              delete this.cancelBlur;
              checkFocus.call(this);
            });
            if (this._start(event) === false) {
              return ;
            }
            this._repeat(null, $(event.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, event);
          },
          "mouseup .ui-spinner-button": "_stop",
          "mouseenter .ui-spinner-button": function(event) {
            if (!$(event.currentTarget).hasClass("ui-state-active")) {
              return ;
            }
            if (this._start(event) === false) {
              return false;
            }
            this._repeat(null, $(event.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, event);
          },
          "mouseleave .ui-spinner-button": "_stop"
        },
        _draw: function() {
          var uiSpinner = this.uiSpinner = this.element.addClass("ui-spinner-input").attr("autocomplete", "off").wrap(this._uiSpinnerHtml()).parent().append(this._buttonHtml());
          this.element.attr("role", "spinbutton");
          this.buttons = uiSpinner.find(".ui-spinner-button").attr("tabIndex", -1).button().removeClass("ui-corner-all");
          if (this.buttons.height() > Math.ceil(uiSpinner.height() * 0.5) && uiSpinner.height() > 0) {
            uiSpinner.height(uiSpinner.height());
          }
          if (this.options.disabled) {
            this.disable();
          }
        },
        _keydown: function(event) {
          var options = this.options,
              keyCode = $.ui.keyCode;
          switch (event.keyCode) {
            case keyCode.UP:
              this._repeat(null, 1, event);
              return true;
            case keyCode.DOWN:
              this._repeat(null, -1, event);
              return true;
            case keyCode.PAGE_UP:
              this._repeat(null, options.page, event);
              return true;
            case keyCode.PAGE_DOWN:
              this._repeat(null, -options.page, event);
              return true;
          }
          return false;
        },
        _uiSpinnerHtml: function() {
          return "<span class='ui-spinner ui-widget ui-widget-content ui-corner-all'></span>";
        },
        _buttonHtml: function() {
          return "" + "<a class='ui-spinner-button ui-spinner-up ui-corner-tr'>" + "<span class='ui-icon " + this.options.icons.up + "'>&#9650;</span>" + "</a>" + "<a class='ui-spinner-button ui-spinner-down ui-corner-br'>" + "<span class='ui-icon " + this.options.icons.down + "'>&#9660;</span>" + "</a>";
        },
        _start: function(event) {
          if (!this.spinning && this._trigger("start", event) === false) {
            return false;
          }
          if (!this.counter) {
            this.counter = 1;
          }
          this.spinning = true;
          return true;
        },
        _repeat: function(i, steps, event) {
          i = i || 500;
          clearTimeout(this.timer);
          this.timer = this._delay(function() {
            this._repeat(40, steps, event);
          }, i);
          this._spin(steps * this.options.step, event);
        },
        _spin: function(step, event) {
          var value = this.value() || 0;
          if (!this.counter) {
            this.counter = 1;
          }
          value = this._adjustValue(value + step * this._increment(this.counter));
          if (!this.spinning || this._trigger("spin", event, {value: value}) !== false) {
            this._value(value);
            this.counter++;
          }
        },
        _increment: function(i) {
          var incremental = this.options.incremental;
          if (incremental) {
            return $.isFunction(incremental) ? incremental(i) : Math.floor(i * i * i / 50000 - i * i / 500 + 17 * i / 200 + 1);
          }
          return 1;
        },
        _precision: function() {
          var precision = this._precisionOf(this.options.step);
          if (this.options.min !== null) {
            precision = Math.max(precision, this._precisionOf(this.options.min));
          }
          return precision;
        },
        _precisionOf: function(num) {
          var str = num.toString(),
              decimal = str.indexOf(".");
          return decimal === -1 ? 0 : str.length - decimal - 1;
        },
        _adjustValue: function(value) {
          var base,
              aboveMin,
              options = this.options;
          base = options.min !== null ? options.min : 0;
          aboveMin = value - base;
          aboveMin = Math.round(aboveMin / options.step) * options.step;
          value = base + aboveMin;
          value = parseFloat(value.toFixed(this._precision()));
          if (options.max !== null && value > options.max) {
            return options.max;
          }
          if (options.min !== null && value < options.min) {
            return options.min;
          }
          return value;
        },
        _stop: function(event) {
          if (!this.spinning) {
            return ;
          }
          clearTimeout(this.timer);
          clearTimeout(this.mousewheelTimer);
          this.counter = 0;
          this.spinning = false;
          this._trigger("stop", event);
        },
        _setOption: function(key, value) {
          if (key === "culture" || key === "numberFormat") {
            var prevValue = this._parse(this.element.val());
            this.options[key] = value;
            this.element.val(this._format(prevValue));
            return ;
          }
          if (key === "max" || key === "min" || key === "step") {
            if (typeof value === "string") {
              value = this._parse(value);
            }
          }
          if (key === "icons") {
            this.buttons.first().find(".ui-icon").removeClass(this.options.icons.up).addClass(value.up);
            this.buttons.last().find(".ui-icon").removeClass(this.options.icons.down).addClass(value.down);
          }
          this._super(key, value);
          if (key === "disabled") {
            this.widget().toggleClass("ui-state-disabled", !!value);
            this.element.prop("disabled", !!value);
            this.buttons.button(value ? "disable" : "enable");
          }
        },
        _setOptions: spinner_modifier(function(options) {
          this._super(options);
        }),
        _parse: function(val) {
          if (typeof val === "string" && val !== "") {
            val = window.Globalize && this.options.numberFormat ? Globalize.parseFloat(val, 10, this.options.culture) : +val;
          }
          return val === "" || isNaN(val) ? null : val;
        },
        _format: function(value) {
          if (value === "") {
            return "";
          }
          return window.Globalize && this.options.numberFormat ? Globalize.format(value, this.options.numberFormat, this.options.culture) : value;
        },
        _refresh: function() {
          this.element.attr({
            "aria-valuemin": this.options.min,
            "aria-valuemax": this.options.max,
            "aria-valuenow": this._parse(this.element.val())
          });
        },
        isValid: function() {
          var value = this.value();
          if (value === null) {
            return false;
          }
          return value === this._adjustValue(value);
        },
        _value: function(value, allowAny) {
          var parsed;
          if (value !== "") {
            parsed = this._parse(value);
            if (parsed !== null) {
              if (!allowAny) {
                parsed = this._adjustValue(parsed);
              }
              value = this._format(parsed);
            }
          }
          this.element.val(value);
          this._refresh();
        },
        _destroy: function() {
          this.element.removeClass("ui-spinner-input").prop("disabled", false).removeAttr("autocomplete").removeAttr("role").removeAttr("aria-valuemin").removeAttr("aria-valuemax").removeAttr("aria-valuenow");
          this.uiSpinner.replaceWith(this.element);
        },
        stepUp: spinner_modifier(function(steps) {
          this._stepUp(steps);
        }),
        _stepUp: function(steps) {
          if (this._start()) {
            this._spin((steps || 1) * this.options.step);
            this._stop();
          }
        },
        stepDown: spinner_modifier(function(steps) {
          this._stepDown(steps);
        }),
        _stepDown: function(steps) {
          if (this._start()) {
            this._spin((steps || 1) * -this.options.step);
            this._stop();
          }
        },
        pageUp: spinner_modifier(function(pages) {
          this._stepUp((pages || 1) * this.options.page);
        }),
        pageDown: spinner_modifier(function(pages) {
          this._stepDown((pages || 1) * this.options.page);
        }),
        value: function(newVal) {
          if (!arguments.length) {
            return this._parse(this.element.val());
          }
          spinner_modifier(this._value).call(this, newVal);
        },
        widget: function() {
          return this.uiSpinner;
        }
      });
      var tabs = $.widget("ui.tabs", {
        version: "1.11.3",
        delay: 300,
        options: {
          active: null,
          collapsible: false,
          event: "click",
          heightStyle: "content",
          hide: null,
          show: null,
          activate: null,
          beforeActivate: null,
          beforeLoad: null,
          load: null
        },
        _isLocal: (function() {
          var rhash = /#.*$/;
          return function(anchor) {
            var anchorUrl,
                locationUrl;
            anchor = anchor.cloneNode(false);
            anchorUrl = anchor.href.replace(rhash, "");
            locationUrl = location.href.replace(rhash, "");
            try {
              anchorUrl = decodeURIComponent(anchorUrl);
            } catch (error) {}
            try {
              locationUrl = decodeURIComponent(locationUrl);
            } catch (error) {}
            return anchor.hash.length > 1 && anchorUrl === locationUrl;
          };
        })(),
        _create: function() {
          var that = this,
              options = this.options;
          this.running = false;
          this.element.addClass("ui-tabs ui-widget ui-widget-content ui-corner-all").toggleClass("ui-tabs-collapsible", options.collapsible);
          this._processTabs();
          options.active = this._initialActive();
          if ($.isArray(options.disabled)) {
            options.disabled = $.unique(options.disabled.concat($.map(this.tabs.filter(".ui-state-disabled"), function(li) {
              return that.tabs.index(li);
            }))).sort();
          }
          if (this.options.active !== false && this.anchors.length) {
            this.active = this._findActive(options.active);
          } else {
            this.active = $();
          }
          this._refresh();
          if (this.active.length) {
            this.load(options.active);
          }
        },
        _initialActive: function() {
          var active = this.options.active,
              collapsible = this.options.collapsible,
              locationHash = location.hash.substring(1);
          if (active === null) {
            if (locationHash) {
              this.tabs.each(function(i, tab) {
                if ($(tab).attr("aria-controls") === locationHash) {
                  active = i;
                  return false;
                }
              });
            }
            if (active === null) {
              active = this.tabs.index(this.tabs.filter(".ui-tabs-active"));
            }
            if (active === null || active === -1) {
              active = this.tabs.length ? 0 : false;
            }
          }
          if (active !== false) {
            active = this.tabs.index(this.tabs.eq(active));
            if (active === -1) {
              active = collapsible ? false : 0;
            }
          }
          if (!collapsible && active === false && this.anchors.length) {
            active = 0;
          }
          return active;
        },
        _getCreateEventData: function() {
          return {
            tab: this.active,
            panel: !this.active.length ? $() : this._getPanelForTab(this.active)
          };
        },
        _tabKeydown: function(event) {
          var focusedTab = $(this.document[0].activeElement).closest("li"),
              selectedIndex = this.tabs.index(focusedTab),
              goingForward = true;
          if (this._handlePageNav(event)) {
            return ;
          }
          switch (event.keyCode) {
            case $.ui.keyCode.RIGHT:
            case $.ui.keyCode.DOWN:
              selectedIndex++;
              break;
            case $.ui.keyCode.UP:
            case $.ui.keyCode.LEFT:
              goingForward = false;
              selectedIndex--;
              break;
            case $.ui.keyCode.END:
              selectedIndex = this.anchors.length - 1;
              break;
            case $.ui.keyCode.HOME:
              selectedIndex = 0;
              break;
            case $.ui.keyCode.SPACE:
              event.preventDefault();
              clearTimeout(this.activating);
              this._activate(selectedIndex);
              return ;
            case $.ui.keyCode.ENTER:
              event.preventDefault();
              clearTimeout(this.activating);
              this._activate(selectedIndex === this.options.active ? false : selectedIndex);
              return ;
            default:
              return ;
          }
          event.preventDefault();
          clearTimeout(this.activating);
          selectedIndex = this._focusNextTab(selectedIndex, goingForward);
          if (!event.ctrlKey && !event.metaKey) {
            focusedTab.attr("aria-selected", "false");
            this.tabs.eq(selectedIndex).attr("aria-selected", "true");
            this.activating = this._delay(function() {
              this.option("active", selectedIndex);
            }, this.delay);
          }
        },
        _panelKeydown: function(event) {
          if (this._handlePageNav(event)) {
            return ;
          }
          if (event.ctrlKey && event.keyCode === $.ui.keyCode.UP) {
            event.preventDefault();
            this.active.focus();
          }
        },
        _handlePageNav: function(event) {
          if (event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP) {
            this._activate(this._focusNextTab(this.options.active - 1, false));
            return true;
          }
          if (event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN) {
            this._activate(this._focusNextTab(this.options.active + 1, true));
            return true;
          }
        },
        _findNextTab: function(index, goingForward) {
          var lastTabIndex = this.tabs.length - 1;
          function constrain() {
            if (index > lastTabIndex) {
              index = 0;
            }
            if (index < 0) {
              index = lastTabIndex;
            }
            return index;
          }
          while ($.inArray(constrain(), this.options.disabled) !== -1) {
            index = goingForward ? index + 1 : index - 1;
          }
          return index;
        },
        _focusNextTab: function(index, goingForward) {
          index = this._findNextTab(index, goingForward);
          this.tabs.eq(index).focus();
          return index;
        },
        _setOption: function(key, value) {
          if (key === "active") {
            this._activate(value);
            return ;
          }
          if (key === "disabled") {
            this._setupDisabled(value);
            return ;
          }
          this._super(key, value);
          if (key === "collapsible") {
            this.element.toggleClass("ui-tabs-collapsible", value);
            if (!value && this.options.active === false) {
              this._activate(0);
            }
          }
          if (key === "event") {
            this._setupEvents(value);
          }
          if (key === "heightStyle") {
            this._setupHeightStyle(value);
          }
        },
        _sanitizeSelector: function(hash) {
          return hash ? hash.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&") : "";
        },
        refresh: function() {
          var options = this.options,
              lis = this.tablist.children(":has(a[href])");
          options.disabled = $.map(lis.filter(".ui-state-disabled"), function(tab) {
            return lis.index(tab);
          });
          this._processTabs();
          if (options.active === false || !this.anchors.length) {
            options.active = false;
            this.active = $();
          } else if (this.active.length && !$.contains(this.tablist[0], this.active[0])) {
            if (this.tabs.length === options.disabled.length) {
              options.active = false;
              this.active = $();
            } else {
              this._activate(this._findNextTab(Math.max(0, options.active - 1), false));
            }
          } else {
            options.active = this.tabs.index(this.active);
          }
          this._refresh();
        },
        _refresh: function() {
          this._setupDisabled(this.options.disabled);
          this._setupEvents(this.options.event);
          this._setupHeightStyle(this.options.heightStyle);
          this.tabs.not(this.active).attr({
            "aria-selected": "false",
            "aria-expanded": "false",
            tabIndex: -1
          });
          this.panels.not(this._getPanelForTab(this.active)).hide().attr({"aria-hidden": "true"});
          if (!this.active.length) {
            this.tabs.eq(0).attr("tabIndex", 0);
          } else {
            this.active.addClass("ui-tabs-active ui-state-active").attr({
              "aria-selected": "true",
              "aria-expanded": "true",
              tabIndex: 0
            });
            this._getPanelForTab(this.active).show().attr({"aria-hidden": "false"});
          }
        },
        _processTabs: function() {
          var that = this,
              prevTabs = this.tabs,
              prevAnchors = this.anchors,
              prevPanels = this.panels;
          this.tablist = this._getList().addClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all").attr("role", "tablist").delegate("> li", "mousedown" + this.eventNamespace, function(event) {
            if ($(this).is(".ui-state-disabled")) {
              event.preventDefault();
            }
          }).delegate(".ui-tabs-anchor", "focus" + this.eventNamespace, function() {
            if ($(this).closest("li").is(".ui-state-disabled")) {
              this.blur();
            }
          });
          this.tabs = this.tablist.find("> li:has(a[href])").addClass("ui-state-default ui-corner-top").attr({
            role: "tab",
            tabIndex: -1
          });
          this.anchors = this.tabs.map(function() {
            return $("a", this)[0];
          }).addClass("ui-tabs-anchor").attr({
            role: "presentation",
            tabIndex: -1
          });
          this.panels = $();
          this.anchors.each(function(i, anchor) {
            var selector,
                panel,
                panelId,
                anchorId = $(anchor).uniqueId().attr("id"),
                tab = $(anchor).closest("li"),
                originalAriaControls = tab.attr("aria-controls");
            if (that._isLocal(anchor)) {
              selector = anchor.hash;
              panelId = selector.substring(1);
              panel = that.element.find(that._sanitizeSelector(selector));
            } else {
              panelId = tab.attr("aria-controls") || $({}).uniqueId()[0].id;
              selector = "#" + panelId;
              panel = that.element.find(selector);
              if (!panel.length) {
                panel = that._createPanel(panelId);
                panel.insertAfter(that.panels[i - 1] || that.tablist);
              }
              panel.attr("aria-live", "polite");
            }
            if (panel.length) {
              that.panels = that.panels.add(panel);
            }
            if (originalAriaControls) {
              tab.data("ui-tabs-aria-controls", originalAriaControls);
            }
            tab.attr({
              "aria-controls": panelId,
              "aria-labelledby": anchorId
            });
            panel.attr("aria-labelledby", anchorId);
          });
          this.panels.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").attr("role", "tabpanel");
          if (prevTabs) {
            this._off(prevTabs.not(this.tabs));
            this._off(prevAnchors.not(this.anchors));
            this._off(prevPanels.not(this.panels));
          }
        },
        _getList: function() {
          return this.tablist || this.element.find("ol,ul").eq(0);
        },
        _createPanel: function(id) {
          return $("<div>").attr("id", id).addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").data("ui-tabs-destroy", true);
        },
        _setupDisabled: function(disabled) {
          if ($.isArray(disabled)) {
            if (!disabled.length) {
              disabled = false;
            } else if (disabled.length === this.anchors.length) {
              disabled = true;
            }
          }
          for (var i = 0,
              li; (li = this.tabs[i]); i++) {
            if (disabled === true || $.inArray(i, disabled) !== -1) {
              $(li).addClass("ui-state-disabled").attr("aria-disabled", "true");
            } else {
              $(li).removeClass("ui-state-disabled").removeAttr("aria-disabled");
            }
          }
          this.options.disabled = disabled;
        },
        _setupEvents: function(event) {
          var events = {};
          if (event) {
            $.each(event.split(" "), function(index, eventName) {
              events[eventName] = "_eventHandler";
            });
          }
          this._off(this.anchors.add(this.tabs).add(this.panels));
          this._on(true, this.anchors, {click: function(event) {
              event.preventDefault();
            }});
          this._on(this.anchors, events);
          this._on(this.tabs, {keydown: "_tabKeydown"});
          this._on(this.panels, {keydown: "_panelKeydown"});
          this._focusable(this.tabs);
          this._hoverable(this.tabs);
        },
        _setupHeightStyle: function(heightStyle) {
          var maxHeight,
              parent = this.element.parent();
          if (heightStyle === "fill") {
            maxHeight = parent.height();
            maxHeight -= this.element.outerHeight() - this.element.height();
            this.element.siblings(":visible").each(function() {
              var elem = $(this),
                  position = elem.css("position");
              if (position === "absolute" || position === "fixed") {
                return ;
              }
              maxHeight -= elem.outerHeight(true);
            });
            this.element.children().not(this.panels).each(function() {
              maxHeight -= $(this).outerHeight(true);
            });
            this.panels.each(function() {
              $(this).height(Math.max(0, maxHeight - $(this).innerHeight() + $(this).height()));
            }).css("overflow", "auto");
          } else if (heightStyle === "auto") {
            maxHeight = 0;
            this.panels.each(function() {
              maxHeight = Math.max(maxHeight, $(this).height("").height());
            }).height(maxHeight);
          }
        },
        _eventHandler: function(event) {
          var options = this.options,
              active = this.active,
              anchor = $(event.currentTarget),
              tab = anchor.closest("li"),
              clickedIsActive = tab[0] === active[0],
              collapsing = clickedIsActive && options.collapsible,
              toShow = collapsing ? $() : this._getPanelForTab(tab),
              toHide = !active.length ? $() : this._getPanelForTab(active),
              eventData = {
                oldTab: active,
                oldPanel: toHide,
                newTab: collapsing ? $() : tab,
                newPanel: toShow
              };
          event.preventDefault();
          if (tab.hasClass("ui-state-disabled") || tab.hasClass("ui-tabs-loading") || this.running || (clickedIsActive && !options.collapsible) || (this._trigger("beforeActivate", event, eventData) === false)) {
            return ;
          }
          options.active = collapsing ? false : this.tabs.index(tab);
          this.active = clickedIsActive ? $() : tab;
          if (this.xhr) {
            this.xhr.abort();
          }
          if (!toHide.length && !toShow.length) {
            $.error("jQuery UI Tabs: Mismatching fragment identifier.");
          }
          if (toShow.length) {
            this.load(this.tabs.index(tab), event);
          }
          this._toggle(event, eventData);
        },
        _toggle: function(event, eventData) {
          var that = this,
              toShow = eventData.newPanel,
              toHide = eventData.oldPanel;
          this.running = true;
          function complete() {
            that.running = false;
            that._trigger("activate", event, eventData);
          }
          function show() {
            eventData.newTab.closest("li").addClass("ui-tabs-active ui-state-active");
            if (toShow.length && that.options.show) {
              that._show(toShow, that.options.show, complete);
            } else {
              toShow.show();
              complete();
            }
          }
          if (toHide.length && this.options.hide) {
            this._hide(toHide, this.options.hide, function() {
              eventData.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active");
              show();
            });
          } else {
            eventData.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active");
            toHide.hide();
            show();
          }
          toHide.attr("aria-hidden", "true");
          eventData.oldTab.attr({
            "aria-selected": "false",
            "aria-expanded": "false"
          });
          if (toShow.length && toHide.length) {
            eventData.oldTab.attr("tabIndex", -1);
          } else if (toShow.length) {
            this.tabs.filter(function() {
              return $(this).attr("tabIndex") === 0;
            }).attr("tabIndex", -1);
          }
          toShow.attr("aria-hidden", "false");
          eventData.newTab.attr({
            "aria-selected": "true",
            "aria-expanded": "true",
            tabIndex: 0
          });
        },
        _activate: function(index) {
          var anchor,
              active = this._findActive(index);
          if (active[0] === this.active[0]) {
            return ;
          }
          if (!active.length) {
            active = this.active;
          }
          anchor = active.find(".ui-tabs-anchor")[0];
          this._eventHandler({
            target: anchor,
            currentTarget: anchor,
            preventDefault: $.noop
          });
        },
        _findActive: function(index) {
          return index === false ? $() : this.tabs.eq(index);
        },
        _getIndex: function(index) {
          if (typeof index === "string") {
            index = this.anchors.index(this.anchors.filter("[href$='" + index + "']"));
          }
          return index;
        },
        _destroy: function() {
          if (this.xhr) {
            this.xhr.abort();
          }
          this.element.removeClass("ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible");
          this.tablist.removeClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all").removeAttr("role");
          this.anchors.removeClass("ui-tabs-anchor").removeAttr("role").removeAttr("tabIndex").removeUniqueId();
          this.tablist.unbind(this.eventNamespace);
          this.tabs.add(this.panels).each(function() {
            if ($.data(this, "ui-tabs-destroy")) {
              $(this).remove();
            } else {
              $(this).removeClass("ui-state-default ui-state-active ui-state-disabled " + "ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel").removeAttr("tabIndex").removeAttr("aria-live").removeAttr("aria-busy").removeAttr("aria-selected").removeAttr("aria-labelledby").removeAttr("aria-hidden").removeAttr("aria-expanded").removeAttr("role");
            }
          });
          this.tabs.each(function() {
            var li = $(this),
                prev = li.data("ui-tabs-aria-controls");
            if (prev) {
              li.attr("aria-controls", prev).removeData("ui-tabs-aria-controls");
            } else {
              li.removeAttr("aria-controls");
            }
          });
          this.panels.show();
          if (this.options.heightStyle !== "content") {
            this.panels.css("height", "");
          }
        },
        enable: function(index) {
          var disabled = this.options.disabled;
          if (disabled === false) {
            return ;
          }
          if (index === undefined) {
            disabled = false;
          } else {
            index = this._getIndex(index);
            if ($.isArray(disabled)) {
              disabled = $.map(disabled, function(num) {
                return num !== index ? num : null;
              });
            } else {
              disabled = $.map(this.tabs, function(li, num) {
                return num !== index ? num : null;
              });
            }
          }
          this._setupDisabled(disabled);
        },
        disable: function(index) {
          var disabled = this.options.disabled;
          if (disabled === true) {
            return ;
          }
          if (index === undefined) {
            disabled = true;
          } else {
            index = this._getIndex(index);
            if ($.inArray(index, disabled) !== -1) {
              return ;
            }
            if ($.isArray(disabled)) {
              disabled = $.merge([index], disabled).sort();
            } else {
              disabled = [index];
            }
          }
          this._setupDisabled(disabled);
        },
        load: function(index, event) {
          index = this._getIndex(index);
          var that = this,
              tab = this.tabs.eq(index),
              anchor = tab.find(".ui-tabs-anchor"),
              panel = this._getPanelForTab(tab),
              eventData = {
                tab: tab,
                panel: panel
              };
          if (this._isLocal(anchor[0])) {
            return ;
          }
          this.xhr = $.ajax(this._ajaxSettings(anchor, event, eventData));
          if (this.xhr && this.xhr.statusText !== "canceled") {
            tab.addClass("ui-tabs-loading");
            panel.attr("aria-busy", "true");
            this.xhr.success(function(response) {
              setTimeout(function() {
                panel.html(response);
                that._trigger("load", event, eventData);
              }, 1);
            }).complete(function(jqXHR, status) {
              setTimeout(function() {
                if (status === "abort") {
                  that.panels.stop(false, true);
                }
                tab.removeClass("ui-tabs-loading");
                panel.removeAttr("aria-busy");
                if (jqXHR === that.xhr) {
                  delete that.xhr;
                }
              }, 1);
            });
          }
        },
        _ajaxSettings: function(anchor, event, eventData) {
          var that = this;
          return {
            url: anchor.attr("href"),
            beforeSend: function(jqXHR, settings) {
              return that._trigger("beforeLoad", event, $.extend({
                jqXHR: jqXHR,
                ajaxSettings: settings
              }, eventData));
            }
          };
        },
        _getPanelForTab: function(tab) {
          var id = $(tab).attr("aria-controls");
          return this.element.find(this._sanitizeSelector("#" + id));
        }
      });
      var tooltip = $.widget("ui.tooltip", {
        version: "1.11.3",
        options: {
          content: function() {
            var title = $(this).attr("title") || "";
            return $("<a>").text(title).html();
          },
          hide: true,
          items: "[title]:not([disabled])",
          position: {
            my: "left top+15",
            at: "left bottom",
            collision: "flipfit flip"
          },
          show: true,
          tooltipClass: null,
          track: false,
          close: null,
          open: null
        },
        _addDescribedBy: function(elem, id) {
          var describedby = (elem.attr("aria-describedby") || "").split(/\s+/);
          describedby.push(id);
          elem.data("ui-tooltip-id", id).attr("aria-describedby", $.trim(describedby.join(" ")));
        },
        _removeDescribedBy: function(elem) {
          var id = elem.data("ui-tooltip-id"),
              describedby = (elem.attr("aria-describedby") || "").split(/\s+/),
              index = $.inArray(id, describedby);
          if (index !== -1) {
            describedby.splice(index, 1);
          }
          elem.removeData("ui-tooltip-id");
          describedby = $.trim(describedby.join(" "));
          if (describedby) {
            elem.attr("aria-describedby", describedby);
          } else {
            elem.removeAttr("aria-describedby");
          }
        },
        _create: function() {
          this._on({
            mouseover: "open",
            focusin: "open"
          });
          this.tooltips = {};
          this.parents = {};
          if (this.options.disabled) {
            this._disable();
          }
          this.liveRegion = $("<div>").attr({
            role: "log",
            "aria-live": "assertive",
            "aria-relevant": "additions"
          }).addClass("ui-helper-hidden-accessible").appendTo(this.document[0].body);
        },
        _setOption: function(key, value) {
          var that = this;
          if (key === "disabled") {
            this[value ? "_disable" : "_enable"]();
            this.options[key] = value;
            return ;
          }
          this._super(key, value);
          if (key === "content") {
            $.each(this.tooltips, function(id, tooltipData) {
              that._updateContent(tooltipData.element);
            });
          }
        },
        _disable: function() {
          var that = this;
          $.each(this.tooltips, function(id, tooltipData) {
            var event = $.Event("blur");
            event.target = event.currentTarget = tooltipData.element[0];
            that.close(event, true);
          });
          this.element.find(this.options.items).addBack().each(function() {
            var element = $(this);
            if (element.is("[title]")) {
              element.data("ui-tooltip-title", element.attr("title")).removeAttr("title");
            }
          });
        },
        _enable: function() {
          this.element.find(this.options.items).addBack().each(function() {
            var element = $(this);
            if (element.data("ui-tooltip-title")) {
              element.attr("title", element.data("ui-tooltip-title"));
            }
          });
        },
        open: function(event) {
          var that = this,
              target = $(event ? event.target : this.element).closest(this.options.items);
          if (!target.length || target.data("ui-tooltip-id")) {
            return ;
          }
          if (target.attr("title")) {
            target.data("ui-tooltip-title", target.attr("title"));
          }
          target.data("ui-tooltip-open", true);
          if (event && event.type === "mouseover") {
            target.parents().each(function() {
              var parent = $(this),
                  blurEvent;
              if (parent.data("ui-tooltip-open")) {
                blurEvent = $.Event("blur");
                blurEvent.target = blurEvent.currentTarget = this;
                that.close(blurEvent, true);
              }
              if (parent.attr("title")) {
                parent.uniqueId();
                that.parents[this.id] = {
                  element: this,
                  title: parent.attr("title")
                };
                parent.attr("title", "");
              }
            });
          }
          this._updateContent(target, event);
        },
        _updateContent: function(target, event) {
          var content,
              contentOption = this.options.content,
              that = this,
              eventType = event ? event.type : null;
          if (typeof contentOption === "string") {
            return this._open(event, target, contentOption);
          }
          content = contentOption.call(target[0], function(response) {
            if (!target.data("ui-tooltip-open")) {
              return ;
            }
            that._delay(function() {
              if (event) {
                event.type = eventType;
              }
              this._open(event, target, response);
            });
          });
          if (content) {
            this._open(event, target, content);
          }
        },
        _open: function(event, target, content) {
          var tooltipData,
              tooltip,
              events,
              delayedShow,
              a11yContent,
              positionOption = $.extend({}, this.options.position);
          if (!content) {
            return ;
          }
          tooltipData = this._find(target);
          if (tooltipData) {
            tooltipData.tooltip.find(".ui-tooltip-content").html(content);
            return ;
          }
          if (target.is("[title]")) {
            if (event && event.type === "mouseover") {
              target.attr("title", "");
            } else {
              target.removeAttr("title");
            }
          }
          tooltipData = this._tooltip(target);
          tooltip = tooltipData.tooltip;
          this._addDescribedBy(target, tooltip.attr("id"));
          tooltip.find(".ui-tooltip-content").html(content);
          this.liveRegion.children().hide();
          if (content.clone) {
            a11yContent = content.clone();
            a11yContent.removeAttr("id").find("[id]").removeAttr("id");
          } else {
            a11yContent = content;
          }
          $("<div>").html(a11yContent).appendTo(this.liveRegion);
          function position(event) {
            positionOption.of = event;
            if (tooltip.is(":hidden")) {
              return ;
            }
            tooltip.position(positionOption);
          }
          if (this.options.track && event && /^mouse/.test(event.type)) {
            this._on(this.document, {mousemove: position});
            position(event);
          } else {
            tooltip.position($.extend({of: target}, this.options.position));
          }
          tooltip.hide();
          this._show(tooltip, this.options.show);
          if (this.options.show && this.options.show.delay) {
            delayedShow = this.delayedShow = setInterval(function() {
              if (tooltip.is(":visible")) {
                position(positionOption.of);
                clearInterval(delayedShow);
              }
            }, $.fx.interval);
          }
          this._trigger("open", event, {tooltip: tooltip});
          events = {keyup: function(event) {
              if (event.keyCode === $.ui.keyCode.ESCAPE) {
                var fakeEvent = $.Event(event);
                fakeEvent.currentTarget = target[0];
                this.close(fakeEvent, true);
              }
            }};
          if (target[0] !== this.element[0]) {
            events.remove = function() {
              this._removeTooltip(tooltip);
            };
          }
          if (!event || event.type === "mouseover") {
            events.mouseleave = "close";
          }
          if (!event || event.type === "focusin") {
            events.focusout = "close";
          }
          this._on(true, target, events);
        },
        close: function(event) {
          var tooltip,
              that = this,
              target = $(event ? event.currentTarget : this.element),
              tooltipData = this._find(target);
          if (!tooltipData) {
            return ;
          }
          tooltip = tooltipData.tooltip;
          if (tooltipData.closing) {
            return ;
          }
          clearInterval(this.delayedShow);
          if (target.data("ui-tooltip-title") && !target.attr("title")) {
            target.attr("title", target.data("ui-tooltip-title"));
          }
          this._removeDescribedBy(target);
          tooltipData.hiding = true;
          tooltip.stop(true);
          this._hide(tooltip, this.options.hide, function() {
            that._removeTooltip($(this));
          });
          target.removeData("ui-tooltip-open");
          this._off(target, "mouseleave focusout keyup");
          if (target[0] !== this.element[0]) {
            this._off(target, "remove");
          }
          this._off(this.document, "mousemove");
          if (event && event.type === "mouseleave") {
            $.each(this.parents, function(id, parent) {
              $(parent.element).attr("title", parent.title);
              delete that.parents[id];
            });
          }
          tooltipData.closing = true;
          this._trigger("close", event, {tooltip: tooltip});
          if (!tooltipData.hiding) {
            tooltipData.closing = false;
          }
        },
        _tooltip: function(element) {
          var tooltip = $("<div>").attr("role", "tooltip").addClass("ui-tooltip ui-widget ui-corner-all ui-widget-content " + (this.options.tooltipClass || "")),
              id = tooltip.uniqueId().attr("id");
          $("<div>").addClass("ui-tooltip-content").appendTo(tooltip);
          tooltip.appendTo(this.document[0].body);
          return this.tooltips[id] = {
            element: element,
            tooltip: tooltip
          };
        },
        _find: function(target) {
          var id = target.data("ui-tooltip-id");
          return id ? this.tooltips[id] : null;
        },
        _removeTooltip: function(tooltip) {
          tooltip.remove();
          delete this.tooltips[tooltip.attr("id")];
        },
        _destroy: function() {
          var that = this;
          $.each(this.tooltips, function(id, tooltipData) {
            var event = $.Event("blur"),
                element = tooltipData.element;
            event.target = event.currentTarget = element[0];
            that.close(event, true);
            $("#" + id).remove();
            if (element.data("ui-tooltip-title")) {
              if (!element.attr("title")) {
                element.attr("title", element.data("ui-tooltip-title"));
              }
              element.removeData("ui-tooltip-title");
            }
          });
          this.liveRegion.remove();
        }
      });
    }));
  }).call(System.global);
  return System.get("@@global-helpers").retrieveGlobal(__module.id, false);
});



System.register("javascripts/importer", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  function MySystemImporter(system) {
    this.system = system;
    this.importData = function(data) {
      var importNodes = data['nodes'];
      var importLinks = data['links'];
      this.importNodes(importNodes);
      this.importLinks(importLinks);
    };
    this.importNodes = function(importNodes) {
      var newNodes = [];
      var node = null;
      for (var index in importNodes) {
        data = importNodes[index];
        this.system.importNode({
          'key': data.key,
          'data': data
        });
      }
    };
    this.importLinks = function(links) {
      var newLinks = [];
      var link = null;
      for (var key in links) {
        data = links[key];
        this.system.importLink({
          sourceNode: data.sourceNodeKey,
          targetNode: data.targetNodeKey,
          sourceTerminal: data.sourceTerminal,
          targetTerminal: data.targetTerminal,
          title: data.title,
          color: data.color
        });
      }
    };
  }
  module.exports = MySystemImporter;
  global.define = __define;
  return module.exports;
});



System.register("npm:lodash@3.3.1/index", ["github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(process) {
    ;
    (function() {
      var undefined;
      var VERSION = '3.3.1';
      var BIND_FLAG = 1,
          BIND_KEY_FLAG = 2,
          CURRY_BOUND_FLAG = 4,
          CURRY_FLAG = 8,
          CURRY_RIGHT_FLAG = 16,
          PARTIAL_FLAG = 32,
          PARTIAL_RIGHT_FLAG = 64,
          REARG_FLAG = 128,
          ARY_FLAG = 256;
      var DEFAULT_TRUNC_LENGTH = 30,
          DEFAULT_TRUNC_OMISSION = '...';
      var HOT_COUNT = 150,
          HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 0,
          LAZY_MAP_FLAG = 1,
          LAZY_WHILE_FLAG = 2;
      var FUNC_ERROR_TEXT = 'Expected a function';
      var PLACEHOLDER = '__lodash_placeholder__';
      var argsTag = '[object Arguments]',
          arrayTag = '[object Array]',
          boolTag = '[object Boolean]',
          dateTag = '[object Date]',
          errorTag = '[object Error]',
          funcTag = '[object Function]',
          mapTag = '[object Map]',
          numberTag = '[object Number]',
          objectTag = '[object Object]',
          regexpTag = '[object RegExp]',
          setTag = '[object Set]',
          stringTag = '[object String]',
          weakMapTag = '[object WeakMap]';
      var arrayBufferTag = '[object ArrayBuffer]',
          float32Tag = '[object Float32Array]',
          float64Tag = '[object Float64Array]',
          int8Tag = '[object Int8Array]',
          int16Tag = '[object Int16Array]',
          int32Tag = '[object Int32Array]',
          uint8Tag = '[object Uint8Array]',
          uint8ClampedTag = '[object Uint8ClampedArray]',
          uint16Tag = '[object Uint16Array]',
          uint32Tag = '[object Uint32Array]';
      var reEmptyStringLeading = /\b__p \+= '';/g,
          reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
          reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
          reUnescapedHtml = /[&<>"'`]/g,
          reHasEscapedHtml = RegExp(reEscapedHtml.source),
          reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g,
          reEvaluate = /<%([\s\S]+?)%>/g,
          reInterpolate = /<%=([\s\S]+?)%>/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reFuncName = /^\s*function[ \n\r\t]+\w/;
      var reHexPrefix = /^0[xX]/;
      var reHostCtor = /^\[object .+?Constructor\]$/;
      var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;
      var reNoMatch = /($^)/;
      var reRegExpChars = /[.*+?^${}()|[\]\/\\]/g,
          reHasRegExpChars = RegExp(reRegExpChars.source);
      var reThis = /\bthis\b/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var reWords = (function() {
        var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
            lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';
        return RegExp(upper + '{2,}(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
      }());
      var whitespace = (' \t\x0b\f\xa0\ufeff' + '\n\r\u2028\u2029' + '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000');
      var contextProps = ['Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array', 'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number', 'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'document', 'isFinite', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array', 'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap', 'window', 'WinRTError'];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[stringTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[mapTag] = cloneableTags[setTag] = cloneableTags[weakMapTag] = false;
      var debounceOptions = {
        'leading': false,
        'maxWait': 0,
        'trailing': false
      };
      var deburredLetters = {
        '\xc0': 'A',
        '\xc1': 'A',
        '\xc2': 'A',
        '\xc3': 'A',
        '\xc4': 'A',
        '\xc5': 'A',
        '\xe0': 'a',
        '\xe1': 'a',
        '\xe2': 'a',
        '\xe3': 'a',
        '\xe4': 'a',
        '\xe5': 'a',
        '\xc7': 'C',
        '\xe7': 'c',
        '\xd0': 'D',
        '\xf0': 'd',
        '\xc8': 'E',
        '\xc9': 'E',
        '\xca': 'E',
        '\xcb': 'E',
        '\xe8': 'e',
        '\xe9': 'e',
        '\xea': 'e',
        '\xeb': 'e',
        '\xcC': 'I',
        '\xcd': 'I',
        '\xce': 'I',
        '\xcf': 'I',
        '\xeC': 'i',
        '\xed': 'i',
        '\xee': 'i',
        '\xef': 'i',
        '\xd1': 'N',
        '\xf1': 'n',
        '\xd2': 'O',
        '\xd3': 'O',
        '\xd4': 'O',
        '\xd5': 'O',
        '\xd6': 'O',
        '\xd8': 'O',
        '\xf2': 'o',
        '\xf3': 'o',
        '\xf4': 'o',
        '\xf5': 'o',
        '\xf6': 'o',
        '\xf8': 'o',
        '\xd9': 'U',
        '\xda': 'U',
        '\xdb': 'U',
        '\xdc': 'U',
        '\xf9': 'u',
        '\xfa': 'u',
        '\xfb': 'u',
        '\xfc': 'u',
        '\xdd': 'Y',
        '\xfd': 'y',
        '\xff': 'y',
        '\xc6': 'Ae',
        '\xe6': 'ae',
        '\xde': 'Th',
        '\xfe': 'th',
        '\xdf': 'ss'
      };
      var htmlEscapes = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;',
        '`': '&#96;'
      };
      var htmlUnescapes = {
        '&amp;': '&',
        '&lt;': '<',
        '&gt;': '>',
        '&quot;': '"',
        '&#39;': "'",
        '&#96;': '`'
      };
      var objectTypes = {
        'function': true,
        'object': true
      };
      var stringEscapes = {
        '\\': '\\',
        "'": "'",
        '\n': 'n',
        '\r': 'r',
        '\u2028': 'u2028',
        '\u2029': 'u2029'
      };
      var root = (objectTypes[typeof window] && window !== (this && this.window)) ? window : this;
      var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
      var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
      var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;
      if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
        root = freeGlobal;
      }
      var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
      function baseCompareAscending(value, other) {
        if (value !== other) {
          var valIsReflexive = value === value,
              othIsReflexive = other === other;
          if (value > other || !valIsReflexive || (typeof value == 'undefined' && othIsReflexive)) {
            return 1;
          }
          if (value < other || !othIsReflexive || (typeof other == 'undefined' && valIsReflexive)) {
            return -1;
          }
        }
        return 0;
      }
      function baseIndexOf(array, value, fromIndex) {
        if (value !== value) {
          return indexOfNaN(array, fromIndex);
        }
        var index = (fromIndex || 0) - 1,
            length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function baseIsFunction(value) {
        return typeof value == 'function' || false;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseToString(value) {
        if (typeof value == 'string') {
          return value;
        }
        return value == null ? '' : (value + '');
      }
      function charAtCallback(string) {
        return string.charCodeAt(0);
      }
      function charsLeftIndex(string, chars) {
        var index = -1,
            length = string.length;
        while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
        return index;
      }
      function charsRightIndex(string, chars) {
        var index = string.length;
        while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
        return index;
      }
      function compareAscending(object, other) {
        return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
      }
      function compareMultipleAscending(object, other) {
        var index = -1,
            objCriteria = object.criteria,
            othCriteria = other.criteria,
            length = objCriteria.length;
        while (++index < length) {
          var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
          if (result) {
            return result;
          }
        }
        return object.index - other.index;
      }
      function deburrLetter(letter) {
        return deburredLetters[letter];
      }
      function escapeHtmlChar(chr) {
        return htmlEscapes[chr];
      }
      function escapeStringChar(chr) {
        return '\\' + stringEscapes[chr];
      }
      function indexOfNaN(array, fromIndex, fromRight) {
        var length = array.length,
            index = fromRight ? (fromIndex || length) : ((fromIndex || 0) - 1);
        while ((fromRight ? index-- : ++index < length)) {
          var other = array[index];
          if (other !== other) {
            return index;
          }
        }
        return -1;
      }
      function isObjectLike(value) {
        return (value && typeof value == 'object') || false;
      }
      function isSpace(charCode) {
        return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 || (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
      }
      function replaceHolders(array, placeholder) {
        var index = -1,
            length = array.length,
            resIndex = -1,
            result = [];
        while (++index < length) {
          if (array[index] === placeholder) {
            array[index] = PLACEHOLDER;
            result[++resIndex] = index;
          }
        }
        return result;
      }
      function sortedUniq(array, iteratee) {
        var seen,
            index = -1,
            length = array.length,
            resIndex = -1,
            result = [];
        while (++index < length) {
          var value = array[index],
              computed = iteratee ? iteratee(value, index, array) : value;
          if (!index || seen !== computed) {
            seen = computed;
            result[++resIndex] = value;
          }
        }
        return result;
      }
      function trimmedLeftIndex(string) {
        var index = -1,
            length = string.length;
        while (++index < length && isSpace(string.charCodeAt(index))) {}
        return index;
      }
      function trimmedRightIndex(string) {
        var index = string.length;
        while (index-- && isSpace(string.charCodeAt(index))) {}
        return index;
      }
      function unescapeHtmlChar(chr) {
        return htmlUnescapes[chr];
      }
      function runInContext(context) {
        context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
        var Array = context.Array,
            Date = context.Date,
            Error = context.Error,
            Function = context.Function,
            Math = context.Math,
            Number = context.Number,
            Object = context.Object,
            RegExp = context.RegExp,
            String = context.String,
            TypeError = context.TypeError;
        var arrayProto = Array.prototype,
            objectProto = Object.prototype;
        var document = (document = context.window) && document.document;
        var fnToString = Function.prototype.toString;
        var getLength = baseProperty('length');
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var objToString = objectProto.toString;
        var oldDash = context._;
        var reNative = RegExp('^' + escapeRegExp(objToString).replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
        var ArrayBuffer = isNative(ArrayBuffer = context.ArrayBuffer) && ArrayBuffer,
            bufferSlice = isNative(bufferSlice = ArrayBuffer && new ArrayBuffer(0).slice) && bufferSlice,
            ceil = Math.ceil,
            clearTimeout = context.clearTimeout,
            floor = Math.floor,
            getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
            push = arrayProto.push,
            propertyIsEnumerable = objectProto.propertyIsEnumerable,
            Set = isNative(Set = context.Set) && Set,
            setTimeout = context.setTimeout,
            splice = arrayProto.splice,
            Uint8Array = isNative(Uint8Array = context.Uint8Array) && Uint8Array,
            WeakMap = isNative(WeakMap = context.WeakMap) && WeakMap;
        var Float64Array = (function() {
          try {
            var func = isNative(func = context.Float64Array) && func,
                result = new func(new ArrayBuffer(10), 0, 1) && func;
          } catch (e) {}
          return result;
        }());
        var nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
            nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
            nativeIsFinite = context.isFinite,
            nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
            nativeMax = Math.max,
            nativeMin = Math.min,
            nativeNow = isNative(nativeNow = Date.now) && nativeNow,
            nativeNumIsFinite = isNative(nativeNumIsFinite = Number.isFinite) && nativeNumIsFinite,
            nativeParseInt = context.parseInt,
            nativeRandom = Math.random;
        var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
            POSITIVE_INFINITY = Number.POSITIVE_INFINITY;
        var MAX_ARRAY_LENGTH = Math.pow(2, 32) - 1,
            MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
            HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var FLOAT64_BYTES_PER_ELEMENT = Float64Array ? Float64Array.BYTES_PER_ELEMENT : 0;
        var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;
        var metaMap = WeakMap && new WeakMap;
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        function baseLodash() {}
        function LodashWrapper(value, chainAll, actions) {
          this.__wrapped__ = value;
          this.__actions__ = actions || [];
          this.__chain__ = !!chainAll;
        }
        var support = lodash.support = {};
        (function(x) {
          support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);
          support.funcNames = typeof Function.name == 'string';
          try {
            support.dom = document.createDocumentFragment().nodeType === 11;
          } catch (e) {
            support.dom = false;
          }
          try {
            support.nonEnumArgs = !propertyIsEnumerable.call(arguments, 1);
          } catch (e) {
            support.nonEnumArgs = true;
          }
        }(0, 0));
        lodash.templateSettings = {
          'escape': reEscape,
          'evaluate': reEvaluate,
          'interpolate': reInterpolate,
          'variable': '',
          'imports': {'_': lodash}
        };
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = null;
          this.__dir__ = 1;
          this.__dropCount__ = 0;
          this.__filtered__ = false;
          this.__iteratees__ = null;
          this.__takeCount__ = POSITIVE_INFINITY;
          this.__views__ = null;
        }
        function lazyClone() {
          var actions = this.__actions__,
              iteratees = this.__iteratees__,
              views = this.__views__,
              result = new LazyWrapper(this.__wrapped__);
          result.__actions__ = actions ? arrayCopy(actions) : null;
          result.__dir__ = this.__dir__;
          result.__dropCount__ = this.__dropCount__;
          result.__filtered__ = this.__filtered__;
          result.__iteratees__ = iteratees ? arrayCopy(iteratees) : null;
          result.__takeCount__ = this.__takeCount__;
          result.__views__ = views ? arrayCopy(views) : null;
          return result;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result = new LazyWrapper(this);
            result.__dir__ = -1;
            result.__filtered__ = true;
          } else {
            result = this.clone();
            result.__dir__ *= -1;
          }
          return result;
        }
        function lazyValue() {
          var array = this.__wrapped__.value();
          if (!isArray(array)) {
            return baseWrapperValue(array, this.__actions__);
          }
          var dir = this.__dir__,
              isRight = dir < 0,
              view = getView(0, array.length, this.__views__),
              start = view.start,
              end = view.end,
              length = end - start,
              dropCount = this.__dropCount__,
              takeCount = nativeMin(length, this.__takeCount__),
              index = isRight ? end : start - 1,
              iteratees = this.__iteratees__,
              iterLength = iteratees ? iteratees.length : 0,
              resIndex = 0,
              result = [];
          outer: while (length-- && resIndex < takeCount) {
            index += dir;
            var iterIndex = -1,
                value = array[index];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex],
                  iteratee = data.iteratee,
                  computed = iteratee(value, index, array),
                  type = data.type;
              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            if (dropCount) {
              dropCount--;
            } else {
              result[resIndex++] = value;
            }
          }
          return result;
        }
        function MapCache() {
          this.__data__ = {};
        }
        function mapDelete(key) {
          return this.has(key) && delete this.__data__[key];
        }
        function mapGet(key) {
          return key == '__proto__' ? undefined : this.__data__[key];
        }
        function mapHas(key) {
          return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
        }
        function mapSet(key, value) {
          if (key != '__proto__') {
            this.__data__[key] = value;
          }
          return this;
        }
        function SetCache(values) {
          var length = values ? values.length : 0;
          this.data = {
            'hash': nativeCreate(null),
            'set': new Set
          };
          while (length--) {
            this.push(values[length]);
          }
        }
        function cacheIndexOf(cache, value) {
          var data = cache.data,
              result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];
          return result ? 0 : -1;
        }
        function cachePush(value) {
          var data = this.data;
          if (typeof value == 'string' || isObject(value)) {
            data.set.add(value);
          } else {
            data.hash[value] = true;
          }
        }
        function arrayCopy(source, array) {
          var index = -1,
              length = source.length;
          array || (array = Array(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function arrayEach(array, iteratee) {
          var index = -1,
              length = array.length;
          while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEachRight(array, iteratee) {
          var length = array.length;
          while (length--) {
            if (iteratee(array[length], length, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEvery(array, predicate) {
          var index = -1,
              length = array.length;
          while (++index < length) {
            if (!predicate(array[index], index, array)) {
              return false;
            }
          }
          return true;
        }
        function arrayFilter(array, predicate) {
          var index = -1,
              length = array.length,
              resIndex = -1,
              result = [];
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result[++resIndex] = value;
            }
          }
          return result;
        }
        function arrayMap(array, iteratee) {
          var index = -1,
              length = array.length,
              result = Array(length);
          while (++index < length) {
            result[index] = iteratee(array[index], index, array);
          }
          return result;
        }
        function arrayMax(array) {
          var index = -1,
              length = array.length,
              result = NEGATIVE_INFINITY;
          while (++index < length) {
            var value = array[index];
            if (value > result) {
              result = value;
            }
          }
          return result;
        }
        function arrayMin(array) {
          var index = -1,
              length = array.length,
              result = POSITIVE_INFINITY;
          while (++index < length) {
            var value = array[index];
            if (value < result) {
              result = value;
            }
          }
          return result;
        }
        function arrayReduce(array, iteratee, accumulator, initFromArray) {
          var index = -1,
              length = array.length;
          if (initFromArray && length) {
            accumulator = array[++index];
          }
          while (++index < length) {
            accumulator = iteratee(accumulator, array[index], index, array);
          }
          return accumulator;
        }
        function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
          var length = array.length;
          if (initFromArray && length) {
            accumulator = array[--length];
          }
          while (length--) {
            accumulator = iteratee(accumulator, array[length], length, array);
          }
          return accumulator;
        }
        function arraySome(array, predicate) {
          var index = -1,
              length = array.length;
          while (++index < length) {
            if (predicate(array[index], index, array)) {
              return true;
            }
          }
          return false;
        }
        function assignDefaults(objectValue, sourceValue) {
          return typeof objectValue == 'undefined' ? sourceValue : objectValue;
        }
        function assignOwnDefaults(objectValue, sourceValue, key, object) {
          return (typeof objectValue == 'undefined' || !hasOwnProperty.call(object, key)) ? sourceValue : objectValue;
        }
        function baseAssign(object, source, customizer) {
          var props = keys(source);
          if (!customizer) {
            return baseCopy(source, object, props);
          }
          var index = -1,
              length = props.length;
          while (++index < length) {
            var key = props[index],
                value = object[key],
                result = customizer(value, source[key], key, object, source);
            if ((result === result ? result !== value : value === value) || (typeof value == 'undefined' && !(key in object))) {
              object[key] = result;
            }
          }
          return object;
        }
        function baseAt(collection, props) {
          var index = -1,
              length = collection.length,
              isArr = isLength(length),
              propsLength = props.length,
              result = Array(propsLength);
          while (++index < propsLength) {
            var key = props[index];
            if (isArr) {
              key = parseFloat(key);
              result[index] = isIndex(key, length) ? collection[key] : undefined;
            } else {
              result[index] = collection[key];
            }
          }
          return result;
        }
        function baseCopy(source, object, props) {
          if (!props) {
            props = object;
            object = {};
          }
          var index = -1,
              length = props.length;
          while (++index < length) {
            var key = props[index];
            object[key] = source[key];
          }
          return object;
        }
        function baseBindAll(object, methodNames) {
          var index = -1,
              length = methodNames.length;
          while (++index < length) {
            var key = methodNames[index];
            object[key] = createWrapper(object[key], BIND_FLAG, object);
          }
          return object;
        }
        function baseCallback(func, thisArg, argCount) {
          var type = typeof func;
          if (type == 'function') {
            return (typeof thisArg != 'undefined' && isBindable(func)) ? bindCallback(func, thisArg, argCount) : func;
          }
          if (func == null) {
            return identity;
          }
          if (type == 'object') {
            return baseMatches(func);
          }
          return typeof thisArg == 'undefined' ? baseProperty(func + '') : baseMatchesProperty(func + '', thisArg);
        }
        function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
          var result;
          if (customizer) {
            result = object ? customizer(value, key, object) : customizer(value);
          }
          if (typeof result != 'undefined') {
            return result;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result = initCloneArray(value);
            if (!isDeep) {
              return arrayCopy(value, result);
            }
          } else {
            var tag = objToString.call(value),
                isFunc = tag == funcTag;
            if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
              result = initCloneObject(isFunc ? {} : value);
              if (!isDeep) {
                return baseCopy(value, result, keys(value));
              }
            } else {
              return cloneableTags[tag] ? initCloneByTag(value, tag, isDeep) : (object ? value : {});
            }
          }
          stackA || (stackA = []);
          stackB || (stackB = []);
          var length = stackA.length;
          while (length--) {
            if (stackA[length] == value) {
              return stackB[length];
            }
          }
          stackA.push(value);
          stackB.push(result);
          (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
            result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
          });
          return result;
        }
        var baseCreate = (function() {
          function Object() {}
          return function(prototype) {
            if (isObject(prototype)) {
              Object.prototype = prototype;
              var result = new Object;
              Object.prototype = null;
            }
            return result || context.Object();
          };
        }());
        function baseDelay(func, wait, args, fromIndex) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return setTimeout(function() {
            func.apply(undefined, baseSlice(args, fromIndex));
          }, wait);
        }
        function baseDifference(array, values) {
          var length = array ? array.length : 0,
              result = [];
          if (!length) {
            return result;
          }
          var index = -1,
              indexOf = getIndexOf(),
              isCommon = indexOf == baseIndexOf,
              cache = (isCommon && values.length >= 200) ? createCache(values) : null,
              valuesLength = values.length;
          if (cache) {
            indexOf = cacheIndexOf;
            isCommon = false;
            values = cache;
          }
          outer: while (++index < length) {
            var value = array[index];
            if (isCommon && value === value) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values[valuesIndex] === value) {
                  continue outer;
                }
              }
              result.push(value);
            } else if (indexOf(values, value) < 0) {
              result.push(value);
            }
          }
          return result;
        }
        function baseEach(collection, iteratee) {
          var length = collection ? collection.length : 0;
          if (!isLength(length)) {
            return baseForOwn(collection, iteratee);
          }
          var index = -1,
              iterable = toObject(collection);
          while (++index < length) {
            if (iteratee(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        }
        function baseEachRight(collection, iteratee) {
          var length = collection ? collection.length : 0;
          if (!isLength(length)) {
            return baseForOwnRight(collection, iteratee);
          }
          var iterable = toObject(collection);
          while (length--) {
            if (iteratee(iterable[length], length, iterable) === false) {
              break;
            }
          }
          return collection;
        }
        function baseEvery(collection, predicate) {
          var result = true;
          baseEach(collection, function(value, index, collection) {
            result = !!predicate(value, index, collection);
            return result;
          });
          return result;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = start == null ? 0 : (+start || 0);
          if (start < 0) {
            start = -start > length ? 0 : (length + start);
          }
          end = (typeof end == 'undefined' || end > length) ? length : (+end || 0);
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end >>> 0;
          start >>>= 0;
          while (start < length) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result = [];
          baseEach(collection, function(value, index, collection) {
            if (predicate(value, index, collection)) {
              result.push(value);
            }
          });
          return result;
        }
        function baseFind(collection, predicate, eachFunc, retKey) {
          var result;
          eachFunc(collection, function(value, key, collection) {
            if (predicate(value, key, collection)) {
              result = retKey ? key : value;
              return false;
            }
          });
          return result;
        }
        function baseFlatten(array, isDeep, isStrict, fromIndex) {
          var index = (fromIndex || 0) - 1,
              length = array.length,
              resIndex = -1,
              result = [];
          while (++index < length) {
            var value = array[index];
            if (isObjectLike(value) && isLength(value.length) && (isArray(value) || isArguments(value))) {
              if (isDeep) {
                value = baseFlatten(value, isDeep, isStrict);
              }
              var valIndex = -1,
                  valLength = value.length;
              result.length += valLength;
              while (++valIndex < valLength) {
                result[++resIndex] = value[valIndex];
              }
            } else if (!isStrict) {
              result[++resIndex] = value;
            }
          }
          return result;
        }
        function baseFor(object, iteratee, keysFunc) {
          var index = -1,
              iterable = toObject(object),
              props = keysFunc(object),
              length = props.length;
          while (++index < length) {
            var key = props[index];
            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        }
        function baseForRight(object, iteratee, keysFunc) {
          var iterable = toObject(object),
              props = keysFunc(object),
              length = props.length;
          while (length--) {
            var key = props[length];
            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        }
        function baseForIn(object, iteratee) {
          return baseFor(object, iteratee, keysIn);
        }
        function baseForOwn(object, iteratee) {
          return baseFor(object, iteratee, keys);
        }
        function baseForOwnRight(object, iteratee) {
          return baseForRight(object, iteratee, keys);
        }
        function baseFunctions(object, props) {
          var index = -1,
              length = props.length,
              resIndex = -1,
              result = [];
          while (++index < length) {
            var key = props[index];
            if (isFunction(object[key])) {
              result[++resIndex] = key;
            }
          }
          return result;
        }
        function baseInvoke(collection, methodName, args) {
          var index = -1,
              isFunc = typeof methodName == 'function',
              length = collection ? collection.length : 0,
              result = isLength(length) ? Array(length) : [];
          baseEach(collection, function(value) {
            var func = isFunc ? methodName : (value != null && value[methodName]);
            result[++index] = func ? func.apply(value, args) : undefined;
          });
          return result;
        }
        function baseIsEqual(value, other, customizer, isWhere, stackA, stackB) {
          if (value === other) {
            return value !== 0 || (1 / value == 1 / other);
          }
          var valType = typeof value,
              othType = typeof other;
          if ((valType != 'function' && valType != 'object' && othType != 'function' && othType != 'object') || value == null || other == null) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, baseIsEqual, customizer, isWhere, stackA, stackB);
        }
        function baseIsEqualDeep(object, other, equalFunc, customizer, isWhere, stackA, stackB) {
          var objIsArr = isArray(object),
              othIsArr = isArray(other),
              objTag = arrayTag,
              othTag = arrayTag;
          if (!objIsArr) {
            objTag = objToString.call(object);
            if (objTag == argsTag) {
              objTag = objectTag;
            } else if (objTag != objectTag) {
              objIsArr = isTypedArray(object);
            }
          }
          if (!othIsArr) {
            othTag = objToString.call(other);
            if (othTag == argsTag) {
              othTag = objectTag;
            } else if (othTag != objectTag) {
              othIsArr = isTypedArray(other);
            }
          }
          var objIsObj = objTag == objectTag,
              othIsObj = othTag == objectTag,
              isSameTag = objTag == othTag;
          if (isSameTag && !(objIsArr || objIsObj)) {
            return equalByTag(object, other, objTag);
          }
          var valWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
              othWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
          if (valWrapped || othWrapped) {
            return equalFunc(valWrapped ? object.value() : object, othWrapped ? other.value() : other, customizer, isWhere, stackA, stackB);
          }
          if (!isSameTag) {
            return false;
          }
          stackA || (stackA = []);
          stackB || (stackB = []);
          var length = stackA.length;
          while (length--) {
            if (stackA[length] == object) {
              return stackB[length] == other;
            }
          }
          stackA.push(object);
          stackB.push(other);
          var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isWhere, stackA, stackB);
          stackA.pop();
          stackB.pop();
          return result;
        }
        function baseIsMatch(object, props, values, strictCompareFlags, customizer) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          var index = -1,
              noCustomizer = !customizer;
          while (++index < length) {
            if ((noCustomizer && strictCompareFlags[index]) ? values[index] !== object[props[index]] : !hasOwnProperty.call(object, props[index])) {
              return false;
            }
          }
          index = -1;
          while (++index < length) {
            var key = props[index];
            if (noCustomizer && strictCompareFlags[index]) {
              var result = hasOwnProperty.call(object, key);
            } else {
              var objValue = object[key],
                  srcValue = values[index];
              result = customizer ? customizer(objValue, srcValue, key) : undefined;
              if (typeof result == 'undefined') {
                result = baseIsEqual(srcValue, objValue, customizer, true);
              }
            }
            if (!result) {
              return false;
            }
          }
          return true;
        }
        function baseMap(collection, iteratee) {
          var result = [];
          baseEach(collection, function(value, key, collection) {
            result.push(iteratee(value, key, collection));
          });
          return result;
        }
        function baseMatches(source) {
          var props = keys(source),
              length = props.length;
          if (length == 1) {
            var key = props[0],
                value = source[key];
            if (isStrictComparable(value)) {
              return function(object) {
                return object != null && object[key] === value && hasOwnProperty.call(object, key);
              };
            }
          }
          var values = Array(length),
              strictCompareFlags = Array(length);
          while (length--) {
            value = source[props[length]];
            values[length] = value;
            strictCompareFlags[length] = isStrictComparable(value);
          }
          return function(object) {
            return baseIsMatch(object, props, values, strictCompareFlags);
          };
        }
        function baseMatchesProperty(key, value) {
          if (isStrictComparable(value)) {
            return function(object) {
              return object != null && object[key] === value;
            };
          }
          return function(object) {
            return object != null && baseIsEqual(value, object[key], null, true);
          };
        }
        function baseMerge(object, source, customizer, stackA, stackB) {
          if (!isObject(object)) {
            return object;
          }
          var isSrcArr = isLength(source.length) && (isArray(source) || isTypedArray(source));
          (isSrcArr ? arrayEach : baseForOwn)(source, function(srcValue, key, source) {
            if (isObjectLike(srcValue)) {
              stackA || (stackA = []);
              stackB || (stackB = []);
              return baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
            }
            var value = object[key],
                result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
                isCommon = typeof result == 'undefined';
            if (isCommon) {
              result = srcValue;
            }
            if ((isSrcArr || typeof result != 'undefined') && (isCommon || (result === result ? result !== value : value === value))) {
              object[key] = result;
            }
          });
          return object;
        }
        function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
          var length = stackA.length,
              srcValue = source[key];
          while (length--) {
            if (stackA[length] == srcValue) {
              object[key] = stackB[length];
              return ;
            }
          }
          var value = object[key],
              result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
              isCommon = typeof result == 'undefined';
          if (isCommon) {
            result = srcValue;
            if (isLength(srcValue.length) && (isArray(srcValue) || isTypedArray(srcValue))) {
              result = isArray(value) ? value : (value ? arrayCopy(value) : []);
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              result = isArguments(value) ? toPlainObject(value) : (isPlainObject(value) ? value : {});
            } else {
              isCommon = false;
            }
          }
          stackA.push(srcValue);
          stackB.push(result);
          if (isCommon) {
            object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
          } else if (result === result ? result !== value : value === value) {
            object[key] = result;
          }
        }
        function baseProperty(key) {
          return function(object) {
            return object == null ? undefined : object[key];
          };
        }
        function basePullAt(array, indexes) {
          var length = indexes.length,
              result = baseAt(array, indexes);
          indexes.sort(baseCompareAscending);
          while (length--) {
            var index = parseFloat(indexes[length]);
            if (index != previous && isIndex(index)) {
              var previous = index;
              splice.call(array, index, 1);
            }
          }
          return result;
        }
        function baseRandom(min, max) {
          return min + floor(nativeRandom() * (max - min + 1));
        }
        function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
          eachFunc(collection, function(value, index, collection) {
            accumulator = initFromCollection ? (initFromCollection = false, value) : iteratee(accumulator, value, index, collection);
          });
          return accumulator;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        function baseSlice(array, start, end) {
          var index = -1,
              length = array.length;
          start = start == null ? 0 : (+start || 0);
          if (start < 0) {
            start = -start > length ? 0 : (length + start);
          }
          end = (typeof end == 'undefined' || end > length) ? length : (+end || 0);
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : (end - start) >>> 0;
          start >>>= 0;
          var result = Array(length);
          while (++index < length) {
            result[index] = array[index + start];
          }
          return result;
        }
        function baseSome(collection, predicate) {
          var result;
          baseEach(collection, function(value, index, collection) {
            result = predicate(value, index, collection);
            return !result;
          });
          return !!result;
        }
        function baseUniq(array, iteratee) {
          var index = -1,
              indexOf = getIndexOf(),
              length = array.length,
              isCommon = indexOf == baseIndexOf,
              isLarge = isCommon && length >= 200,
              seen = isLarge ? createCache() : null,
              result = [];
          if (seen) {
            indexOf = cacheIndexOf;
            isCommon = false;
          } else {
            isLarge = false;
            seen = iteratee ? [] : result;
          }
          outer: while (++index < length) {
            var value = array[index],
                computed = iteratee ? iteratee(value, index, array) : value;
            if (isCommon && value === value) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee) {
                seen.push(computed);
              }
              result.push(value);
            } else if (indexOf(seen, computed) < 0) {
              if (iteratee || isLarge) {
                seen.push(computed);
              }
              result.push(value);
            }
          }
          return result;
        }
        function baseValues(object, props) {
          var index = -1,
              length = props.length,
              result = Array(length);
          while (++index < length) {
            result[index] = object[props[index]];
          }
          return result;
        }
        function baseWrapperValue(value, actions) {
          var result = value;
          if (result instanceof LazyWrapper) {
            result = result.value();
          }
          var index = -1,
              length = actions.length;
          while (++index < length) {
            var args = [result],
                action = actions[index];
            push.apply(args, action.args);
            result = action.func.apply(action.thisArg, args);
          }
          return result;
        }
        function binaryIndex(array, value, retHighest) {
          var low = 0,
              high = array ? array.length : low;
          if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = (low + high) >>> 1,
                  computed = array[mid];
              if (retHighest ? (computed <= value) : (computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return binaryIndexBy(array, value, identity, retHighest);
        }
        function binaryIndexBy(array, value, iteratee, retHighest) {
          value = iteratee(value);
          var low = 0,
              high = array ? array.length : 0,
              valIsNaN = value !== value,
              valIsUndef = typeof value == 'undefined';
          while (low < high) {
            var mid = floor((low + high) / 2),
                computed = iteratee(array[mid]),
                isReflexive = computed === computed;
            if (valIsNaN) {
              var setLow = isReflexive || retHighest;
            } else if (valIsUndef) {
              setLow = isReflexive && (retHighest || typeof computed != 'undefined');
            } else {
              setLow = retHighest ? (computed <= value) : (computed < value);
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function bindCallback(func, thisArg, argCount) {
          if (typeof func != 'function') {
            return identity;
          }
          if (typeof thisArg == 'undefined') {
            return func;
          }
          switch (argCount) {
            case 1:
              return function(value) {
                return func.call(thisArg, value);
              };
            case 3:
              return function(value, index, collection) {
                return func.call(thisArg, value, index, collection);
              };
            case 4:
              return function(accumulator, value, index, collection) {
                return func.call(thisArg, accumulator, value, index, collection);
              };
            case 5:
              return function(value, other, key, object, source) {
                return func.call(thisArg, value, other, key, object, source);
              };
          }
          return function() {
            return func.apply(thisArg, arguments);
          };
        }
        function bufferClone(buffer) {
          return bufferSlice.call(buffer, 0);
        }
        if (!bufferSlice) {
          bufferClone = !(ArrayBuffer && Uint8Array) ? constant(null) : function(buffer) {
            var byteLength = buffer.byteLength,
                floatLength = Float64Array ? floor(byteLength / FLOAT64_BYTES_PER_ELEMENT) : 0,
                offset = floatLength * FLOAT64_BYTES_PER_ELEMENT,
                result = new ArrayBuffer(byteLength);
            if (floatLength) {
              var view = new Float64Array(result, 0, floatLength);
              view.set(new Float64Array(buffer, 0, floatLength));
            }
            if (byteLength != offset) {
              view = new Uint8Array(result, offset);
              view.set(new Uint8Array(buffer, offset));
            }
            return result;
          };
        }
        function composeArgs(args, partials, holders) {
          var holdersLength = holders.length,
              argsIndex = -1,
              argsLength = nativeMax(args.length - holdersLength, 0),
              leftIndex = -1,
              leftLength = partials.length,
              result = Array(argsLength + leftLength);
          while (++leftIndex < leftLength) {
            result[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            result[holders[argsIndex]] = args[argsIndex];
          }
          while (argsLength--) {
            result[leftIndex++] = args[argsIndex++];
          }
          return result;
        }
        function composeArgsRight(args, partials, holders) {
          var holdersIndex = -1,
              holdersLength = holders.length,
              argsIndex = -1,
              argsLength = nativeMax(args.length - holdersLength, 0),
              rightIndex = -1,
              rightLength = partials.length,
              result = Array(argsLength + rightLength);
          while (++argsIndex < argsLength) {
            result[argsIndex] = args[argsIndex];
          }
          var pad = argsIndex;
          while (++rightIndex < rightLength) {
            result[pad + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            result[pad + holders[holdersIndex]] = args[argsIndex++];
          }
          return result;
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee, thisArg) {
            var result = initializer ? initializer() : {};
            iteratee = getCallback(iteratee, thisArg, 3);
            if (isArray(collection)) {
              var index = -1,
                  length = collection.length;
              while (++index < length) {
                var value = collection[index];
                setter(result, value, iteratee(value, index, collection), collection);
              }
            } else {
              baseEach(collection, function(value, key, collection) {
                setter(result, value, iteratee(value, key, collection), collection);
              });
            }
            return result;
          };
        }
        function createAssigner(assigner) {
          return function() {
            var length = arguments.length,
                object = arguments[0];
            if (length < 2 || object == null) {
              return object;
            }
            if (length > 3 && isIterateeCall(arguments[1], arguments[2], arguments[3])) {
              length = 2;
            }
            if (length > 3 && typeof arguments[length - 2] == 'function') {
              var customizer = bindCallback(arguments[--length - 1], arguments[length--], 5);
            } else if (length > 2 && typeof arguments[length - 1] == 'function') {
              customizer = arguments[--length];
            }
            var index = 0;
            while (++index < length) {
              var source = arguments[index];
              if (source) {
                assigner(object, source, customizer);
              }
            }
            return object;
          };
        }
        function createBindWrapper(func, thisArg) {
          var Ctor = createCtorWrapper(func);
          function wrapper() {
            return (this instanceof wrapper ? Ctor : func).apply(thisArg, arguments);
          }
          return wrapper;
        }
        var createCache = !(nativeCreate && Set) ? constant(null) : function(values) {
          return new SetCache(values);
        };
        function createCompounder(callback) {
          return function(string) {
            var index = -1,
                array = words(deburr(string)),
                length = array.length,
                result = '';
            while (++index < length) {
              result = callback(result, array[index], index);
            }
            return result;
          };
        }
        function createCtorWrapper(Ctor) {
          return function() {
            var thisBinding = baseCreate(Ctor.prototype),
                result = Ctor.apply(thisBinding, arguments);
            return isObject(result) ? result : thisBinding;
          };
        }
        function createExtremum(arrayFunc, isMin) {
          return function(collection, iteratee, thisArg) {
            if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
              iteratee = null;
            }
            var func = getCallback(),
                noIteratee = iteratee == null;
            if (!(func === baseCallback && noIteratee)) {
              noIteratee = false;
              iteratee = func(iteratee, thisArg, 3);
            }
            if (noIteratee) {
              var isArr = isArray(collection);
              if (!isArr && isString(collection)) {
                iteratee = charAtCallback;
              } else {
                return arrayFunc(isArr ? collection : toIterable(collection));
              }
            }
            return extremumBy(collection, iteratee, isMin);
          };
        }
        function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
          var isAry = bitmask & ARY_FLAG,
              isBind = bitmask & BIND_FLAG,
              isBindKey = bitmask & BIND_KEY_FLAG,
              isCurry = bitmask & CURRY_FLAG,
              isCurryBound = bitmask & CURRY_BOUND_FLAG,
              isCurryRight = bitmask & CURRY_RIGHT_FLAG;
          var Ctor = !isBindKey && createCtorWrapper(func),
              key = func;
          function wrapper() {
            var length = arguments.length,
                index = length,
                args = Array(length);
            while (index--) {
              args[index] = arguments[index];
            }
            if (partials) {
              args = composeArgs(args, partials, holders);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight);
            }
            if (isCurry || isCurryRight) {
              var placeholder = wrapper.placeholder,
                  argsHolders = replaceHolders(args, placeholder);
              length -= argsHolders.length;
              if (length < arity) {
                var newArgPos = argPos ? arrayCopy(argPos) : null,
                    newArity = nativeMax(arity - length, 0),
                    newsHolders = isCurry ? argsHolders : null,
                    newHoldersRight = isCurry ? null : argsHolders,
                    newPartials = isCurry ? args : null,
                    newPartialsRight = isCurry ? null : args;
                bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
                bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);
                if (!isCurryBound) {
                  bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
                }
                var result = createHybridWrapper(func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity);
                result.placeholder = placeholder;
                return result;
              }
            }
            var thisBinding = isBind ? thisArg : this;
            if (isBindKey) {
              func = thisBinding[key];
            }
            if (argPos) {
              args = reorder(args, argPos);
            }
            if (isAry && ary < args.length) {
              args.length = ary;
            }
            return (this instanceof wrapper ? (Ctor || createCtorWrapper(func)) : func).apply(thisBinding, args);
          }
          return wrapper;
        }
        function createPad(string, length, chars) {
          var strLength = string.length;
          length = +length;
          if (strLength >= length || !nativeIsFinite(length)) {
            return '';
          }
          var padLength = length - strLength;
          chars = chars == null ? ' ' : (chars + '');
          return repeat(chars, ceil(padLength / chars.length)).slice(0, padLength);
        }
        function createPartialWrapper(func, bitmask, thisArg, partials) {
          var isBind = bitmask & BIND_FLAG,
              Ctor = createCtorWrapper(func);
          function wrapper() {
            var argsIndex = -1,
                argsLength = arguments.length,
                leftIndex = -1,
                leftLength = partials.length,
                args = Array(argsLength + leftLength);
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return (this instanceof wrapper ? Ctor : func).apply(isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
          var isBindKey = bitmask & BIND_KEY_FLAG;
          if (!isBindKey && typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
            partials = holders = null;
          }
          length -= (holders ? holders.length : 0);
          if (bitmask & PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials,
                holdersRight = holders;
            partials = holders = null;
          }
          var data = !isBindKey && getData(func),
              newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];
          if (data && data !== true) {
            mergeData(newData, data);
            bitmask = newData[1];
            arity = newData[9];
          }
          newData[9] = arity == null ? (isBindKey ? 0 : func.length) : (nativeMax(arity - length, 0) || 0);
          if (bitmask == BIND_FLAG) {
            var result = createBindWrapper(newData[0], newData[2]);
          } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
            result = createPartialWrapper.apply(undefined, newData);
          } else {
            result = createHybridWrapper.apply(undefined, newData);
          }
          var setter = data ? baseSetData : setData;
          return setter(result, newData);
        }
        function equalArrays(array, other, equalFunc, customizer, isWhere, stackA, stackB) {
          var index = -1,
              arrLength = array.length,
              othLength = other.length,
              result = true;
          if (arrLength != othLength && !(isWhere && othLength > arrLength)) {
            return false;
          }
          while (result && ++index < arrLength) {
            var arrValue = array[index],
                othValue = other[index];
            result = undefined;
            if (customizer) {
              result = isWhere ? customizer(othValue, arrValue, index) : customizer(arrValue, othValue, index);
            }
            if (typeof result == 'undefined') {
              if (isWhere) {
                var othIndex = othLength;
                while (othIndex--) {
                  othValue = other[othIndex];
                  result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);
                  if (result) {
                    break;
                  }
                }
              } else {
                result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);
              }
            }
          }
          return !!result;
        }
        function equalByTag(object, other, tag) {
          switch (tag) {
            case boolTag:
            case dateTag:
              return +object == +other;
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case numberTag:
              return (object != +object) ? other != +other : (object == 0 ? ((1 / object) == (1 / other)) : object == +other);
            case regexpTag:
            case stringTag:
              return object == (other + '');
          }
          return false;
        }
        function equalObjects(object, other, equalFunc, customizer, isWhere, stackA, stackB) {
          var objProps = keys(object),
              objLength = objProps.length,
              othProps = keys(other),
              othLength = othProps.length;
          if (objLength != othLength && !isWhere) {
            return false;
          }
          var hasCtor,
              index = -1;
          while (++index < objLength) {
            var key = objProps[index],
                result = hasOwnProperty.call(other, key);
            if (result) {
              var objValue = object[key],
                  othValue = other[key];
              result = undefined;
              if (customizer) {
                result = isWhere ? customizer(othValue, objValue, key) : customizer(objValue, othValue, key);
              }
              if (typeof result == 'undefined') {
                result = (objValue && objValue === othValue) || equalFunc(objValue, othValue, customizer, isWhere, stackA, stackB);
              }
            }
            if (!result) {
              return false;
            }
            hasCtor || (hasCtor = key == 'constructor');
          }
          if (!hasCtor) {
            var objCtor = object.constructor,
                othCtor = other.constructor;
            if (objCtor != othCtor && ('constructor' in object && 'constructor' in other) && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
              return false;
            }
          }
          return true;
        }
        function extremumBy(collection, iteratee, isMin) {
          var exValue = isMin ? POSITIVE_INFINITY : NEGATIVE_INFINITY,
              computed = exValue,
              result = computed;
          baseEach(collection, function(value, index, collection) {
            var current = iteratee(value, index, collection);
            if ((isMin ? current < computed : current > computed) || (current === exValue && current === result)) {
              computed = current;
              result = value;
            }
          });
          return result;
        }
        function getCallback(func, thisArg, argCount) {
          var result = lodash.callback || callback;
          result = result === callback ? baseCallback : result;
          return argCount ? result(func, thisArg, argCount) : result;
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getIndexOf(collection, target, fromIndex) {
          var result = lodash.indexOf || indexOf;
          result = result === indexOf ? baseIndexOf : result;
          return collection ? result(collection, target, fromIndex) : result;
        }
        function getView(start, end, transforms) {
          var index = -1,
              length = transforms ? transforms.length : 0;
          while (++index < length) {
            var data = transforms[index],
                size = data.size;
            switch (data.type) {
              case 'drop':
                start += size;
                break;
              case 'dropRight':
                end -= size;
                break;
              case 'take':
                end = nativeMin(end, start + size);
                break;
              case 'takeRight':
                start = nativeMax(start, end - size);
                break;
            }
          }
          return {
            'start': start,
            'end': end
          };
        }
        function initCloneArray(array) {
          var length = array.length,
              result = new array.constructor(length);
          if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
            result.index = array.index;
            result.input = array.input;
          }
          return result;
        }
        function initCloneObject(object) {
          var Ctor = object.constructor;
          if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
            Ctor = Object;
          }
          return new Ctor;
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return bufferClone(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              var buffer = object.buffer;
              return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              var result = new Ctor(object.source, reFlags.exec(object));
              result.lastIndex = object.lastIndex;
          }
          return result;
        }
        function isBindable(func) {
          var support = lodash.support,
              result = !(support.funcNames ? func.name : support.funcDecomp);
          if (!result) {
            var source = fnToString.call(func);
            if (!support.funcNames) {
              result = !reFuncName.test(source);
            }
            if (!result) {
              result = reThis.test(source) || isNative(func);
              baseSetData(func, result);
            }
          }
          return result;
        }
        function isIndex(value, length) {
          value = +value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return value > -1 && value % 1 == 0 && value < length;
        }
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == 'number') {
            var length = object.length,
                prereq = isLength(length) && isIndex(index, length);
          } else {
            prereq = type == 'string' && index in object;
          }
          if (prereq) {
            var other = object[index];
            return value === value ? value === other : other !== other;
          }
          return false;
        }
        function isLength(value) {
          return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isStrictComparable(value) {
          return value === value && (value === 0 ? ((1 / value) > 0) : !isObject(value));
        }
        function mergeData(data, source) {
          var bitmask = data[1],
              srcBitmask = source[1],
              newBitmask = bitmask | srcBitmask;
          var arityFlags = ARY_FLAG | REARG_FLAG,
              bindFlags = BIND_FLAG | BIND_KEY_FLAG,
              comboFlags = arityFlags | bindFlags | CURRY_BOUND_FLAG | CURRY_RIGHT_FLAG;
          var isAry = bitmask & ARY_FLAG && !(srcBitmask & ARY_FLAG),
              isRearg = bitmask & REARG_FLAG && !(srcBitmask & REARG_FLAG),
              argPos = (isRearg ? data : source)[7],
              ary = (isAry ? data : source)[8];
          var isCommon = !(bitmask >= REARG_FLAG && srcBitmask > bindFlags) && !(bitmask > bindFlags && srcBitmask >= REARG_FLAG);
          var isCombo = (newBitmask >= arityFlags && newBitmask <= comboFlags) && (bitmask < REARG_FLAG || ((isRearg || isAry) && argPos.length <= ary));
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
          }
          value = source[7];
          if (value) {
            data[7] = arrayCopy(value);
          }
          if (srcBitmask & ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function pickByArray(object, props) {
          object = toObject(object);
          var index = -1,
              length = props.length,
              result = {};
          while (++index < length) {
            var key = props[index];
            if (key in object) {
              result[key] = object[key];
            }
          }
          return result;
        }
        function pickByCallback(object, predicate) {
          var result = {};
          baseForIn(object, function(value, key, object) {
            if (predicate(value, key, object)) {
              result[key] = value;
            }
          });
          return result;
        }
        function reorder(array, indexes) {
          var arrLength = array.length,
              length = nativeMin(indexes.length, arrLength),
              oldArray = arrayCopy(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
          }
          return array;
        }
        var setData = (function() {
          var count = 0,
              lastCalled = 0;
          return function(key, value) {
            var stamp = now(),
                remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return key;
              }
            } else {
              count = 0;
            }
            return baseSetData(key, value);
          };
        }());
        function shimIsPlainObject(value) {
          var Ctor,
              support = lodash.support;
          if (!(isObjectLike(value) && objToString.call(value) == objectTag) || (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
            return false;
          }
          var result;
          baseForIn(value, function(subValue, key) {
            result = key;
          });
          return typeof result == 'undefined' || hasOwnProperty.call(value, result);
        }
        function shimKeys(object) {
          var props = keysIn(object),
              propsLength = props.length,
              length = propsLength && object.length,
              support = lodash.support;
          var allowIndexes = length && isLength(length) && (isArray(object) || (support.nonEnumArgs && isArguments(object)));
          var index = -1,
              result = [];
          while (++index < propsLength) {
            var key = props[index];
            if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
              result.push(key);
            }
          }
          return result;
        }
        function toIterable(value) {
          if (value == null) {
            return [];
          }
          if (!isLength(value.length)) {
            return values(value);
          }
          return isObject(value) ? value : Object(value);
        }
        function toObject(value) {
          return isObject(value) ? value : Object(value);
        }
        function wrapperClone(wrapper) {
          return wrapper instanceof LazyWrapper ? wrapper.clone() : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
        }
        function chunk(array, size, guard) {
          if (guard ? isIterateeCall(array, size, guard) : size == null) {
            size = 1;
          } else {
            size = nativeMax(+size || 1, 1);
          }
          var index = 0,
              length = array ? array.length : 0,
              resIndex = -1,
              result = Array(ceil(length / size));
          while (index < length) {
            result[++resIndex] = baseSlice(array, index, (index += size));
          }
          return result;
        }
        function compact(array) {
          var index = -1,
              length = array ? array.length : 0,
              resIndex = -1,
              result = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result[++resIndex] = value;
            }
          }
          return result;
        }
        function difference() {
          var index = -1,
              length = arguments.length;
          while (++index < length) {
            var value = arguments[index];
            if (isArray(value) || isArguments(value)) {
              break;
            }
          }
          return baseDifference(value, baseFlatten(arguments, false, true, ++index));
        }
        function drop(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          return baseSlice(array, n < 0 ? 0 : n);
        }
        function dropRight(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          n = length - (+n || 0);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate, thisArg) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          predicate = getCallback(predicate, thisArg, 3);
          while (length-- && predicate(array[length], length, array)) {}
          return baseSlice(array, 0, length + 1);
        }
        function dropWhile(array, predicate, thisArg) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          var index = -1;
          predicate = getCallback(predicate, thisArg, 3);
          while (++index < length && predicate(array[index], index, array)) {}
          return baseSlice(array, index);
        }
        function fill(array, value, start, end) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, thisArg) {
          var index = -1,
              length = array ? array.length : 0;
          predicate = getCallback(predicate, thisArg, 3);
          while (++index < length) {
            if (predicate(array[index], index, array)) {
              return index;
            }
          }
          return -1;
        }
        function findLastIndex(array, predicate, thisArg) {
          var length = array ? array.length : 0;
          predicate = getCallback(predicate, thisArg, 3);
          while (length--) {
            if (predicate(array[length], length, array)) {
              return length;
            }
          }
          return -1;
        }
        function first(array) {
          return array ? array[0] : undefined;
        }
        function flatten(array, isDeep, guard) {
          var length = array ? array.length : 0;
          if (guard && isIterateeCall(array, isDeep, guard)) {
            isDeep = false;
          }
          return length ? baseFlatten(array, isDeep) : [];
        }
        function flattenDeep(array) {
          var length = array ? array.length : 0;
          return length ? baseFlatten(array, true) : [];
        }
        function indexOf(array, value, fromIndex) {
          var length = array ? array.length : 0;
          if (!length) {
            return -1;
          }
          if (typeof fromIndex == 'number') {
            fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
          } else if (fromIndex) {
            var index = binaryIndex(array, value),
                other = array[index];
            return (value === value ? value === other : other !== other) ? index : -1;
          }
          return baseIndexOf(array, value, fromIndex);
        }
        function initial(array) {
          return dropRight(array, 1);
        }
        function intersection() {
          var args = [],
              argsIndex = -1,
              argsLength = arguments.length,
              caches = [],
              indexOf = getIndexOf(),
              isCommon = indexOf == baseIndexOf;
          while (++argsIndex < argsLength) {
            var value = arguments[argsIndex];
            if (isArray(value) || isArguments(value)) {
              args.push(value);
              caches.push((isCommon && value.length >= 120) ? createCache(argsIndex && value) : null);
            }
          }
          argsLength = args.length;
          var array = args[0],
              index = -1,
              length = array ? array.length : 0,
              result = [],
              seen = caches[0];
          outer: while (++index < length) {
            value = array[index];
            if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value)) < 0) {
              argsIndex = argsLength;
              while (--argsIndex) {
                var cache = caches[argsIndex];
                if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(value);
              }
              result.push(value);
            }
          }
          return result;
        }
        function last(array) {
          var length = array ? array.length : 0;
          return length ? array[length - 1] : undefined;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array ? array.length : 0;
          if (!length) {
            return -1;
          }
          var index = length;
          if (typeof fromIndex == 'number') {
            index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
          } else if (fromIndex) {
            index = binaryIndex(array, value, true) - 1;
            var other = array[index];
            return (value === value ? value === other : other !== other) ? index : -1;
          }
          if (value !== value) {
            return indexOfNaN(array, index, true);
          }
          while (index--) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }
        function pull() {
          var array = arguments[0];
          if (!(array && array.length)) {
            return array;
          }
          var index = 0,
              indexOf = getIndexOf(),
              length = arguments.length;
          while (++index < length) {
            var fromIndex = 0,
                value = arguments[index];
            while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function pullAt(array) {
          return basePullAt(array || [], baseFlatten(arguments, false, false, 1));
        }
        function remove(array, predicate, thisArg) {
          var index = -1,
              length = array ? array.length : 0,
              result = [];
          predicate = getCallback(predicate, thisArg, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result.push(value);
              splice.call(array, index--, 1);
              length--;
            }
          }
          return result;
        }
        function rest(array) {
          return drop(array, 1);
        }
        function slice(array, start, end) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value, iteratee, thisArg) {
          var func = getCallback(iteratee);
          return (func === baseCallback && iteratee == null) ? binaryIndex(array, value) : binaryIndexBy(array, value, func(iteratee, thisArg, 1));
        }
        function sortedLastIndex(array, value, iteratee, thisArg) {
          var func = getCallback(iteratee);
          return (func === baseCallback && iteratee == null) ? binaryIndex(array, value, true) : binaryIndexBy(array, value, func(iteratee, thisArg, 1), true);
        }
        function take(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          n = length - (+n || 0);
          return baseSlice(array, n < 0 ? 0 : n);
        }
        function takeRightWhile(array, predicate, thisArg) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          predicate = getCallback(predicate, thisArg, 3);
          while (length-- && predicate(array[length], length, array)) {}
          return baseSlice(array, length + 1);
        }
        function takeWhile(array, predicate, thisArg) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          var index = -1;
          predicate = getCallback(predicate, thisArg, 3);
          while (++index < length && predicate(array[index], index, array)) {}
          return baseSlice(array, 0, index);
        }
        function union() {
          return baseUniq(baseFlatten(arguments, false, true));
        }
        function uniq(array, isSorted, iteratee, thisArg) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (isSorted != null && typeof isSorted != 'boolean') {
            thisArg = iteratee;
            iteratee = isIterateeCall(array, isSorted, thisArg) ? null : isSorted;
            isSorted = false;
          }
          var func = getCallback();
          if (!(func === baseCallback && iteratee == null)) {
            iteratee = func(iteratee, thisArg, 3);
          }
          return (isSorted && getIndexOf() == baseIndexOf) ? sortedUniq(array, iteratee) : baseUniq(array, iteratee);
        }
        function unzip(array) {
          var index = -1,
              length = (array && array.length && arrayMax(arrayMap(array, getLength))) >>> 0,
              result = Array(length);
          while (++index < length) {
            result[index] = arrayMap(array, baseProperty(index));
          }
          return result;
        }
        function without(array) {
          return baseDifference(array, baseSlice(arguments, 1));
        }
        function xor() {
          var index = -1,
              length = arguments.length;
          while (++index < length) {
            var array = arguments[index];
            if (isArray(array) || isArguments(array)) {
              var result = result ? baseDifference(result, array).concat(baseDifference(array, result)) : array;
            }
          }
          return result ? baseUniq(result) : [];
        }
        function zip() {
          var length = arguments.length,
              array = Array(length);
          while (length--) {
            array[length] = arguments[length];
          }
          return unzip(array);
        }
        function zipObject(props, values) {
          var index = -1,
              length = props ? props.length : 0,
              result = {};
          if (length && !values && !isArray(props[0])) {
            values = [];
          }
          while (++index < length) {
            var key = props[index];
            if (values) {
              result[key] = values[index];
            } else if (key) {
              result[key[0]] = key[1];
            }
          }
          return result;
        }
        function chain(value) {
          var result = lodash(value);
          result.__chain__ = true;
          return result;
        }
        function tap(value, interceptor, thisArg) {
          interceptor.call(thisArg, value);
          return value;
        }
        function thru(value, interceptor, thisArg) {
          return interceptor.call(thisArg, value);
        }
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperPlant(value) {
          var result,
              parent = this;
          while (parent instanceof baseLodash) {
            var clone = wrapperClone(parent);
            if (result) {
              previous.__wrapped__ = clone;
            } else {
              result = clone;
            }
            var previous = clone;
            parent = parent.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            if (this.__actions__.length) {
              value = new LazyWrapper(this);
            }
            return new LodashWrapper(value.reverse(), this.__chain__);
          }
          return this.thru(function(value) {
            return value.reverse();
          });
        }
        function wrapperToString() {
          return (this.value() + '');
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        function at(collection) {
          var length = collection ? collection.length : 0;
          if (isLength(length)) {
            collection = toIterable(collection);
          }
          return baseAt(collection, baseFlatten(arguments, false, false, 1));
        }
        var countBy = createAggregator(function(result, value, key) {
          hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
        });
        function every(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (typeof predicate != 'function' || typeof thisArg != 'undefined') {
            predicate = getCallback(predicate, thisArg, 3);
          }
          return func(collection, predicate);
        }
        function filter(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          predicate = getCallback(predicate, thisArg, 3);
          return func(collection, predicate);
        }
        function find(collection, predicate, thisArg) {
          if (isArray(collection)) {
            var index = findIndex(collection, predicate, thisArg);
            return index > -1 ? collection[index] : undefined;
          }
          predicate = getCallback(predicate, thisArg, 3);
          return baseFind(collection, predicate, baseEach);
        }
        function findLast(collection, predicate, thisArg) {
          predicate = getCallback(predicate, thisArg, 3);
          return baseFind(collection, predicate, baseEachRight);
        }
        function findWhere(collection, source) {
          return find(collection, baseMatches(source));
        }
        function forEach(collection, iteratee, thisArg) {
          return (typeof iteratee == 'function' && typeof thisArg == 'undefined' && isArray(collection)) ? arrayEach(collection, iteratee) : baseEach(collection, bindCallback(iteratee, thisArg, 3));
        }
        function forEachRight(collection, iteratee, thisArg) {
          return (typeof iteratee == 'function' && typeof thisArg == 'undefined' && isArray(collection)) ? arrayEachRight(collection, iteratee) : baseEachRight(collection, bindCallback(iteratee, thisArg, 3));
        }
        var groupBy = createAggregator(function(result, value, key) {
          if (hasOwnProperty.call(result, key)) {
            result[key].push(value);
          } else {
            result[key] = [value];
          }
        });
        function includes(collection, target, fromIndex) {
          var length = collection ? collection.length : 0;
          if (!isLength(length)) {
            collection = values(collection);
            length = collection.length;
          }
          if (!length) {
            return false;
          }
          if (typeof fromIndex == 'number') {
            fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
          } else {
            fromIndex = 0;
          }
          return (typeof collection == 'string' || !isArray(collection) && isString(collection)) ? (fromIndex < length && collection.indexOf(target, fromIndex) > -1) : (getIndexOf(collection, target, fromIndex) > -1);
        }
        var indexBy = createAggregator(function(result, value, key) {
          result[key] = value;
        });
        function invoke(collection, methodName) {
          return baseInvoke(collection, methodName, baseSlice(arguments, 2));
        }
        function map(collection, iteratee, thisArg) {
          var func = isArray(collection) ? arrayMap : baseMap;
          iteratee = getCallback(iteratee, thisArg, 3);
          return func(collection, iteratee);
        }
        var max = createExtremum(arrayMax);
        var min = createExtremum(arrayMin, true);
        var partition = createAggregator(function(result, value, key) {
          result[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function pluck(collection, key) {
          return map(collection, baseProperty(key));
        }
        function reduce(collection, iteratee, accumulator, thisArg) {
          var func = isArray(collection) ? arrayReduce : baseReduce;
          return func(collection, getCallback(iteratee, thisArg, 4), accumulator, arguments.length < 3, baseEach);
        }
        function reduceRight(collection, iteratee, accumulator, thisArg) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce;
          return func(collection, getCallback(iteratee, thisArg, 4), accumulator, arguments.length < 3, baseEachRight);
        }
        function reject(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          predicate = getCallback(predicate, thisArg, 3);
          return func(collection, function(value, index, collection) {
            return !predicate(value, index, collection);
          });
        }
        function sample(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n == null) {
            collection = toIterable(collection);
            var length = collection.length;
            return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
          }
          var result = shuffle(collection);
          result.length = nativeMin(n < 0 ? 0 : (+n || 0), result.length);
          return result;
        }
        function shuffle(collection) {
          collection = toIterable(collection);
          var index = -1,
              length = collection.length,
              result = Array(length);
          while (++index < length) {
            var rand = baseRandom(0, index);
            if (index != rand) {
              result[index] = result[rand];
            }
            result[rand] = collection[index];
          }
          return result;
        }
        function size(collection) {
          var length = collection ? collection.length : 0;
          return isLength(length) ? length : keys(collection).length;
        }
        function some(collection, predicate, thisArg) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (typeof predicate != 'function' || typeof thisArg != 'undefined') {
            predicate = getCallback(predicate, thisArg, 3);
          }
          return func(collection, predicate);
        }
        function sortBy(collection, iteratee, thisArg) {
          var index = -1,
              length = collection ? collection.length : 0,
              result = isLength(length) ? Array(length) : [];
          if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
            iteratee = null;
          }
          iteratee = getCallback(iteratee, thisArg, 3);
          baseEach(collection, function(value, key, collection) {
            result[++index] = {
              'criteria': iteratee(value, key, collection),
              'index': index,
              'value': value
            };
          });
          return baseSortBy(result, compareAscending);
        }
        function sortByAll(collection) {
          var args = arguments;
          if (args.length > 3 && isIterateeCall(args[1], args[2], args[3])) {
            args = [collection, args[1]];
          }
          var index = -1,
              length = collection ? collection.length : 0,
              props = baseFlatten(args, false, false, 1),
              result = isLength(length) ? Array(length) : [];
          baseEach(collection, function(value) {
            var length = props.length,
                criteria = Array(length);
            while (length--) {
              criteria[length] = value == null ? undefined : value[props[length]];
            }
            result[++index] = {
              'criteria': criteria,
              'index': index,
              'value': value
            };
          });
          return baseSortBy(result, compareMultipleAscending);
        }
        function where(collection, source) {
          return filter(collection, baseMatches(source));
        }
        var now = nativeNow || function() {
          return new Date().getTime();
        };
        function after(n, func) {
          if (typeof func != 'function') {
            if (typeof n == 'function') {
              var temp = n;
              n = func;
              func = temp;
            } else {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
          }
          n = nativeIsFinite(n = +n) ? n : 0;
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          if (guard && isIterateeCall(func, n, guard)) {
            n = null;
          }
          n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
          return createWrapper(func, ARY_FLAG, null, null, null, null, n);
        }
        function before(n, func) {
          var result;
          if (typeof func != 'function') {
            if (typeof n == 'function') {
              var temp = n;
              n = func;
              func = temp;
            } else {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
          }
          return function() {
            if (--n > 0) {
              result = func.apply(this, arguments);
            } else {
              func = null;
            }
            return result;
          };
        }
        function bind(func, thisArg) {
          var bitmask = BIND_FLAG;
          if (arguments.length > 2) {
            var partials = baseSlice(arguments, 2),
                holders = replaceHolders(partials, bind.placeholder);
            bitmask |= PARTIAL_FLAG;
          }
          return createWrapper(func, bitmask, thisArg, partials, holders);
        }
        function bindAll(object) {
          return baseBindAll(object, arguments.length > 1 ? baseFlatten(arguments, false, false, 1) : functions(object));
        }
        function bindKey(object, key) {
          var bitmask = BIND_FLAG | BIND_KEY_FLAG;
          if (arguments.length > 2) {
            var partials = baseSlice(arguments, 2),
                holders = replaceHolders(partials, bindKey.placeholder);
            bitmask |= PARTIAL_FLAG;
          }
          return createWrapper(key, bitmask, object, partials, holders);
        }
        function curry(func, arity, guard) {
          if (guard && isIterateeCall(func, arity, guard)) {
            arity = null;
          }
          var result = createWrapper(func, CURRY_FLAG, null, null, null, null, null, arity);
          result.placeholder = curry.placeholder;
          return result;
        }
        function curryRight(func, arity, guard) {
          if (guard && isIterateeCall(func, arity, guard)) {
            arity = null;
          }
          var result = createWrapper(func, CURRY_RIGHT_FLAG, null, null, null, null, null, arity);
          result.placeholder = curryRight.placeholder;
          return result;
        }
        function debounce(func, wait, options) {
          var args,
              maxTimeoutId,
              result,
              stamp,
              thisArg,
              timeoutId,
              trailingCall,
              lastCalled = 0,
              maxWait = false,
              trailing = true;
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          wait = wait < 0 ? 0 : (+wait || 0);
          if (options === true) {
            var leading = true;
            trailing = false;
          } else if (isObject(options)) {
            leading = options.leading;
            maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
            trailing = 'trailing' in options ? options.trailing : trailing;
          }
          function cancel() {
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            if (maxTimeoutId) {
              clearTimeout(maxTimeoutId);
            }
            maxTimeoutId = timeoutId = trailingCall = undefined;
          }
          function delayed() {
            var remaining = wait - (now() - stamp);
            if (remaining <= 0 || remaining > wait) {
              if (maxTimeoutId) {
                clearTimeout(maxTimeoutId);
              }
              var isCalled = trailingCall;
              maxTimeoutId = timeoutId = trailingCall = undefined;
              if (isCalled) {
                lastCalled = now();
                result = func.apply(thisArg, args);
                if (!timeoutId && !maxTimeoutId) {
                  args = thisArg = null;
                }
              }
            } else {
              timeoutId = setTimeout(delayed, remaining);
            }
          }
          function maxDelayed() {
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            maxTimeoutId = timeoutId = trailingCall = undefined;
            if (trailing || (maxWait !== wait)) {
              lastCalled = now();
              result = func.apply(thisArg, args);
              if (!timeoutId && !maxTimeoutId) {
                args = thisArg = null;
              }
            }
          }
          function debounced() {
            args = arguments;
            stamp = now();
            thisArg = this;
            trailingCall = trailing && (timeoutId || !leading);
            if (maxWait === false) {
              var leadingCall = leading && !timeoutId;
            } else {
              if (!maxTimeoutId && !leading) {
                lastCalled = stamp;
              }
              var remaining = maxWait - (stamp - lastCalled),
                  isCalled = remaining <= 0 || remaining > maxWait;
              if (isCalled) {
                if (maxTimeoutId) {
                  maxTimeoutId = clearTimeout(maxTimeoutId);
                }
                lastCalled = stamp;
                result = func.apply(thisArg, args);
              } else if (!maxTimeoutId) {
                maxTimeoutId = setTimeout(maxDelayed, remaining);
              }
            }
            if (isCalled && timeoutId) {
              timeoutId = clearTimeout(timeoutId);
            } else if (!timeoutId && wait !== maxWait) {
              timeoutId = setTimeout(delayed, wait);
            }
            if (leadingCall) {
              isCalled = true;
              result = func.apply(thisArg, args);
            }
            if (isCalled && !timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
            return result;
          }
          debounced.cancel = cancel;
          return debounced;
        }
        function defer(func) {
          return baseDelay(func, 1, arguments, 1);
        }
        function delay(func, wait) {
          return baseDelay(func, wait, arguments, 2);
        }
        function flow() {
          var funcs = arguments,
              length = funcs.length;
          if (!length) {
            return function() {
              return arguments[0];
            };
          }
          if (!arrayEvery(funcs, baseIsFunction)) {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function() {
            var index = 0,
                result = funcs[index].apply(this, arguments);
            while (++index < length) {
              result = funcs[index].call(this, result);
            }
            return result;
          };
        }
        function flowRight() {
          var funcs = arguments,
              fromIndex = funcs.length - 1;
          if (fromIndex < 0) {
            return function() {
              return arguments[0];
            };
          }
          if (!arrayEvery(funcs, baseIsFunction)) {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function() {
            var index = fromIndex,
                result = funcs[index].apply(this, arguments);
            while (index--) {
              result = funcs[index].call(this, result);
            }
            return result;
          };
        }
        function memoize(func, resolver) {
          if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var cache = memoized.cache,
                key = resolver ? resolver.apply(this, arguments) : arguments[0];
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result = func.apply(this, arguments);
            cache.set(key, result);
            return result;
          };
          memoized.cache = new memoize.Cache;
          return memoized;
        }
        function negate(predicate) {
          if (typeof predicate != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function() {
            return !predicate.apply(this, arguments);
          };
        }
        function once(func) {
          return before(func, 2);
        }
        function partial(func) {
          var partials = baseSlice(arguments, 1),
              holders = replaceHolders(partials, partial.placeholder);
          return createWrapper(func, PARTIAL_FLAG, null, partials, holders);
        }
        function partialRight(func) {
          var partials = baseSlice(arguments, 1),
              holders = replaceHolders(partials, partialRight.placeholder);
          return createWrapper(func, PARTIAL_RIGHT_FLAG, null, partials, holders);
        }
        function rearg(func) {
          var indexes = baseFlatten(arguments, false, false, 1);
          return createWrapper(func, REARG_FLAG, null, null, null, indexes);
        }
        function spread(func) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function(array) {
            return func.apply(this, array);
          };
        }
        function throttle(func, wait, options) {
          var leading = true,
              trailing = true;
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (options === false) {
            leading = false;
          } else if (isObject(options)) {
            leading = 'leading' in options ? !!options.leading : leading;
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }
          debounceOptions.leading = leading;
          debounceOptions.maxWait = +wait;
          debounceOptions.trailing = trailing;
          return debounce(func, wait, debounceOptions);
        }
        function wrap(value, wrapper) {
          wrapper = wrapper == null ? identity : wrapper;
          return createWrapper(wrapper, PARTIAL_FLAG, null, [value], []);
        }
        function clone(value, isDeep, customizer, thisArg) {
          if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
            isDeep = false;
          } else if (typeof isDeep == 'function') {
            thisArg = customizer;
            customizer = isDeep;
            isDeep = false;
          }
          customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);
          return baseClone(value, isDeep, customizer);
        }
        function cloneDeep(value, customizer, thisArg) {
          customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);
          return baseClone(value, true, customizer);
        }
        function isArguments(value) {
          var length = isObjectLike(value) ? value.length : undefined;
          return (isLength(length) && objToString.call(value) == argsTag) || false;
        }
        var isArray = nativeIsArray || function(value) {
          return (isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag) || false;
        };
        function isBoolean(value) {
          return (value === true || value === false || isObjectLike(value) && objToString.call(value) == boolTag) || false;
        }
        function isDate(value) {
          return (isObjectLike(value) && objToString.call(value) == dateTag) || false;
        }
        function isElement(value) {
          return (value && value.nodeType === 1 && isObjectLike(value) && objToString.call(value).indexOf('Element') > -1) || false;
        }
        if (!support.dom) {
          isElement = function(value) {
            return (value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value)) || false;
          };
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          var length = value.length;
          if (isLength(length) && (isArray(value) || isString(value) || isArguments(value) || (isObjectLike(value) && isFunction(value.splice)))) {
            return !length;
          }
          return !keys(value).length;
        }
        function isEqual(value, other, customizer, thisArg) {
          customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 3);
          if (!customizer && isStrictComparable(value) && isStrictComparable(other)) {
            return value === other;
          }
          var result = customizer ? customizer(value, other) : undefined;
          return typeof result == 'undefined' ? baseIsEqual(value, other, customizer) : !!result;
        }
        function isError(value) {
          return (isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag) || false;
        }
        var isFinite = nativeNumIsFinite || function(value) {
          return typeof value == 'number' && nativeIsFinite(value);
        };
        var isFunction = !(baseIsFunction(/x/) || (Uint8Array && !baseIsFunction(Uint8Array))) ? baseIsFunction : function(value) {
          return objToString.call(value) == funcTag;
        };
        function isObject(value) {
          var type = typeof value;
          return type == 'function' || (value && type == 'object') || false;
        }
        function isMatch(object, source, customizer, thisArg) {
          var props = keys(source),
              length = props.length;
          customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 3);
          if (!customizer && length == 1) {
            var key = props[0],
                value = source[key];
            if (isStrictComparable(value)) {
              return object != null && value === object[key] && hasOwnProperty.call(object, key);
            }
          }
          var values = Array(length),
              strictCompareFlags = Array(length);
          while (length--) {
            value = values[length] = source[props[length]];
            strictCompareFlags[length] = isStrictComparable(value);
          }
          return baseIsMatch(object, props, values, strictCompareFlags, customizer);
        }
        function isNaN(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (value == null) {
            return false;
          }
          if (objToString.call(value) == funcTag) {
            return reNative.test(fnToString.call(value));
          }
          return (isObjectLike(value) && reHostCtor.test(value)) || false;
        }
        function isNull(value) {
          return value === null;
        }
        function isNumber(value) {
          return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag) || false;
        }
        var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
          if (!(value && objToString.call(value) == objectTag)) {
            return false;
          }
          var valueOf = value.valueOf,
              objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
          return objProto ? (value == objProto || getPrototypeOf(value) == objProto) : shimIsPlainObject(value);
        };
        function isRegExp(value) {
          return (isObjectLike(value) && objToString.call(value) == regexpTag) || false;
        }
        function isString(value) {
          return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag) || false;
        }
        function isTypedArray(value) {
          return (isObjectLike(value) && isLength(value.length) && typedArrayTags[objToString.call(value)]) || false;
        }
        function isUndefined(value) {
          return typeof value == 'undefined';
        }
        function toArray(value) {
          var length = value ? value.length : 0;
          if (!isLength(length)) {
            return values(value);
          }
          if (!length) {
            return [];
          }
          return arrayCopy(value);
        }
        function toPlainObject(value) {
          return baseCopy(value, keysIn(value));
        }
        var assign = createAssigner(baseAssign);
        function create(prototype, properties, guard) {
          var result = baseCreate(prototype);
          if (guard && isIterateeCall(prototype, properties, guard)) {
            properties = null;
          }
          return properties ? baseCopy(properties, result, keys(properties)) : result;
        }
        function defaults(object) {
          if (object == null) {
            return object;
          }
          var args = arrayCopy(arguments);
          args.push(assignDefaults);
          return assign.apply(undefined, args);
        }
        function findKey(object, predicate, thisArg) {
          predicate = getCallback(predicate, thisArg, 3);
          return baseFind(object, predicate, baseForOwn, true);
        }
        function findLastKey(object, predicate, thisArg) {
          predicate = getCallback(predicate, thisArg, 3);
          return baseFind(object, predicate, baseForOwnRight, true);
        }
        function forIn(object, iteratee, thisArg) {
          if (typeof iteratee != 'function' || typeof thisArg != 'undefined') {
            iteratee = bindCallback(iteratee, thisArg, 3);
          }
          return baseFor(object, iteratee, keysIn);
        }
        function forInRight(object, iteratee, thisArg) {
          iteratee = bindCallback(iteratee, thisArg, 3);
          return baseForRight(object, iteratee, keysIn);
        }
        function forOwn(object, iteratee, thisArg) {
          if (typeof iteratee != 'function' || typeof thisArg != 'undefined') {
            iteratee = bindCallback(iteratee, thisArg, 3);
          }
          return baseForOwn(object, iteratee);
        }
        function forOwnRight(object, iteratee, thisArg) {
          iteratee = bindCallback(iteratee, thisArg, 3);
          return baseForRight(object, iteratee, keys);
        }
        function functions(object) {
          return baseFunctions(object, keysIn(object));
        }
        function has(object, key) {
          return object ? hasOwnProperty.call(object, key) : false;
        }
        function invert(object, multiValue, guard) {
          if (guard && isIterateeCall(object, multiValue, guard)) {
            multiValue = null;
          }
          var index = -1,
              props = keys(object),
              length = props.length,
              result = {};
          while (++index < length) {
            var key = props[index],
                value = object[key];
            if (multiValue) {
              if (hasOwnProperty.call(result, value)) {
                result[value].push(key);
              } else {
                result[value] = [key];
              }
            } else {
              result[value] = key;
            }
          }
          return result;
        }
        var keys = !nativeKeys ? shimKeys : function(object) {
          if (object) {
            var Ctor = object.constructor,
                length = object.length;
          }
          if ((typeof Ctor == 'function' && Ctor.prototype === object) || (typeof object != 'function' && (length && isLength(length)))) {
            return shimKeys(object);
          }
          return isObject(object) ? nativeKeys(object) : [];
        };
        function keysIn(object) {
          if (object == null) {
            return [];
          }
          if (!isObject(object)) {
            object = Object(object);
          }
          var length = object.length;
          length = (length && isLength(length) && (isArray(object) || (support.nonEnumArgs && isArguments(object))) && length) || 0;
          var Ctor = object.constructor,
              index = -1,
              isProto = typeof Ctor == 'function' && Ctor.prototype === object,
              result = Array(length),
              skipIndexes = length > 0;
          while (++index < length) {
            result[index] = (index + '');
          }
          for (var key in object) {
            if (!(skipIndexes && isIndex(key, length)) && !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
              result.push(key);
            }
          }
          return result;
        }
        function mapValues(object, iteratee, thisArg) {
          var result = {};
          iteratee = getCallback(iteratee, thisArg, 3);
          baseForOwn(object, function(value, key, object) {
            result[key] = iteratee(value, key, object);
          });
          return result;
        }
        var merge = createAssigner(baseMerge);
        function omit(object, predicate, thisArg) {
          if (object == null) {
            return {};
          }
          if (typeof predicate != 'function') {
            var props = arrayMap(baseFlatten(arguments, false, false, 1), String);
            return pickByArray(object, baseDifference(keysIn(object), props));
          }
          predicate = bindCallback(predicate, thisArg, 3);
          return pickByCallback(object, function(value, key, object) {
            return !predicate(value, key, object);
          });
        }
        function pairs(object) {
          var index = -1,
              props = keys(object),
              length = props.length,
              result = Array(length);
          while (++index < length) {
            var key = props[index];
            result[index] = [key, object[key]];
          }
          return result;
        }
        function pick(object, predicate, thisArg) {
          if (object == null) {
            return {};
          }
          return typeof predicate == 'function' ? pickByCallback(object, bindCallback(predicate, thisArg, 3)) : pickByArray(object, baseFlatten(arguments, false, false, 1));
        }
        function result(object, key, defaultValue) {
          var value = object == null ? undefined : object[key];
          if (typeof value == 'undefined') {
            value = defaultValue;
          }
          return isFunction(value) ? value.call(object) : value;
        }
        function transform(object, iteratee, accumulator, thisArg) {
          var isArr = isArray(object) || isTypedArray(object);
          iteratee = getCallback(iteratee, thisArg, 4);
          if (accumulator == null) {
            if (isArr || isObject(object)) {
              var Ctor = object.constructor;
              if (isArr) {
                accumulator = isArray(object) ? new Ctor : [];
              } else {
                accumulator = baseCreate(isFunction(Ctor) && Ctor.prototype);
              }
            } else {
              accumulator = {};
            }
          }
          (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
            return iteratee(accumulator, value, index, object);
          });
          return accumulator;
        }
        function values(object) {
          return baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return baseValues(object, keysIn(object));
        }
        function inRange(value, start, end) {
          start = +start || 0;
          if (typeof end === 'undefined') {
            end = start;
            start = 0;
          } else {
            end = +end || 0;
          }
          return value >= start && value < end;
        }
        function random(min, max, floating) {
          if (floating && isIterateeCall(min, max, floating)) {
            max = floating = null;
          }
          var noMin = min == null,
              noMax = max == null;
          if (floating == null) {
            if (noMax && typeof min == 'boolean') {
              floating = min;
              min = 1;
            } else if (typeof max == 'boolean') {
              floating = max;
              noMax = true;
            }
          }
          if (noMin && noMax) {
            max = 1;
            noMax = false;
          }
          min = +min || 0;
          if (noMax) {
            max = min;
            min = 0;
          } else {
            max = +max || 0;
          }
          if (floating || min % 1 || max % 1) {
            var rand = nativeRandom();
            return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
          }
          return baseRandom(min, max);
        }
        var camelCase = createCompounder(function(result, word, index) {
          word = word.toLowerCase();
          return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
        });
        function capitalize(string) {
          string = baseToString(string);
          return string && (string.charAt(0).toUpperCase() + string.slice(1));
        }
        function deburr(string) {
          string = baseToString(string);
          return string && string.replace(reLatin1, deburrLetter);
        }
        function endsWith(string, target, position) {
          string = baseToString(string);
          target = (target + '');
          var length = string.length;
          position = (typeof position == 'undefined' ? length : nativeMin(position < 0 ? 0 : (+position || 0), length)) - target.length;
          return position >= 0 && string.indexOf(target, position) == position;
        }
        function escape(string) {
          string = baseToString(string);
          return (string && reHasUnescapedHtml.test(string)) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = baseToString(string);
          return (string && reHasRegExpChars.test(string)) ? string.replace(reRegExpChars, '\\$&') : string;
        }
        var kebabCase = createCompounder(function(result, word, index) {
          return result + (index ? '-' : '') + word.toLowerCase();
        });
        function pad(string, length, chars) {
          string = baseToString(string);
          length = +length;
          var strLength = string.length;
          if (strLength >= length || !nativeIsFinite(length)) {
            return string;
          }
          var mid = (length - strLength) / 2,
              leftLength = floor(mid),
              rightLength = ceil(mid);
          chars = createPad('', rightLength, chars);
          return chars.slice(0, leftLength) + string + chars;
        }
        function padLeft(string, length, chars) {
          string = baseToString(string);
          return string && (createPad(string, length, chars) + string);
        }
        function padRight(string, length, chars) {
          string = baseToString(string);
          return string && (string + createPad(string, length, chars));
        }
        function parseInt(string, radix, guard) {
          if (guard && isIterateeCall(string, radix, guard)) {
            radix = 0;
          }
          return nativeParseInt(string, radix);
        }
        if (nativeParseInt(whitespace + '08') != 8) {
          parseInt = function(string, radix, guard) {
            if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
              radix = 0;
            } else if (radix) {
              radix = +radix;
            }
            string = trim(string);
            return nativeParseInt(string, radix || (reHexPrefix.test(string) ? 16 : 10));
          };
        }
        function repeat(string, n) {
          var result = '';
          string = baseToString(string);
          n = +n;
          if (n < 1 || !string || !nativeIsFinite(n)) {
            return result;
          }
          do {
            if (n % 2) {
              result += string;
            }
            n = floor(n / 2);
            string += string;
          } while (n);
          return result;
        }
        var snakeCase = createCompounder(function(result, word, index) {
          return result + (index ? '_' : '') + word.toLowerCase();
        });
        var startCase = createCompounder(function(result, word, index) {
          return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
        });
        function startsWith(string, target, position) {
          string = baseToString(string);
          position = position == null ? 0 : nativeMin(position < 0 ? 0 : (+position || 0), string.length);
          return string.lastIndexOf(target, position) == position;
        }
        function template(string, options, otherOptions) {
          var settings = lodash.templateSettings;
          if (otherOptions && isIterateeCall(string, options, otherOptions)) {
            options = otherOptions = null;
          }
          string = baseToString(string);
          options = baseAssign(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);
          var imports = baseAssign(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
              importsKeys = keys(imports),
              importsValues = baseValues(imports, importsKeys);
          var isEscaping,
              isEvaluating,
              index = 0,
              interpolate = options.interpolate || reNoMatch,
              source = "__p += '";
          var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g');
          var sourceURL = '//# sourceURL=' + ('sourceURL' in options ? options.sourceURL : ('lodash.templateSources[' + (++templateCounter) + ']')) + '\n';
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = options.variable;
          if (!variable) {
            source = 'with (obj) {\n' + source + '\n}\n';
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;');
          source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
          var result = attempt(function() {
            return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
          });
          result.source = source;
          if (isError(result)) {
            throw result;
          }
          return result;
        }
        function trim(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
          }
          chars = (chars + '');
          return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
        }
        function trimLeft(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(trimmedLeftIndex(string));
          }
          return string.slice(charsLeftIndex(string, (chars + '')));
        }
        function trimRight(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(0, trimmedRightIndex(string) + 1);
          }
          return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
        }
        function trunc(string, options, guard) {
          if (guard && isIterateeCall(string, options, guard)) {
            options = null;
          }
          var length = DEFAULT_TRUNC_LENGTH,
              omission = DEFAULT_TRUNC_OMISSION;
          if (options != null) {
            if (isObject(options)) {
              var separator = 'separator' in options ? options.separator : separator;
              length = 'length' in options ? +options.length || 0 : length;
              omission = 'omission' in options ? baseToString(options.omission) : omission;
            } else {
              length = +options || 0;
            }
          }
          string = baseToString(string);
          if (length >= string.length) {
            return string;
          }
          var end = length - omission.length;
          if (end < 1) {
            return omission;
          }
          var result = string.slice(0, end);
          if (separator == null) {
            return result + omission;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match,
                  newEnd,
                  substring = string.slice(0, end);
              if (!separator.global) {
                separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
              }
              separator.lastIndex = 0;
              while ((match = separator.exec(substring))) {
                newEnd = match.index;
              }
              result = result.slice(0, newEnd == null ? end : newEnd);
            }
          } else if (string.indexOf(separator, end) != end) {
            var index = result.lastIndexOf(separator);
            if (index > -1) {
              result = result.slice(0, index);
            }
          }
          return result + omission;
        }
        function unescape(string) {
          string = baseToString(string);
          return (string && reHasEscapedHtml.test(string)) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        function words(string, pattern, guard) {
          if (guard && isIterateeCall(string, pattern, guard)) {
            pattern = null;
          }
          string = baseToString(string);
          return string.match(pattern || reWords) || [];
        }
        function attempt() {
          var length = arguments.length,
              func = arguments[0];
          try {
            var args = Array(length ? length - 1 : 0);
            while (--length > 0) {
              args[length - 1] = arguments[length];
            }
            return func.apply(undefined, args);
          } catch (e) {
            return isError(e) ? e : new Error(e);
          }
        }
        function callback(func, thisArg, guard) {
          if (guard && isIterateeCall(func, thisArg, guard)) {
            thisArg = null;
          }
          return isObjectLike(func) ? matches(func) : baseCallback(func, thisArg);
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function identity(value) {
          return value;
        }
        function matches(source) {
          return baseMatches(baseClone(source, true));
        }
        function matchesProperty(key, value) {
          return baseMatchesProperty(key + '', baseClone(value, true));
        }
        function mixin(object, source, options) {
          if (options == null) {
            var isObj = isObject(source),
                props = isObj && keys(source),
                methodNames = props && props.length && baseFunctions(source, props);
            if (!(methodNames ? methodNames.length : isObj)) {
              methodNames = false;
              options = source;
              source = object;
              object = this;
            }
          }
          if (!methodNames) {
            methodNames = baseFunctions(source, keys(source));
          }
          var chain = true,
              index = -1,
              isFunc = isFunction(object),
              length = methodNames.length;
          if (options === false) {
            chain = false;
          } else if (isObject(options) && 'chain' in options) {
            chain = options.chain;
          }
          while (++index < length) {
            var methodName = methodNames[index],
                func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = (function(func) {
                return function() {
                  var chainAll = this.__chain__;
                  if (chain || chainAll) {
                    var result = object(this.__wrapped__);
                    (result.__actions__ = arrayCopy(this.__actions__)).push({
                      'func': func,
                      'args': arguments,
                      'thisArg': object
                    });
                    result.__chain__ = chainAll;
                    return result;
                  }
                  var args = [this.value()];
                  push.apply(args, arguments);
                  return func.apply(object, args);
                };
              }(func));
            }
          }
          return object;
        }
        function noConflict() {
          context._ = oldDash;
          return this;
        }
        function noop() {}
        function property(key) {
          return baseProperty(key + '');
        }
        function propertyOf(object) {
          return function(key) {
            return object == null ? undefined : object[key];
          };
        }
        function range(start, end, step) {
          if (step && isIterateeCall(start, end, step)) {
            end = step = null;
          }
          start = +start || 0;
          step = step == null ? 1 : (+step || 0);
          if (end == null) {
            end = start;
            start = 0;
          } else {
            end = +end || 0;
          }
          var index = -1,
              length = nativeMax(ceil((end - start) / (step || 1)), 0),
              result = Array(length);
          while (++index < length) {
            result[index] = start;
            start += step;
          }
          return result;
        }
        function times(n, iteratee, thisArg) {
          n = +n;
          if (n < 1 || !nativeIsFinite(n)) {
            return [];
          }
          var index = -1,
              result = Array(nativeMin(n, MAX_ARRAY_LENGTH));
          iteratee = bindCallback(iteratee, thisArg, 1);
          while (++index < n) {
            if (index < MAX_ARRAY_LENGTH) {
              result[index] = iteratee(index);
            } else {
              iteratee(index);
            }
          }
          return result;
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return baseToString(prefix) + id;
        }
        lodash.prototype = baseLodash.prototype;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        MapCache.prototype['delete'] = mapDelete;
        MapCache.prototype.get = mapGet;
        MapCache.prototype.has = mapHas;
        MapCache.prototype.set = mapSet;
        SetCache.prototype.push = cachePush;
        memoize.Cache = MapCache;
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.callback = callback;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.functions = functions;
        lodash.groupBy = groupBy;
        lodash.indexBy = indexBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.invert = invert;
        lodash.invoke = invoke;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.omit = omit;
        lodash.once = once;
        lodash.pairs = pairs;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pluck = pluck;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortByAll = sortByAll;
        lodash.spread = spread;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.times = times;
        lodash.toArray = toArray;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.union = union;
        lodash.uniq = uniq;
        lodash.unzip = unzip;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.where = where;
        lodash.without = without;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.backflow = flowRight;
        lodash.collect = map;
        lodash.compose = flowRight;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.extend = assign;
        lodash.iteratee = callback;
        lodash.methods = functions;
        lodash.object = zipObject;
        lodash.select = filter;
        lodash.tail = rest;
        lodash.unique = uniq;
        mixin(lodash, lodash);
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.deburr = deburr;
        lodash.endsWith = endsWith;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.findWhere = findWhere;
        lodash.first = first;
        lodash.has = has;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isBoolean = isBoolean;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isError = isError;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isMatch = isMatch;
        lodash.isNaN = isNaN;
        lodash.isNative = isNative;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isString = isString;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.max = max;
        lodash.min = min;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padLeft = padLeft;
        lodash.padRight = padRight;
        lodash.parseInt = parseInt;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.result = result;
        lodash.runInContext = runInContext;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.template = template;
        lodash.trim = trim;
        lodash.trimLeft = trimLeft;
        lodash.trimRight = trimRight;
        lodash.trunc = trunc;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.words = words;
        lodash.all = every;
        lodash.any = some;
        lodash.contains = includes;
        lodash.detect = find;
        lodash.foldl = reduce;
        lodash.foldr = reduceRight;
        lodash.head = first;
        lodash.include = includes;
        lodash.inject = reduce;
        mixin(lodash, (function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!lodash.prototype[methodName]) {
              source[methodName] = func;
            }
          });
          return source;
        }()), false);
        lodash.sample = sample;
        lodash.prototype.sample = function(n) {
          if (!this.__chain__ && n == null) {
            return sample(this.value());
          }
          return this.thru(function(value) {
            return sample(value, n);
          });
        };
        lodash.VERSION = VERSION;
        arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
          var isFilter = index == LAZY_FILTER_FLAG || index == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
            var result = this.clone(),
                iteratees = result.__iteratees__ || (result.__iteratees__ = []);
            result.__filtered__ = result.__filtered__ || isFilter;
            iteratees.push({
              'iteratee': getCallback(iteratee, thisArg, 3),
              'type': index
            });
            return result;
          };
        });
        arrayEach(['drop', 'take'], function(methodName, index) {
          var countName = '__' + methodName + 'Count__',
              whileName = methodName + 'While';
          LazyWrapper.prototype[methodName] = function(n) {
            n = n == null ? 1 : nativeMax(floor(n) || 0, 0);
            var result = this.clone();
            if (result.__filtered__) {
              var value = result[countName];
              result[countName] = index ? nativeMin(value, n) : (value + n);
            } else {
              var views = result.__views__ || (result.__views__ = []);
              views.push({
                'size': n,
                'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
              });
            }
            return result;
          };
          LazyWrapper.prototype[methodName + 'Right'] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
          LazyWrapper.prototype[methodName + 'RightWhile'] = function(predicate, thisArg) {
            return this.reverse()[whileName](predicate, thisArg).reverse();
          };
        });
        arrayEach(['first', 'last'], function(methodName, index) {
          var takeName = 'take' + (index ? 'Right' : '');
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(['initial', 'rest'], function(methodName, index) {
          var dropName = 'drop' + (index ? '' : 'Right');
          LazyWrapper.prototype[methodName] = function() {
            return this[dropName](1);
          };
        });
        arrayEach(['pluck', 'where'], function(methodName, index) {
          var operationName = index ? 'filter' : 'map',
              createCallback = index ? baseMatches : baseProperty;
          LazyWrapper.prototype[methodName] = function(value) {
            return this[operationName](createCallback(value));
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.dropWhile = function(predicate, thisArg) {
          var done,
              lastIndex,
              isRight = this.__dir__ < 0;
          predicate = getCallback(predicate, thisArg, 3);
          return this.filter(function(value, index, array) {
            done = done && (isRight ? index < lastIndex : index > lastIndex);
            lastIndex = index;
            return done || (done = !predicate(value, index, array));
          });
        };
        LazyWrapper.prototype.reject = function(predicate, thisArg) {
          predicate = getCallback(predicate, thisArg, 3);
          return this.filter(function(value, index, array) {
            return !predicate(value, index, array);
          });
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = start == null ? 0 : (+start || 0);
          var result = start < 0 ? this.takeRight(-start) : this.drop(start);
          if (typeof end != 'undefined') {
            end = (+end || 0);
            result = end < 0 ? result.dropRight(-end) : result.take(end - start);
          }
          return result;
        };
        LazyWrapper.prototype.toArray = function() {
          return this.drop(0);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName],
              retUnwrapped = /^(?:first|last)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__,
                args = arguments,
                chainAll = this.__chain__,
                isHybrid = !!this.__actions__.length,
                isLazy = value instanceof LazyWrapper,
                onlyLazy = isLazy && !isHybrid;
            if (retUnwrapped && !chainAll) {
              return onlyLazy ? func.call(value) : lodashFunc.call(lodash, this.value());
            }
            var interceptor = function(value) {
              var otherArgs = [value];
              push.apply(otherArgs, args);
              return lodashFunc.apply(lodash, otherArgs);
            };
            if (isLazy || isArray(value)) {
              var wrapper = onlyLazy ? value : new LazyWrapper(this),
                  result = func.apply(wrapper, args);
              if (!retUnwrapped && (isHybrid || result.__actions__)) {
                var actions = result.__actions__ || (result.__actions__ = []);
                actions.push({
                  'func': thru,
                  'args': [interceptor],
                  'thisArg': lodash
                });
              }
              return new LodashWrapper(result, chainAll);
            }
            return this.thru(interceptor);
          };
        });
        arrayEach(['concat', 'join', 'pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
          var func = arrayProto[methodName],
              chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
              retUnwrapped = /^(?:join|pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              return func.apply(this.value(), args);
            }
            return this[chainName](function(value) {
              return func.apply(value, args);
            });
          };
        });
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toString = wrapperToString;
        lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.collect = lodash.prototype.map;
        lodash.prototype.head = lodash.prototype.first;
        lodash.prototype.select = lodash.prototype.filter;
        lodash.prototype.tail = lodash.prototype.rest;
        return lodash;
      }
      var _ = runInContext();
      if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeExports && freeModule) {
        if (moduleExports) {
          (freeModule.exports = _)._ = _;
        } else {
          freeExports._ = _;
        }
      } else {
        root._ = _;
      }
    }.call(this));
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("javascripts/models/graph-primitive", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function() {
    var GraphPrimitive;
    GraphPrimitive = (function() {
      GraphPrimitive.counters = {};
      GraphPrimitive.reset_counters = function() {
        return this.counters = {};
      };
      GraphPrimitive.nextID = function(type) {
        var base;
        (base = this.counters)[type] || (base[type] = 0);
        this.counters[type]++;
        return type + "-" + this.counters[type];
      };
      GraphPrimitive.prototype.type = function() {
        return "GraphPrimitive";
      };
      function GraphPrimitive() {
        this.id = GraphPrimitive.nextID(this.type());
        this.key = this.id;
      }
      return GraphPrimitive;
    })();
    module.exports = GraphPrimitive;
  }).call(this);
  global.define = __define;
  return module.exports;
});



System.register("javascripts/models/Node", ["npm:lodash@3.3.1", "npm:loglevel@1.2.0", "javascripts/models/graph-primitive"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function() {
    var GraphPrimitive,
        Node,
        _,
        log,
        extend = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        },
        hasProp = {}.hasOwnProperty;
    _ = require("npm:lodash@3.3.1");
    log = require("npm:loglevel@1.2.0");
    GraphPrimitive = require("javascripts/models/graph-primitive");
    Node = (function(superClass) {
      extend(Node, superClass);
      function Node(nodeSpec, key) {
        if (nodeSpec == null) {
          nodeSpec = {
            x: 0,
            y: 0,
            title: "untitled",
            image: null
          };
        }
        Node.__super__.constructor.call(this);
        if (key) {
          this.key = key;
        }
        this.links = [];
        this.x = nodeSpec.x;
        this.y = nodeSpec.y;
        this.title = nodeSpec.title;
        this.image = nodeSpec.image;
      }
      Node.prototype.type = function() {
        return "Node";
      };
      Node.prototype.addLink = function(link) {
        if (link.sourceNode === this || link.targetNode === this) {
          if (_.contains(this.links, link)) {
            throw new Error("Duplicate link for Node:" + this.id);
          }
          return this.links.push(link);
        } else {
          throw new Error("Bad link for Node:" + this.id);
        }
      };
      Node.prototype.outLinks = function() {
        return _.filter(this.links, (function(_this) {
          return function(link) {
            if (link.sourceNode === _this) {
              return true;
            }
            return false;
          };
        })(this));
      };
      Node.prototype.inLinks = function() {
        return _.filter(this.links, (function(_this) {
          return function(link) {
            if (link.targetNode === _this) {
              return true;
            }
            return false;
          };
        })(this));
      };
      Node.prototype.infoString = function() {
        var link,
            linkNamer,
            outs;
        linkNamer = (function(_this) {
          return function(link) {
            return " --" + link.title + "-->[" + link.targetNode.title + "]";
          };
        })(this);
        outs = (function() {
          var i,
              len,
              ref,
              results;
          ref = this.outLinks();
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            link = ref[i];
            results.push(linkNamer(link));
          }
          return results;
        }).call(this);
        return this.title + " " + outs;
      };
      Node.prototype.downstreamNodes = function() {
        var visit,
            visitedNodes;
        visitedNodes = [];
        visit = function(node) {
          log.info("visiting node: " + node.id);
          visitedNodes.push(node);
          return _.each(node.outLinks(), function(link) {
            var downstreamNode;
            downstreamNode = link.targetNode;
            if (!_.contains(visitedNodes, downstreamNode)) {
              return visit(downstreamNode);
            }
          });
        };
        visit(this);
        return _.without(visitedNodes, this);
      };
      Node.prototype.toExport = function() {
        return {
          title: this.title,
          x: this.x,
          y: this.y,
          image: this.image,
          key: this.key
        };
      };
      return Node;
    })(GraphPrimitive);
    module.exports = Node;
  }).call(this);
  global.define = __define;
  return module.exports;
});



System.register("javascripts/js_plumb_diagram_toolkit", ["javascripts/vendor/touchpunch"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var $ = require("javascripts/vendor/touchpunch");
  function DiagramToolkit(domContext, options) {
    this.options = options || {};
    this.domContex = domContext;
    this.type = 'jsPlumbWrappingDiagramToolkit';
    this.color = this.options.color || "#233";
    this.lineWidth = this.options.lineWidth || 6;
    this.kit = jsPlumb.getInstance({Container: domContext});
    this.registerListeners = function() {
      this.kit.bind("connection", this.handleConnect.bind(this));
    };
    this.handleConnect = function(info, evnt) {
      if (this.options.handleConnect) {
        this.options.handleConnect(info, evnt);
      }
      return true;
    };
    this.handleClick = function(connection, evnt) {
      if (this.options.handleClick) {
        this.options.handleClick(connection, evnt);
      }
    }, this.handleLabelClick = function(label, evnt) {}, this.handleDisconnect = function(info, evnt) {
      if (this.options.handleDisconnect) {
        return this.options.handleDisconnect(info, evnt);
      }
      return true;
    };
    this.repaint = function() {
      this.kit.repaintEverything();
    };
    this._endpointOptions = ["Dot", {radius: 15}];
    this.makeTarget = function(div) {
      var opts = {
        isTarget: true,
        isSource: true,
        endpoint: this._endpointOptions,
        connector: ["Bezier"],
        anchor: "Top",
        paintStyle: this._paintStyle(),
        maxConnections: -1
      };
      this.kit.addEndpoint(div, opts);
      opts.anchor = "Bottom";
      this.kit.addEndpoint(div, opts);
    };
    this.clear = function() {
      if (this.kit) {
        this.kit.deleteEveryEndpoint();
        this.kit.reset();
        this.registerListeners();
      } else {
        console.log("No kit defined");
      }
    };
    this.kit.importDefaults({
      Connector: ["Bezier", {curviness: 50}],
      Anchors: ["TopCenter", "BottomCenter"],
      Endpoint: this._endpointOptions,
      DragOptions: {
        cursor: 'pointer',
        zIndex: 2000
      },
      DoNotThrowErrors: false
    });
    this._paintStyle = function(color) {
      var _color = color || this.color;
      var _line_width = this.lineWidth;
      return ({
        strokeStyle: _color,
        lineWidth: _line_width
      });
    };
    this._overlays = function(label, selected) {
      var _label = label || "";
      var hasLabel = label.length > 0;
      var cssClass = "label";
      if (selected) {
        cssClass = cssClass + " selected";
      }
      var results = [["Arrow", {
        location: 1.0,
        events: {click: this.handleLabelClick}
      }]];
      if (hasLabel) {
        results.push(["Label", {
          location: 0.4,
          events: {click: this.handleLabelClick},
          label: _label,
          cssClass: cssClass
        }]);
      }
      return results;
    };
    this._clean_borked_endpoints = function() {};
    this.addLink = function(source, target, label, color, source_terminal, target_terminal, linkModel) {
      var paintStyle = this._paintStyle(color);
      var selected = linkModel.selected;
      if (selected) {
        paintStyle.lineWidth = paintStyle.lineWidth * 1.2;
      }
      var connection = this.kit.connect({
        source: source,
        target: target,
        anchors: [source_terminal || "Top", target_terminal || "Bottom"],
        paintStyle: paintStyle,
        overlays: this._overlays(label, selected)
      });
      connection.bind("click", this.handleClick.bind(this));
      connection.linkModel = linkModel;
    };
    this.setSuspendDrawing = function(shouldwestop) {
      if (!shouldwestop) {
        this._clean_borked_endpoints();
      }
      this.kit.setSuspendDrawing(shouldwestop, !shouldwestop);
    };
    this.supspendDrawing = function() {
      this.setSuspendDrawing(true);
    };
    this.resumeDrawing = function() {
      this.setSuspendDrawing(false);
    };
    this.registerListeners();
  }
  module.exports = DiagramToolkit;
  global.define = __define;
  return module.exports;
});



System.register("javascripts/proto-node-view", ["npm:react@0.12.2", "npm:loglevel@1.2.0", "npm:lodash@3.3.1", "javascripts/vendor/touchpunch"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var React = require("npm:react@0.12.2");
  log = require("npm:loglevel@1.2.0");
  _ = require("npm:lodash@3.3.1");
  $ = require("javascripts/vendor/touchpunch");
  var ProtoNodeView = React.createClass({
    displayName: "ProtoNodeView",
    componentDidMount: function() {
      var $elem = $(this.getDOMNode());
      var movedHandler = this.doMove;
      $elem.draggable({
        drag: movedHandler,
        revert: true,
        helper: "clone",
        revertDuration: 0,
        opacity: 0.35
      });
    },
    doMove: function(evt, extra) {},
    render: function() {
      var key = this.props.key;
      var title = this.props.title;
      var image = this.props.image;
      var deleteHandler = this.doDelete;
      var imageTag = "";
      if (image.length > 0) {
        imageTag = (React.createElement("img", {src: image}));
      }
      ;
      return (React.createElement("div", {
        className: "proto-node",
        "data-node-key": key,
        "data-image": image,
        "data-title": title
      }, React.createElement("div", {className: "img-background"}, imageTag)));
    }
  });
  module.exports = ProtoNodeView;
  global.define = __define;
  return module.exports;
});



System.register("javascripts/node-edit-view", ["npm:react@0.12.2"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var React = require("npm:react@0.12.2");
  var NodeEditView = React.createClass({
    displayName: "NodeEditView",
    notifyChange: function(title, image) {
      var changeListener = this.props.onNodeChanged;
      var node = this.props.node;
      if (changeListener) {
        changeListener(node, title, image);
      }
    },
    changeTitle: function(evnt) {
      var node = this.props.node;
      var image = node.image;
      var title = evnt.target.value;
      this.notifyChange(title, image);
    },
    changeImage: function(evnt) {
      var node = this.props.node;
      var image = evnt.target.value;
      var title = node.title;
      this.notifyChange(title, image);
    },
    render: function() {
      var node = this.props.node;
      if (node) {
        var title = node.title;
        var image = node.image;
        var changeTitle = this.changeTitle;
        var changeImage = this.changeImage;
        return (React.createElement("div", {className: "node-edit-view"}, React.createElement("h2", null, title), React.createElement("div", {className: "edit-row"}, React.createElement("label", {name: "title"}, "Title"), React.createElement("input", {
          type: "text",
          name: "title",
          value: title,
          onChange: changeTitle
        })), React.createElement("div", {className: "edit-row"}, React.createElement("label", {name: "image"}, "Image"), React.createElement("input", {
          type: "text",
          name: "image",
          value: image,
          onChange: changeImage
        }))));
      } else {
        return (React.createElement("div", {className: "node-edit-view hidden"}));
      }
    }
  });
  module.exports = NodeEditView;
  global.define = __define;
  return module.exports;
});



System.register("javascripts/link-edit-view", ["npm:react@0.12.2"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var React = require("npm:react@0.12.2");
  var palettes = [['#4D6A6D', '#798478', "#A0A083", "#C9ADA1", "#EAE0CC"], ['#351431', '#775253', "#BDC696", "#D1D3C4", "#DFE0DC"], ['#D6F49D', '#EAD637', "#CBA328", "#230C0F", "#A2D3C2"]];
  var LinkEditView = React.createClass({
    displayName: "LinkEditView",
    notifyChange: function(title, color, deleted) {
      deleted = !!deleted;
      var changeListener = this.props.onLinkChanged;
      var link = this.props.link;
      if (changeListener) {
        changeListener(link, title, color, deleted);
      }
    },
    changeTitle: function(evnt) {
      var link = this.props.link;
      var color = link.color;
      var title = evnt.target.value;
      this.notifyChange(title, color);
    },
    changeColor: function(color) {
      var link = this.props.link;
      var title = link.title;
      this.notifyChange(title, color);
    },
    render: function() {
      var link = this.props.link;
      if (link) {
        var title = link.title;
        var color = link.color;
        var changeTitle = this.changeTitle;
        var changeColor = this.changeColor;
        var paletteNo = 2;
        var deleteLink = function(evnt) {
          this.notifyChange(title, color, true);
        }.bind(this);
        var pickColor = function(evnt) {
          var color = $(evnt.target).css('background-color');
          this.changeColor(color);
        }.bind(this);
        var palette = palettes[paletteNo].map(function(colorCode) {
          var style = {"background-color": colorCode};
          return (React.createElement("div", {
            className: "colorChoice",
            style: style,
            onTouchEnd: pickColor,
            onClick: pickColor
          }));
        });
        var deleteButton = (React.createElement("button", {
          type: "button",
          className: "delete",
          onClick: deleteLink
        }, " delete this link"));
        return (React.createElement("div", {className: "link-edit-view"}, React.createElement("h2", null, title), React.createElement("div", {className: "edit-row"}, deleteButton), React.createElement("div", {className: "edit-row"}, React.createElement("label", {name: "title"}, "Title"), React.createElement("input", {
          type: "text",
          name: "title",
          value: title,
          onChange: changeTitle
        })), React.createElement("div", {className: "edit-row"}, React.createElement("label", {name: "color"}, "Color"), palette)));
      } else {
        return (React.createElement("div", {className: "link-edit-view hidden"}));
      }
    }
  });
  module.exports = LinkEditView;
  global.define = __define;
  return module.exports;
});



System.register("javascripts/google-drive-io", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  function GoogleDriveIO() {
    var CLIENT_ID = '1095918012594-svs72eqfalasuc4t1p1ps1m8r9b8psso.apps.googleusercontent.com',
        SCOPES = 'https://www.googleapis.com/auth/drive';
    this.authorize = function() {
      gapi.auth.authorize({
        'client_id': CLIENT_ID,
        'scope': SCOPES,
        'immediate': false
      }, function(token) {
        if (token && token.error) {
          console.error("Google Drive Authorization failed:" + error);
        }
      });
    };
    this.upload = function(fileSpec, contents) {
      function handleAuthResult(authResult) {
        if (authResult && !authResult.error) {
          gapi.client.load('drive', 'v2', function() {
            sendFile(fileSpec);
          });
        } else {
          console.log('No authorization. Upload failed for file: ' + fileSpec.fileName);
        }
      }
      function makeMultipartBody(parts, boundary) {
        var delimiter = "\r\n--" + boundary + "\r\n",
            close_delim = "\r\n--" + boundary + "--",
            results = "";
        parts.forEach(function(part) {
          results += delimiter + 'Content-Type: ' + part.fileType;
          if (part.encoding) {
            results += 'Content-Transfer-Encoding: ' + part.encoding;
          }
          results += "\r\n\r\n";
          results += part.message;
        });
        results += close_delim;
        return results;
      }
      function sendFile(fileSpec, callback) {
        var boundary = '-------314159265358979323846',
            contentType = fileSpec.mimeType || 'application/octet-stream',
            metadata = {
              'title': fileSpec.fileName,
              'mimeType': contentType
            },
            base64Data = btoa(contents),
            multipartRequestBody = makeMultipartBody([{
              fileType: contentType,
              message: JSON.stringify(metadata)
            }, {
              fileType: 'application/json',
              message: contents
            }], boundary),
            request = gapi.client.request({
              'path': '/upload/drive/v2/files',
              'method': 'POST',
              'params': {'uploadType': 'multipart'},
              'headers': {'Content-Type': 'multipart/mixed; boundary="' + boundary + '"'},
              'body': multipartRequestBody
            });
        if (!callback) {
          callback = function(file) {
            console.log(file);
          };
        }
        request.execute(callback);
      }
      gapi.auth.authorize({
        'client_id': CLIENT_ID,
        'scope': SCOPES,
        'immediate': true
      }, handleAuthResult);
    };
  }
  module.exports = GoogleDriveIO;
  global.define = __define;
  return module.exports;
});



System.register("npm:process@0.10.0", ["npm:process@0.10.0/browser"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:process@0.10.0/browser");
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/warning", ["npm:react@0.12.2/lib/emptyFunction", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var emptyFunction = require("npm:react@0.12.2/lib/emptyFunction");
    var warning = emptyFunction;
    if ("production" !== process.env.NODE_ENV) {
      warning = function(condition, format) {
        for (var args = [],
            $__0 = 2,
            $__1 = arguments.length; $__0 < $__1; $__0++)
          args.push(arguments[$__0]);
        if (format === undefined) {
          throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
        }
        if (!condition) {
          var argIndex = 0;
          console.warn('Warning: ' + format.replace(/%s/g, function() {
            return args[argIndex++];
          }));
        }
      };
    }
    module.exports = warning;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/EventConstants", ["npm:react@0.12.2/lib/keyMirror"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var keyMirror = require("npm:react@0.12.2/lib/keyMirror");
  var PropagationPhases = keyMirror({
    bubbled: null,
    captured: null
  });
  var topLevelTypes = keyMirror({
    topBlur: null,
    topChange: null,
    topClick: null,
    topCompositionEnd: null,
    topCompositionStart: null,
    topCompositionUpdate: null,
    topContextMenu: null,
    topCopy: null,
    topCut: null,
    topDoubleClick: null,
    topDrag: null,
    topDragEnd: null,
    topDragEnter: null,
    topDragExit: null,
    topDragLeave: null,
    topDragOver: null,
    topDragStart: null,
    topDrop: null,
    topError: null,
    topFocus: null,
    topInput: null,
    topKeyDown: null,
    topKeyPress: null,
    topKeyUp: null,
    topLoad: null,
    topMouseDown: null,
    topMouseMove: null,
    topMouseOut: null,
    topMouseOver: null,
    topMouseUp: null,
    topPaste: null,
    topReset: null,
    topScroll: null,
    topSelectionChange: null,
    topSubmit: null,
    topTextInput: null,
    topTouchCancel: null,
    topTouchEnd: null,
    topTouchMove: null,
    topTouchStart: null,
    topWheel: null
  });
  var EventConstants = {
    topLevelTypes: topLevelTypes,
    PropagationPhases: PropagationPhases
  };
  module.exports = EventConstants;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactContext", ["npm:react@0.12.2/lib/Object.assign"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var assign = require("npm:react@0.12.2/lib/Object.assign");
  var ReactContext = {
    current: {},
    withContext: function(newContext, scopedCallback) {
      var result;
      var previousContext = ReactContext.current;
      ReactContext.current = assign({}, previousContext, newContext);
      try {
        result = scopedCallback();
      } finally {
        ReactContext.current = previousContext;
      }
      return result;
    }
  };
  module.exports = ReactContext;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactInstanceHandles", ["npm:react@0.12.2/lib/ReactRootIndex", "npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactRootIndex = require("npm:react@0.12.2/lib/ReactRootIndex");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var SEPARATOR = '.';
    var SEPARATOR_LENGTH = SEPARATOR.length;
    var MAX_TREE_DEPTH = 100;
    function getReactRootIDString(index) {
      return SEPARATOR + index.toString(36);
    }
    function isBoundary(id, index) {
      return id.charAt(index) === SEPARATOR || index === id.length;
    }
    function isValidID(id) {
      return id === '' || (id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR);
    }
    function isAncestorIDOf(ancestorID, descendantID) {
      return (descendantID.indexOf(ancestorID) === 0 && isBoundary(descendantID, ancestorID.length));
    }
    function getParentID(id) {
      return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';
    }
    function getNextDescendantID(ancestorID, destinationID) {
      ("production" !== process.env.NODE_ENV ? invariant(isValidID(ancestorID) && isValidID(destinationID), 'getNextDescendantID(%s, %s): Received an invalid React DOM ID.', ancestorID, destinationID) : invariant(isValidID(ancestorID) && isValidID(destinationID)));
      ("production" !== process.env.NODE_ENV ? invariant(isAncestorIDOf(ancestorID, destinationID), 'getNextDescendantID(...): React has made an invalid assumption about ' + 'the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.', ancestorID, destinationID) : invariant(isAncestorIDOf(ancestorID, destinationID)));
      if (ancestorID === destinationID) {
        return ancestorID;
      }
      var start = ancestorID.length + SEPARATOR_LENGTH;
      for (var i = start; i < destinationID.length; i++) {
        if (isBoundary(destinationID, i)) {
          break;
        }
      }
      return destinationID.substr(0, i);
    }
    function getFirstCommonAncestorID(oneID, twoID) {
      var minLength = Math.min(oneID.length, twoID.length);
      if (minLength === 0) {
        return '';
      }
      var lastCommonMarkerIndex = 0;
      for (var i = 0; i <= minLength; i++) {
        if (isBoundary(oneID, i) && isBoundary(twoID, i)) {
          lastCommonMarkerIndex = i;
        } else if (oneID.charAt(i) !== twoID.charAt(i)) {
          break;
        }
      }
      var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);
      ("production" !== process.env.NODE_ENV ? invariant(isValidID(longestCommonID), 'getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s', oneID, twoID, longestCommonID) : invariant(isValidID(longestCommonID)));
      return longestCommonID;
    }
    function traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {
      start = start || '';
      stop = stop || '';
      ("production" !== process.env.NODE_ENV ? invariant(start !== stop, 'traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.', start) : invariant(start !== stop));
      var traverseUp = isAncestorIDOf(stop, start);
      ("production" !== process.env.NODE_ENV ? invariant(traverseUp || isAncestorIDOf(start, stop), 'traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do ' + 'not have a parent path.', start, stop) : invariant(traverseUp || isAncestorIDOf(start, stop)));
      var depth = 0;
      var traverse = traverseUp ? getParentID : getNextDescendantID;
      for (var id = start; ; id = traverse(id, stop)) {
        var ret;
        if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {
          ret = cb(id, traverseUp, arg);
        }
        if (ret === false || id === stop) {
          break;
        }
        ("production" !== process.env.NODE_ENV ? invariant(depth++ < MAX_TREE_DEPTH, 'traverseParentPath(%s, %s, ...): Detected an infinite loop while ' + 'traversing the React DOM ID tree. This may be due to malformed IDs: %s', start, stop) : invariant(depth++ < MAX_TREE_DEPTH));
      }
    }
    var ReactInstanceHandles = {
      createReactRootID: function() {
        return getReactRootIDString(ReactRootIndex.createReactRootIndex());
      },
      createReactID: function(rootID, name) {
        return rootID + name;
      },
      getReactRootIDFromNodeID: function(id) {
        if (id && id.charAt(0) === SEPARATOR && id.length > 1) {
          var index = id.indexOf(SEPARATOR, 1);
          return index > -1 ? id.substr(0, index) : id;
        }
        return null;
      },
      traverseEnterLeave: function(leaveID, enterID, cb, upArg, downArg) {
        var ancestorID = getFirstCommonAncestorID(leaveID, enterID);
        if (ancestorID !== leaveID) {
          traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);
        }
        if (ancestorID !== enterID) {
          traverseParentPath(ancestorID, enterID, cb, downArg, true, false);
        }
      },
      traverseTwoPhase: function(targetID, cb, arg) {
        if (targetID) {
          traverseParentPath('', targetID, cb, arg, true, false);
          traverseParentPath(targetID, '', cb, arg, false, true);
        }
      },
      traverseAncestors: function(targetID, cb, arg) {
        traverseParentPath('', targetID, cb, arg, true, false);
      },
      _getFirstCommonAncestorID: getFirstCommonAncestorID,
      _getNextDescendantID: getNextDescendantID,
      isAncestorIDOf: isAncestorIDOf,
      SEPARATOR: SEPARATOR
    };
    module.exports = ReactInstanceHandles;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactOwner", ["npm:react@0.12.2/lib/emptyObject", "npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var emptyObject = require("npm:react@0.12.2/lib/emptyObject");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var ReactOwner = {
      isValidOwner: function(object) {
        return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
      },
      addComponentAsRefTo: function(component, ref, owner) {
        ("production" !== process.env.NODE_ENV ? invariant(ReactOwner.isValidOwner(owner), 'addComponentAsRefTo(...): Only a ReactOwner can have refs. This ' + 'usually means that you\'re trying to add a ref to a component that ' + 'doesn\'t have an owner (that is, was not created inside of another ' + 'component\'s `render` method). Try rendering this component inside of ' + 'a new top-level component which will hold the ref.') : invariant(ReactOwner.isValidOwner(owner)));
        owner.attachRef(ref, component);
      },
      removeComponentAsRefFrom: function(component, ref, owner) {
        ("production" !== process.env.NODE_ENV ? invariant(ReactOwner.isValidOwner(owner), 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. This ' + 'usually means that you\'re trying to remove a ref to a component that ' + 'doesn\'t have an owner (that is, was not created inside of another ' + 'component\'s `render` method). Try rendering this component inside of ' + 'a new top-level component which will hold the ref.') : invariant(ReactOwner.isValidOwner(owner)));
        if (owner.refs[ref] === component) {
          owner.detachRef(ref);
        }
      },
      Mixin: {
        construct: function() {
          this.refs = emptyObject;
        },
        attachRef: function(ref, component) {
          ("production" !== process.env.NODE_ENV ? invariant(component.isOwnedBy(this), 'attachRef(%s, ...): Only a component\'s owner can store a ref to it.', ref) : invariant(component.isOwnedBy(this)));
          var refs = this.refs === emptyObject ? (this.refs = {}) : this.refs;
          refs[ref] = component;
        },
        detachRef: function(ref) {
          delete this.refs[ref];
        }
      }
    };
    module.exports = ReactOwner;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactUpdates", ["npm:react@0.12.2/lib/CallbackQueue", "npm:react@0.12.2/lib/PooledClass", "npm:react@0.12.2/lib/ReactCurrentOwner", "npm:react@0.12.2/lib/ReactPerf", "npm:react@0.12.2/lib/Transaction", "npm:react@0.12.2/lib/Object.assign", "npm:react@0.12.2/lib/invariant", "npm:react@0.12.2/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var CallbackQueue = require("npm:react@0.12.2/lib/CallbackQueue");
    var PooledClass = require("npm:react@0.12.2/lib/PooledClass");
    var ReactCurrentOwner = require("npm:react@0.12.2/lib/ReactCurrentOwner");
    var ReactPerf = require("npm:react@0.12.2/lib/ReactPerf");
    var Transaction = require("npm:react@0.12.2/lib/Transaction");
    var assign = require("npm:react@0.12.2/lib/Object.assign");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var warning = require("npm:react@0.12.2/lib/warning");
    var dirtyComponents = [];
    var asapCallbackQueue = CallbackQueue.getPooled();
    var asapEnqueued = false;
    var batchingStrategy = null;
    function ensureInjected() {
      ("production" !== process.env.NODE_ENV ? invariant(ReactUpdates.ReactReconcileTransaction && batchingStrategy, 'ReactUpdates: must inject a reconcile transaction class and batching ' + 'strategy') : invariant(ReactUpdates.ReactReconcileTransaction && batchingStrategy));
    }
    var NESTED_UPDATES = {
      initialize: function() {
        this.dirtyComponentsLength = dirtyComponents.length;
      },
      close: function() {
        if (this.dirtyComponentsLength !== dirtyComponents.length) {
          dirtyComponents.splice(0, this.dirtyComponentsLength);
          flushBatchedUpdates();
        } else {
          dirtyComponents.length = 0;
        }
      }
    };
    var UPDATE_QUEUEING = {
      initialize: function() {
        this.callbackQueue.reset();
      },
      close: function() {
        this.callbackQueue.notifyAll();
      }
    };
    var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];
    function ReactUpdatesFlushTransaction() {
      this.reinitializeTransaction();
      this.dirtyComponentsLength = null;
      this.callbackQueue = CallbackQueue.getPooled();
      this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled();
    }
    assign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {
      getTransactionWrappers: function() {
        return TRANSACTION_WRAPPERS;
      },
      destructor: function() {
        this.dirtyComponentsLength = null;
        CallbackQueue.release(this.callbackQueue);
        this.callbackQueue = null;
        ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
        this.reconcileTransaction = null;
      },
      perform: function(method, scope, a) {
        return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
      }
    });
    PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);
    function batchedUpdates(callback, a, b) {
      ensureInjected();
      batchingStrategy.batchedUpdates(callback, a, b);
    }
    function mountDepthComparator(c1, c2) {
      return c1._mountDepth - c2._mountDepth;
    }
    function runBatchedUpdates(transaction) {
      var len = transaction.dirtyComponentsLength;
      ("production" !== process.env.NODE_ENV ? invariant(len === dirtyComponents.length, 'Expected flush transaction\'s stored dirty-components length (%s) to ' + 'match dirty-components array length (%s).', len, dirtyComponents.length) : invariant(len === dirtyComponents.length));
      dirtyComponents.sort(mountDepthComparator);
      for (var i = 0; i < len; i++) {
        var component = dirtyComponents[i];
        if (component.isMounted()) {
          var callbacks = component._pendingCallbacks;
          component._pendingCallbacks = null;
          component.performUpdateIfNecessary(transaction.reconcileTransaction);
          if (callbacks) {
            for (var j = 0; j < callbacks.length; j++) {
              transaction.callbackQueue.enqueue(callbacks[j], component);
            }
          }
        }
      }
    }
    var flushBatchedUpdates = ReactPerf.measure('ReactUpdates', 'flushBatchedUpdates', function() {
      while (dirtyComponents.length || asapEnqueued) {
        if (dirtyComponents.length) {
          var transaction = ReactUpdatesFlushTransaction.getPooled();
          transaction.perform(runBatchedUpdates, null, transaction);
          ReactUpdatesFlushTransaction.release(transaction);
        }
        if (asapEnqueued) {
          asapEnqueued = false;
          var queue = asapCallbackQueue;
          asapCallbackQueue = CallbackQueue.getPooled();
          queue.notifyAll();
          CallbackQueue.release(queue);
        }
      }
    });
    function enqueueUpdate(component, callback) {
      ("production" !== process.env.NODE_ENV ? invariant(!callback || typeof callback === "function", 'enqueueUpdate(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(!callback || typeof callback === "function"));
      ensureInjected();
      ("production" !== process.env.NODE_ENV ? warning(ReactCurrentOwner.current == null, 'enqueueUpdate(): Render methods should be a pure function of props ' + 'and state; triggering nested component updates from render is not ' + 'allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate.') : null);
      if (!batchingStrategy.isBatchingUpdates) {
        batchingStrategy.batchedUpdates(enqueueUpdate, component, callback);
        return ;
      }
      dirtyComponents.push(component);
      if (callback) {
        if (component._pendingCallbacks) {
          component._pendingCallbacks.push(callback);
        } else {
          component._pendingCallbacks = [callback];
        }
      }
    }
    function asap(callback, context) {
      ("production" !== process.env.NODE_ENV ? invariant(batchingStrategy.isBatchingUpdates, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context where' + 'updates are not being batched.') : invariant(batchingStrategy.isBatchingUpdates));
      asapCallbackQueue.enqueue(callback, context);
      asapEnqueued = true;
    }
    var ReactUpdatesInjection = {
      injectReconcileTransaction: function(ReconcileTransaction) {
        ("production" !== process.env.NODE_ENV ? invariant(ReconcileTransaction, 'ReactUpdates: must provide a reconcile transaction class') : invariant(ReconcileTransaction));
        ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
      },
      injectBatchingStrategy: function(_batchingStrategy) {
        ("production" !== process.env.NODE_ENV ? invariant(_batchingStrategy, 'ReactUpdates: must provide a batching strategy') : invariant(_batchingStrategy));
        ("production" !== process.env.NODE_ENV ? invariant(typeof _batchingStrategy.batchedUpdates === 'function', 'ReactUpdates: must provide a batchedUpdates() function') : invariant(typeof _batchingStrategy.batchedUpdates === 'function'));
        ("production" !== process.env.NODE_ENV ? invariant(typeof _batchingStrategy.isBatchingUpdates === 'boolean', 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : invariant(typeof _batchingStrategy.isBatchingUpdates === 'boolean'));
        batchingStrategy = _batchingStrategy;
      }
    };
    var ReactUpdates = {
      ReactReconcileTransaction: null,
      batchedUpdates: batchedUpdates,
      enqueueUpdate: enqueueUpdate,
      flushBatchedUpdates: flushBatchedUpdates,
      injection: ReactUpdatesInjection,
      asap: asap
    };
    module.exports = ReactUpdates;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactElementValidator", ["npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/ReactPropTypeLocations", "npm:react@0.12.2/lib/ReactCurrentOwner", "npm:react@0.12.2/lib/monitorCodeUse", "npm:react@0.12.2/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
    var ReactPropTypeLocations = require("npm:react@0.12.2/lib/ReactPropTypeLocations");
    var ReactCurrentOwner = require("npm:react@0.12.2/lib/ReactCurrentOwner");
    var monitorCodeUse = require("npm:react@0.12.2/lib/monitorCodeUse");
    var warning = require("npm:react@0.12.2/lib/warning");
    var ownerHasKeyUseWarning = {
      'react_key_warning': {},
      'react_numeric_key_warning': {}
    };
    var ownerHasMonitoredObjectMap = {};
    var loggedTypeFailures = {};
    var NUMERIC_PROPERTY_REGEX = /^\d+$/;
    function getCurrentOwnerDisplayName() {
      var current = ReactCurrentOwner.current;
      return current && current.constructor.displayName || undefined;
    }
    function validateExplicitKey(component, parentType) {
      if (component._store.validated || component.key != null) {
        return ;
      }
      component._store.validated = true;
      warnAndMonitorForKeyUse('react_key_warning', 'Each child in an array should have a unique "key" prop.', component, parentType);
    }
    function validatePropertyKey(name, component, parentType) {
      if (!NUMERIC_PROPERTY_REGEX.test(name)) {
        return ;
      }
      warnAndMonitorForKeyUse('react_numeric_key_warning', 'Child objects should have non-numeric keys so ordering is preserved.', component, parentType);
    }
    function warnAndMonitorForKeyUse(warningID, message, component, parentType) {
      var ownerName = getCurrentOwnerDisplayName();
      var parentName = parentType.displayName;
      var useName = ownerName || parentName;
      var memoizer = ownerHasKeyUseWarning[warningID];
      if (memoizer.hasOwnProperty(useName)) {
        return ;
      }
      memoizer[useName] = true;
      message += ownerName ? (" Check the render method of " + ownerName + ".") : (" Check the renderComponent call using <" + parentName + ">.");
      var childOwnerName = null;
      if (component._owner && component._owner !== ReactCurrentOwner.current) {
        childOwnerName = component._owner.constructor.displayName;
        message += (" It was passed a child from " + childOwnerName + ".");
      }
      message += ' See http://fb.me/react-warning-keys for more information.';
      monitorCodeUse(warningID, {
        component: useName,
        componentOwner: childOwnerName
      });
      console.warn(message);
    }
    function monitorUseOfObjectMap() {
      var currentName = getCurrentOwnerDisplayName() || '';
      if (ownerHasMonitoredObjectMap.hasOwnProperty(currentName)) {
        return ;
      }
      ownerHasMonitoredObjectMap[currentName] = true;
      monitorCodeUse('react_object_map_children');
    }
    function validateChildKeys(component, parentType) {
      if (Array.isArray(component)) {
        for (var i = 0; i < component.length; i++) {
          var child = component[i];
          if (ReactElement.isValidElement(child)) {
            validateExplicitKey(child, parentType);
          }
        }
      } else if (ReactElement.isValidElement(component)) {
        component._store.validated = true;
      } else if (component && typeof component === 'object') {
        monitorUseOfObjectMap();
        for (var name in component) {
          validatePropertyKey(name, component[name], parentType);
        }
      }
    }
    function checkPropTypes(componentName, propTypes, props, location) {
      for (var propName in propTypes) {
        if (propTypes.hasOwnProperty(propName)) {
          var error;
          try {
            error = propTypes[propName](props, propName, componentName, location);
          } catch (ex) {
            error = ex;
          }
          if (error instanceof Error && !(error.message in loggedTypeFailures)) {
            loggedTypeFailures[error.message] = true;
            monitorCodeUse('react_failed_descriptor_type_check', {message: error.message});
          }
        }
      }
    }
    var ReactElementValidator = {
      createElement: function(type, props, children) {
        ("production" !== process.env.NODE_ENV ? warning(type != null, 'React.createElement: type should not be null or undefined. It should ' + 'be a string (for DOM elements) or a ReactClass (for composite ' + 'components).') : null);
        var element = ReactElement.createElement.apply(this, arguments);
        if (element == null) {
          return element;
        }
        for (var i = 2; i < arguments.length; i++) {
          validateChildKeys(arguments[i], type);
        }
        if (type) {
          var name = type.displayName;
          if (type.propTypes) {
            checkPropTypes(name, type.propTypes, element.props, ReactPropTypeLocations.prop);
          }
          if (type.contextTypes) {
            checkPropTypes(name, type.contextTypes, element._context, ReactPropTypeLocations.context);
          }
        }
        return element;
      },
      createFactory: function(type) {
        var validatedFactory = ReactElementValidator.createElement.bind(null, type);
        validatedFactory.type = type;
        return validatedFactory;
      }
    };
    module.exports = ReactElementValidator;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactPropTransferer", ["npm:react@0.12.2/lib/Object.assign", "npm:react@0.12.2/lib/emptyFunction", "npm:react@0.12.2/lib/invariant", "npm:react@0.12.2/lib/joinClasses", "npm:react@0.12.2/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var assign = require("npm:react@0.12.2/lib/Object.assign");
    var emptyFunction = require("npm:react@0.12.2/lib/emptyFunction");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var joinClasses = require("npm:react@0.12.2/lib/joinClasses");
    var warning = require("npm:react@0.12.2/lib/warning");
    var didWarn = false;
    function createTransferStrategy(mergeStrategy) {
      return function(props, key, value) {
        if (!props.hasOwnProperty(key)) {
          props[key] = value;
        } else {
          props[key] = mergeStrategy(props[key], value);
        }
      };
    }
    var transferStrategyMerge = createTransferStrategy(function(a, b) {
      return assign({}, b, a);
    });
    var TransferStrategies = {
      children: emptyFunction,
      className: createTransferStrategy(joinClasses),
      style: transferStrategyMerge
    };
    function transferInto(props, newProps) {
      for (var thisKey in newProps) {
        if (!newProps.hasOwnProperty(thisKey)) {
          continue;
        }
        var transferStrategy = TransferStrategies[thisKey];
        if (transferStrategy && TransferStrategies.hasOwnProperty(thisKey)) {
          transferStrategy(props, thisKey, newProps[thisKey]);
        } else if (!props.hasOwnProperty(thisKey)) {
          props[thisKey] = newProps[thisKey];
        }
      }
      return props;
    }
    var ReactPropTransferer = {
      TransferStrategies: TransferStrategies,
      mergeProps: function(oldProps, newProps) {
        return transferInto(assign({}, oldProps), newProps);
      },
      Mixin: {transferPropsTo: function(element) {
          ("production" !== process.env.NODE_ENV ? invariant(element._owner === this, '%s: You can\'t call transferPropsTo() on a component that you ' + 'don\'t own, %s. This usually means you are calling ' + 'transferPropsTo() on a component passed in as props or children.', this.constructor.displayName, typeof element.type === 'string' ? element.type : element.type.displayName) : invariant(element._owner === this));
          if ("production" !== process.env.NODE_ENV) {
            if (!didWarn) {
              didWarn = true;
              ("production" !== process.env.NODE_ENV ? warning(false, 'transferPropsTo is deprecated. ' + 'See http://fb.me/react-transferpropsto for more information.') : null);
            }
          }
          transferInto(element.props, this.props);
          return element;
        }}
    };
    module.exports = ReactPropTransferer;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/instantiateReactComponent", ["npm:react@0.12.2/lib/warning", "npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/ReactLegacyElement", "npm:react@0.12.2/lib/ReactNativeComponent", "npm:react@0.12.2/lib/ReactEmptyComponent", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var warning = require("npm:react@0.12.2/lib/warning");
    var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
    var ReactLegacyElement = require("npm:react@0.12.2/lib/ReactLegacyElement");
    var ReactNativeComponent = require("npm:react@0.12.2/lib/ReactNativeComponent");
    var ReactEmptyComponent = require("npm:react@0.12.2/lib/ReactEmptyComponent");
    function instantiateReactComponent(element, parentCompositeType) {
      var instance;
      if ("production" !== process.env.NODE_ENV) {
        ("production" !== process.env.NODE_ENV ? warning(element && (typeof element.type === 'function' || typeof element.type === 'string'), 'Only functions or strings can be mounted as React components.') : null);
        if (element.type._mockedReactClassConstructor) {
          ReactLegacyElement._isLegacyCallWarningEnabled = false;
          try {
            instance = new element.type._mockedReactClassConstructor(element.props);
          } finally {
            ReactLegacyElement._isLegacyCallWarningEnabled = true;
          }
          if (ReactElement.isValidElement(instance)) {
            instance = new instance.type(instance.props);
          }
          var render = instance.render;
          if (!render) {
            element = ReactEmptyComponent.getEmptyComponent();
          } else {
            if (render._isMockFunction && !render._getMockImplementation()) {
              render.mockImplementation(ReactEmptyComponent.getEmptyComponent);
            }
            instance.construct(element);
            return instance;
          }
        }
      }
      if (typeof element.type === 'string') {
        instance = ReactNativeComponent.createInstanceForTag(element.type, element.props, parentCompositeType);
      } else {
        instance = new element.type(element.props);
      }
      if ("production" !== process.env.NODE_ENV) {
        ("production" !== process.env.NODE_ENV ? warning(typeof instance.construct === 'function' && typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function', 'Only React Components can be mounted.') : null);
      }
      instance.construct(element);
      return instance;
    }
    module.exports = instantiateReactComponent;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/camelizeStyleName", ["npm:react@0.12.2/lib/camelize"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var camelize = require("npm:react@0.12.2/lib/camelize");
  var msPattern = /^-ms-/;
  function camelizeStyleName(string) {
    return camelize(string.replace(msPattern, 'ms-'));
  }
  module.exports = camelizeStyleName;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/hyphenateStyleName", ["npm:react@0.12.2/lib/hyphenate"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var hyphenate = require("npm:react@0.12.2/lib/hyphenate");
  var msPattern = /^ms-/;
  function hyphenateStyleName(string) {
    return hyphenate(string).replace(msPattern, '-ms-');
  }
  module.exports = hyphenateStyleName;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/EventPluginHub", ["npm:react@0.12.2/lib/EventPluginRegistry", "npm:react@0.12.2/lib/EventPluginUtils", "npm:react@0.12.2/lib/accumulateInto", "npm:react@0.12.2/lib/forEachAccumulated", "npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var EventPluginRegistry = require("npm:react@0.12.2/lib/EventPluginRegistry");
    var EventPluginUtils = require("npm:react@0.12.2/lib/EventPluginUtils");
    var accumulateInto = require("npm:react@0.12.2/lib/accumulateInto");
    var forEachAccumulated = require("npm:react@0.12.2/lib/forEachAccumulated");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var listenerBank = {};
    var eventQueue = null;
    var executeDispatchesAndRelease = function(event) {
      if (event) {
        var executeDispatch = EventPluginUtils.executeDispatch;
        var PluginModule = EventPluginRegistry.getPluginModuleForEvent(event);
        if (PluginModule && PluginModule.executeDispatch) {
          executeDispatch = PluginModule.executeDispatch;
        }
        EventPluginUtils.executeDispatchesInOrder(event, executeDispatch);
        if (!event.isPersistent()) {
          event.constructor.release(event);
        }
      }
    };
    var InstanceHandle = null;
    function validateInstanceHandle() {
      var invalid = !InstanceHandle || !InstanceHandle.traverseTwoPhase || !InstanceHandle.traverseEnterLeave;
      if (invalid) {
        throw new Error('InstanceHandle not injected before use!');
      }
    }
    var EventPluginHub = {
      injection: {
        injectMount: EventPluginUtils.injection.injectMount,
        injectInstanceHandle: function(InjectedInstanceHandle) {
          InstanceHandle = InjectedInstanceHandle;
          if ("production" !== process.env.NODE_ENV) {
            validateInstanceHandle();
          }
        },
        getInstanceHandle: function() {
          if ("production" !== process.env.NODE_ENV) {
            validateInstanceHandle();
          }
          return InstanceHandle;
        },
        injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,
        injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
      },
      eventNameDispatchConfigs: EventPluginRegistry.eventNameDispatchConfigs,
      registrationNameModules: EventPluginRegistry.registrationNameModules,
      putListener: function(id, registrationName, listener) {
        ("production" !== process.env.NODE_ENV ? invariant(!listener || typeof listener === 'function', 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : invariant(!listener || typeof listener === 'function'));
        var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
        bankForRegistrationName[id] = listener;
      },
      getListener: function(id, registrationName) {
        var bankForRegistrationName = listenerBank[registrationName];
        return bankForRegistrationName && bankForRegistrationName[id];
      },
      deleteListener: function(id, registrationName) {
        var bankForRegistrationName = listenerBank[registrationName];
        if (bankForRegistrationName) {
          delete bankForRegistrationName[id];
        }
      },
      deleteAllListeners: function(id) {
        for (var registrationName in listenerBank) {
          delete listenerBank[registrationName][id];
        }
      },
      extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
        var events;
        var plugins = EventPluginRegistry.plugins;
        for (var i = 0,
            l = plugins.length; i < l; i++) {
          var possiblePlugin = plugins[i];
          if (possiblePlugin) {
            var extractedEvents = possiblePlugin.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent);
            if (extractedEvents) {
              events = accumulateInto(events, extractedEvents);
            }
          }
        }
        return events;
      },
      enqueueEvents: function(events) {
        if (events) {
          eventQueue = accumulateInto(eventQueue, events);
        }
      },
      processEventQueue: function() {
        var processingEventQueue = eventQueue;
        eventQueue = null;
        forEachAccumulated(processingEventQueue, executeDispatchesAndRelease);
        ("production" !== process.env.NODE_ENV ? invariant(!eventQueue, 'processEventQueue(): Additional events were enqueued while processing ' + 'an event queue. Support for this has not yet been implemented.') : invariant(!eventQueue));
      },
      __purge: function() {
        listenerBank = {};
      },
      __getListenerBank: function() {
        return listenerBank;
      }
    };
    module.exports = EventPluginHub;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ViewportMetrics", ["npm:react@0.12.2/lib/getUnboundedScrollPosition"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var getUnboundedScrollPosition = require("npm:react@0.12.2/lib/getUnboundedScrollPosition");
  var ViewportMetrics = {
    currentScrollLeft: 0,
    currentScrollTop: 0,
    refreshScrollValues: function() {
      var scrollPosition = getUnboundedScrollPosition(window);
      ViewportMetrics.currentScrollLeft = scrollPosition.x;
      ViewportMetrics.currentScrollTop = scrollPosition.y;
    }
  };
  module.exports = ViewportMetrics;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/isTextNode", ["npm:react@0.12.2/lib/isNode"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var isNode = require("npm:react@0.12.2/lib/isNode");
  function isTextNode(object) {
    return isNode(object) && object.nodeType == 3;
  }
  module.exports = isTextNode;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/flattenChildren", ["npm:react@0.12.2/lib/ReactTextComponent", "npm:react@0.12.2/lib/traverseAllChildren", "npm:react@0.12.2/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactTextComponent = require("npm:react@0.12.2/lib/ReactTextComponent");
    var traverseAllChildren = require("npm:react@0.12.2/lib/traverseAllChildren");
    var warning = require("npm:react@0.12.2/lib/warning");
    function flattenSingleChildIntoContext(traverseContext, child, name) {
      var result = traverseContext;
      var keyUnique = !result.hasOwnProperty(name);
      ("production" !== process.env.NODE_ENV ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : null);
      if (keyUnique && child != null) {
        var type = typeof child;
        var normalizedValue;
        if (type === 'string') {
          normalizedValue = ReactTextComponent(child);
        } else if (type === 'number') {
          normalizedValue = ReactTextComponent('' + child);
        } else {
          normalizedValue = child;
        }
        result[name] = normalizedValue;
      }
    }
    function flattenChildren(children) {
      if (children == null) {
        return children;
      }
      var result = {};
      traverseAllChildren(children, flattenSingleChildIntoContext, result);
      return result;
    }
    module.exports = flattenChildren;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SyntheticEvent", ["npm:react@0.12.2/lib/PooledClass", "npm:react@0.12.2/lib/Object.assign", "npm:react@0.12.2/lib/emptyFunction", "npm:react@0.12.2/lib/getEventTarget"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var PooledClass = require("npm:react@0.12.2/lib/PooledClass");
  var assign = require("npm:react@0.12.2/lib/Object.assign");
  var emptyFunction = require("npm:react@0.12.2/lib/emptyFunction");
  var getEventTarget = require("npm:react@0.12.2/lib/getEventTarget");
  var EventInterface = {
    type: null,
    target: getEventTarget,
    currentTarget: emptyFunction.thatReturnsNull,
    eventPhase: null,
    bubbles: null,
    cancelable: null,
    timeStamp: function(event) {
      return event.timeStamp || Date.now();
    },
    defaultPrevented: null,
    isTrusted: null
  };
  function SyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    this.dispatchConfig = dispatchConfig;
    this.dispatchMarker = dispatchMarker;
    this.nativeEvent = nativeEvent;
    var Interface = this.constructor.Interface;
    for (var propName in Interface) {
      if (!Interface.hasOwnProperty(propName)) {
        continue;
      }
      var normalize = Interface[propName];
      if (normalize) {
        this[propName] = normalize(nativeEvent);
      } else {
        this[propName] = nativeEvent[propName];
      }
    }
    var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
    if (defaultPrevented) {
      this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
    } else {
      this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
    }
    this.isPropagationStopped = emptyFunction.thatReturnsFalse;
  }
  assign(SyntheticEvent.prototype, {
    preventDefault: function() {
      this.defaultPrevented = true;
      var event = this.nativeEvent;
      event.preventDefault ? event.preventDefault() : event.returnValue = false;
      this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
    },
    stopPropagation: function() {
      var event = this.nativeEvent;
      event.stopPropagation ? event.stopPropagation() : event.cancelBubble = true;
      this.isPropagationStopped = emptyFunction.thatReturnsTrue;
    },
    persist: function() {
      this.isPersistent = emptyFunction.thatReturnsTrue;
    },
    isPersistent: emptyFunction.thatReturnsFalse,
    destructor: function() {
      var Interface = this.constructor.Interface;
      for (var propName in Interface) {
        this[propName] = null;
      }
      this.dispatchConfig = null;
      this.dispatchMarker = null;
      this.nativeEvent = null;
    }
  });
  SyntheticEvent.Interface = EventInterface;
  SyntheticEvent.augmentClass = function(Class, Interface) {
    var Super = this;
    var prototype = Object.create(Super.prototype);
    assign(prototype, Class.prototype);
    Class.prototype = prototype;
    Class.prototype.constructor = Class;
    Class.Interface = assign({}, Super.Interface, Interface);
    Class.augmentClass = Super.augmentClass;
    PooledClass.addPoolingTo(Class, PooledClass.threeArgumentPooler);
  };
  PooledClass.addPoolingTo(SyntheticEvent, PooledClass.threeArgumentPooler);
  module.exports = SyntheticEvent;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ChangeEventPlugin", ["npm:react@0.12.2/lib/EventConstants", "npm:react@0.12.2/lib/EventPluginHub", "npm:react@0.12.2/lib/EventPropagators", "npm:react@0.12.2/lib/ExecutionEnvironment", "npm:react@0.12.2/lib/ReactUpdates", "npm:react@0.12.2/lib/SyntheticEvent", "npm:react@0.12.2/lib/isEventSupported", "npm:react@0.12.2/lib/isTextInputElement", "npm:react@0.12.2/lib/keyOf", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var EventConstants = require("npm:react@0.12.2/lib/EventConstants");
    var EventPluginHub = require("npm:react@0.12.2/lib/EventPluginHub");
    var EventPropagators = require("npm:react@0.12.2/lib/EventPropagators");
    var ExecutionEnvironment = require("npm:react@0.12.2/lib/ExecutionEnvironment");
    var ReactUpdates = require("npm:react@0.12.2/lib/ReactUpdates");
    var SyntheticEvent = require("npm:react@0.12.2/lib/SyntheticEvent");
    var isEventSupported = require("npm:react@0.12.2/lib/isEventSupported");
    var isTextInputElement = require("npm:react@0.12.2/lib/isTextInputElement");
    var keyOf = require("npm:react@0.12.2/lib/keyOf");
    var topLevelTypes = EventConstants.topLevelTypes;
    var eventTypes = {change: {
        phasedRegistrationNames: {
          bubbled: keyOf({onChange: null}),
          captured: keyOf({onChangeCapture: null})
        },
        dependencies: [topLevelTypes.topBlur, topLevelTypes.topChange, topLevelTypes.topClick, topLevelTypes.topFocus, topLevelTypes.topInput, topLevelTypes.topKeyDown, topLevelTypes.topKeyUp, topLevelTypes.topSelectionChange]
      }};
    var activeElement = null;
    var activeElementID = null;
    var activeElementValue = null;
    var activeElementValueProp = null;
    function shouldUseChangeEvent(elem) {
      return (elem.nodeName === 'SELECT' || (elem.nodeName === 'INPUT' && elem.type === 'file'));
    }
    var doesChangeEventBubble = false;
    if (ExecutionEnvironment.canUseDOM) {
      doesChangeEventBubble = isEventSupported('change') && (!('documentMode' in document) || document.documentMode > 8);
    }
    function manualDispatchChangeEvent(nativeEvent) {
      var event = SyntheticEvent.getPooled(eventTypes.change, activeElementID, nativeEvent);
      EventPropagators.accumulateTwoPhaseDispatches(event);
      ReactUpdates.batchedUpdates(runEventInBatch, event);
    }
    function runEventInBatch(event) {
      EventPluginHub.enqueueEvents(event);
      EventPluginHub.processEventQueue();
    }
    function startWatchingForChangeEventIE8(target, targetID) {
      activeElement = target;
      activeElementID = targetID;
      activeElement.attachEvent('onchange', manualDispatchChangeEvent);
    }
    function stopWatchingForChangeEventIE8() {
      if (!activeElement) {
        return ;
      }
      activeElement.detachEvent('onchange', manualDispatchChangeEvent);
      activeElement = null;
      activeElementID = null;
    }
    function getTargetIDForChangeEvent(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topChange) {
        return topLevelTargetID;
      }
    }
    function handleEventsForChangeEventIE8(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topFocus) {
        stopWatchingForChangeEventIE8();
        startWatchingForChangeEventIE8(topLevelTarget, topLevelTargetID);
      } else if (topLevelType === topLevelTypes.topBlur) {
        stopWatchingForChangeEventIE8();
      }
    }
    var isInputEventSupported = false;
    if (ExecutionEnvironment.canUseDOM) {
      isInputEventSupported = isEventSupported('input') && (!('documentMode' in document) || document.documentMode > 9);
    }
    var newValueProp = {
      get: function() {
        return activeElementValueProp.get.call(this);
      },
      set: function(val) {
        activeElementValue = '' + val;
        activeElementValueProp.set.call(this, val);
      }
    };
    function startWatchingForValueChange(target, targetID) {
      activeElement = target;
      activeElementID = targetID;
      activeElementValue = target.value;
      activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');
      Object.defineProperty(activeElement, 'value', newValueProp);
      activeElement.attachEvent('onpropertychange', handlePropertyChange);
    }
    function stopWatchingForValueChange() {
      if (!activeElement) {
        return ;
      }
      delete activeElement.value;
      activeElement.detachEvent('onpropertychange', handlePropertyChange);
      activeElement = null;
      activeElementID = null;
      activeElementValue = null;
      activeElementValueProp = null;
    }
    function handlePropertyChange(nativeEvent) {
      if (nativeEvent.propertyName !== 'value') {
        return ;
      }
      var value = nativeEvent.srcElement.value;
      if (value === activeElementValue) {
        return ;
      }
      activeElementValue = value;
      manualDispatchChangeEvent(nativeEvent);
    }
    function getTargetIDForInputEvent(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topInput) {
        return topLevelTargetID;
      }
    }
    function handleEventsForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topFocus) {
        stopWatchingForValueChange();
        startWatchingForValueChange(topLevelTarget, topLevelTargetID);
      } else if (topLevelType === topLevelTypes.topBlur) {
        stopWatchingForValueChange();
      }
    }
    function getTargetIDForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topSelectionChange || topLevelType === topLevelTypes.topKeyUp || topLevelType === topLevelTypes.topKeyDown) {
        if (activeElement && activeElement.value !== activeElementValue) {
          activeElementValue = activeElement.value;
          return activeElementID;
        }
      }
    }
    function shouldUseClickEvent(elem) {
      return (elem.nodeName === 'INPUT' && (elem.type === 'checkbox' || elem.type === 'radio'));
    }
    function getTargetIDForClickEvent(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topClick) {
        return topLevelTargetID;
      }
    }
    var ChangeEventPlugin = {
      eventTypes: eventTypes,
      extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
        var getTargetIDFunc,
            handleEventFunc;
        if (shouldUseChangeEvent(topLevelTarget)) {
          if (doesChangeEventBubble) {
            getTargetIDFunc = getTargetIDForChangeEvent;
          } else {
            handleEventFunc = handleEventsForChangeEventIE8;
          }
        } else if (isTextInputElement(topLevelTarget)) {
          if (isInputEventSupported) {
            getTargetIDFunc = getTargetIDForInputEvent;
          } else {
            getTargetIDFunc = getTargetIDForInputEventIE;
            handleEventFunc = handleEventsForInputEventIE;
          }
        } else if (shouldUseClickEvent(topLevelTarget)) {
          getTargetIDFunc = getTargetIDForClickEvent;
        }
        if (getTargetIDFunc) {
          var targetID = getTargetIDFunc(topLevelType, topLevelTarget, topLevelTargetID);
          if (targetID) {
            var event = SyntheticEvent.getPooled(eventTypes.change, targetID, nativeEvent);
            EventPropagators.accumulateTwoPhaseDispatches(event);
            return event;
          }
        }
        if (handleEventFunc) {
          handleEventFunc(topLevelType, topLevelTarget, topLevelTargetID);
        }
      }
    };
    module.exports = ChangeEventPlugin;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDOMSelection", ["npm:react@0.12.2/lib/ExecutionEnvironment", "npm:react@0.12.2/lib/getNodeForCharacterOffset", "npm:react@0.12.2/lib/getTextContentAccessor"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var ExecutionEnvironment = require("npm:react@0.12.2/lib/ExecutionEnvironment");
  var getNodeForCharacterOffset = require("npm:react@0.12.2/lib/getNodeForCharacterOffset");
  var getTextContentAccessor = require("npm:react@0.12.2/lib/getTextContentAccessor");
  function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
    return anchorNode === focusNode && anchorOffset === focusOffset;
  }
  function getIEOffsets(node) {
    var selection = document.selection;
    var selectedRange = selection.createRange();
    var selectedLength = selectedRange.text.length;
    var fromStart = selectedRange.duplicate();
    fromStart.moveToElementText(node);
    fromStart.setEndPoint('EndToStart', selectedRange);
    var startOffset = fromStart.text.length;
    var endOffset = startOffset + selectedLength;
    return {
      start: startOffset,
      end: endOffset
    };
  }
  function getModernOffsets(node) {
    var selection = window.getSelection && window.getSelection();
    if (!selection || selection.rangeCount === 0) {
      return null;
    }
    var anchorNode = selection.anchorNode;
    var anchorOffset = selection.anchorOffset;
    var focusNode = selection.focusNode;
    var focusOffset = selection.focusOffset;
    var currentRange = selection.getRangeAt(0);
    var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
    var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;
    var tempRange = currentRange.cloneRange();
    tempRange.selectNodeContents(node);
    tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);
    var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);
    var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
    var end = start + rangeLength;
    var detectionRange = document.createRange();
    detectionRange.setStart(anchorNode, anchorOffset);
    detectionRange.setEnd(focusNode, focusOffset);
    var isBackward = detectionRange.collapsed;
    return {
      start: isBackward ? end : start,
      end: isBackward ? start : end
    };
  }
  function setIEOffsets(node, offsets) {
    var range = document.selection.createRange().duplicate();
    var start,
        end;
    if (typeof offsets.end === 'undefined') {
      start = offsets.start;
      end = start;
    } else if (offsets.start > offsets.end) {
      start = offsets.end;
      end = offsets.start;
    } else {
      start = offsets.start;
      end = offsets.end;
    }
    range.moveToElementText(node);
    range.moveStart('character', start);
    range.setEndPoint('EndToStart', range);
    range.moveEnd('character', end - start);
    range.select();
  }
  function setModernOffsets(node, offsets) {
    if (!window.getSelection) {
      return ;
    }
    var selection = window.getSelection();
    var length = node[getTextContentAccessor()].length;
    var start = Math.min(offsets.start, length);
    var end = typeof offsets.end === 'undefined' ? start : Math.min(offsets.end, length);
    if (!selection.extend && start > end) {
      var temp = end;
      end = start;
      start = temp;
    }
    var startMarker = getNodeForCharacterOffset(node, start);
    var endMarker = getNodeForCharacterOffset(node, end);
    if (startMarker && endMarker) {
      var range = document.createRange();
      range.setStart(startMarker.node, startMarker.offset);
      selection.removeAllRanges();
      if (start > end) {
        selection.addRange(range);
        selection.extend(endMarker.node, endMarker.offset);
      } else {
        range.setEnd(endMarker.node, endMarker.offset);
        selection.addRange(range);
      }
    }
  }
  var useIEOffsets = ExecutionEnvironment.canUseDOM && document.selection;
  var ReactDOMSelection = {
    getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,
    setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
  };
  module.exports = ReactDOMSelection;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SyntheticMouseEvent", ["npm:react@0.12.2/lib/SyntheticUIEvent", "npm:react@0.12.2/lib/ViewportMetrics", "npm:react@0.12.2/lib/getEventModifierState"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var SyntheticUIEvent = require("npm:react@0.12.2/lib/SyntheticUIEvent");
  var ViewportMetrics = require("npm:react@0.12.2/lib/ViewportMetrics");
  var getEventModifierState = require("npm:react@0.12.2/lib/getEventModifierState");
  var MouseEventInterface = {
    screenX: null,
    screenY: null,
    clientX: null,
    clientY: null,
    ctrlKey: null,
    shiftKey: null,
    altKey: null,
    metaKey: null,
    getModifierState: getEventModifierState,
    button: function(event) {
      var button = event.button;
      if ('which' in event) {
        return button;
      }
      return button === 2 ? 2 : button === 4 ? 1 : 0;
    },
    buttons: null,
    relatedTarget: function(event) {
      return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
    },
    pageX: function(event) {
      return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
    },
    pageY: function(event) {
      return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
    }
  };
  function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);
  module.exports = SyntheticMouseEvent;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/createArrayFrom", ["npm:react@0.12.2/lib/toArray"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var toArray = require("npm:react@0.12.2/lib/toArray");
  function hasArrayNature(obj) {
    return (!!obj && (typeof obj == 'object' || typeof obj == 'function') && ('length' in obj) && !('setInterval' in obj) && (typeof obj.nodeType != 'number') && (((Array.isArray(obj) || ('callee' in obj) || 'item' in obj))));
  }
  function createArrayFrom(obj) {
    if (!hasArrayNature(obj)) {
      return [obj];
    } else if (Array.isArray(obj)) {
      return obj.slice();
    } else {
      return toArray(obj);
    }
  }
  module.exports = createArrayFrom;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactMarkupChecksum", ["npm:react@0.12.2/lib/adler32"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var adler32 = require("npm:react@0.12.2/lib/adler32");
  var ReactMarkupChecksum = {
    CHECKSUM_ATTR_NAME: 'data-react-checksum',
    addChecksumToMarkup: function(markup) {
      var checksum = adler32(markup);
      return markup.replace('>', ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '">');
    },
    canReuseMarkup: function(markup, element) {
      var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
      existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
      var markupChecksum = adler32(markup);
      return markupChecksum === existingChecksum;
    }
  };
  module.exports = ReactMarkupChecksum;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactReconcileTransaction", ["npm:react@0.12.2/lib/CallbackQueue", "npm:react@0.12.2/lib/PooledClass", "npm:react@0.12.2/lib/ReactBrowserEventEmitter", "npm:react@0.12.2/lib/ReactInputSelection", "npm:react@0.12.2/lib/ReactPutListenerQueue", "npm:react@0.12.2/lib/Transaction", "npm:react@0.12.2/lib/Object.assign"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var CallbackQueue = require("npm:react@0.12.2/lib/CallbackQueue");
  var PooledClass = require("npm:react@0.12.2/lib/PooledClass");
  var ReactBrowserEventEmitter = require("npm:react@0.12.2/lib/ReactBrowserEventEmitter");
  var ReactInputSelection = require("npm:react@0.12.2/lib/ReactInputSelection");
  var ReactPutListenerQueue = require("npm:react@0.12.2/lib/ReactPutListenerQueue");
  var Transaction = require("npm:react@0.12.2/lib/Transaction");
  var assign = require("npm:react@0.12.2/lib/Object.assign");
  var SELECTION_RESTORATION = {
    initialize: ReactInputSelection.getSelectionInformation,
    close: ReactInputSelection.restoreSelection
  };
  var EVENT_SUPPRESSION = {
    initialize: function() {
      var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
      ReactBrowserEventEmitter.setEnabled(false);
      return currentlyEnabled;
    },
    close: function(previouslyEnabled) {
      ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
    }
  };
  var ON_DOM_READY_QUEUEING = {
    initialize: function() {
      this.reactMountReady.reset();
    },
    close: function() {
      this.reactMountReady.notifyAll();
    }
  };
  var PUT_LISTENER_QUEUEING = {
    initialize: function() {
      this.putListenerQueue.reset();
    },
    close: function() {
      this.putListenerQueue.putListeners();
    }
  };
  var TRANSACTION_WRAPPERS = [PUT_LISTENER_QUEUEING, SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];
  function ReactReconcileTransaction() {
    this.reinitializeTransaction();
    this.renderToStaticMarkup = false;
    this.reactMountReady = CallbackQueue.getPooled(null);
    this.putListenerQueue = ReactPutListenerQueue.getPooled();
  }
  var Mixin = {
    getTransactionWrappers: function() {
      return TRANSACTION_WRAPPERS;
    },
    getReactMountReady: function() {
      return this.reactMountReady;
    },
    getPutListenerQueue: function() {
      return this.putListenerQueue;
    },
    destructor: function() {
      CallbackQueue.release(this.reactMountReady);
      this.reactMountReady = null;
      ReactPutListenerQueue.release(this.putListenerQueue);
      this.putListenerQueue = null;
    }
  };
  assign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);
  PooledClass.addPoolingTo(ReactReconcileTransaction);
  module.exports = ReactReconcileTransaction;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDOMButton", ["npm:react@0.12.2/lib/AutoFocusMixin", "npm:react@0.12.2/lib/ReactBrowserComponentMixin", "npm:react@0.12.2/lib/ReactCompositeComponent", "npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/ReactDOM", "npm:react@0.12.2/lib/keyMirror"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var AutoFocusMixin = require("npm:react@0.12.2/lib/AutoFocusMixin");
  var ReactBrowserComponentMixin = require("npm:react@0.12.2/lib/ReactBrowserComponentMixin");
  var ReactCompositeComponent = require("npm:react@0.12.2/lib/ReactCompositeComponent");
  var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
  var ReactDOM = require("npm:react@0.12.2/lib/ReactDOM");
  var keyMirror = require("npm:react@0.12.2/lib/keyMirror");
  var button = ReactElement.createFactory(ReactDOM.button.type);
  var mouseListenerNames = keyMirror({
    onClick: true,
    onDoubleClick: true,
    onMouseDown: true,
    onMouseMove: true,
    onMouseUp: true,
    onClickCapture: true,
    onDoubleClickCapture: true,
    onMouseDownCapture: true,
    onMouseMoveCapture: true,
    onMouseUpCapture: true
  });
  var ReactDOMButton = ReactCompositeComponent.createClass({
    displayName: 'ReactDOMButton',
    mixins: [AutoFocusMixin, ReactBrowserComponentMixin],
    render: function() {
      var props = {};
      for (var key in this.props) {
        if (this.props.hasOwnProperty(key) && (!this.props.disabled || !mouseListenerNames[key])) {
          props[key] = this.props[key];
        }
      }
      return button(props, this.props.children);
    }
  });
  module.exports = ReactDOMButton;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDOMForm", ["npm:react@0.12.2/lib/EventConstants", "npm:react@0.12.2/lib/LocalEventTrapMixin", "npm:react@0.12.2/lib/ReactBrowserComponentMixin", "npm:react@0.12.2/lib/ReactCompositeComponent", "npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/ReactDOM"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var EventConstants = require("npm:react@0.12.2/lib/EventConstants");
  var LocalEventTrapMixin = require("npm:react@0.12.2/lib/LocalEventTrapMixin");
  var ReactBrowserComponentMixin = require("npm:react@0.12.2/lib/ReactBrowserComponentMixin");
  var ReactCompositeComponent = require("npm:react@0.12.2/lib/ReactCompositeComponent");
  var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
  var ReactDOM = require("npm:react@0.12.2/lib/ReactDOM");
  var form = ReactElement.createFactory(ReactDOM.form.type);
  var ReactDOMForm = ReactCompositeComponent.createClass({
    displayName: 'ReactDOMForm',
    mixins: [ReactBrowserComponentMixin, LocalEventTrapMixin],
    render: function() {
      return form(this.props);
    },
    componentDidMount: function() {
      this.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset');
      this.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit');
    }
  });
  module.exports = ReactDOMForm;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/LinkedValueUtils", ["npm:react@0.12.2/lib/ReactPropTypes", "npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactPropTypes = require("npm:react@0.12.2/lib/ReactPropTypes");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var hasReadOnlyValue = {
      'button': true,
      'checkbox': true,
      'image': true,
      'hidden': true,
      'radio': true,
      'reset': true,
      'submit': true
    };
    function _assertSingleLink(input) {
      ("production" !== process.env.NODE_ENV ? invariant(input.props.checkedLink == null || input.props.valueLink == null, 'Cannot provide a checkedLink and a valueLink. If you want to use ' + 'checkedLink, you probably don\'t want to use valueLink and vice versa.') : invariant(input.props.checkedLink == null || input.props.valueLink == null));
    }
    function _assertValueLink(input) {
      _assertSingleLink(input);
      ("production" !== process.env.NODE_ENV ? invariant(input.props.value == null && input.props.onChange == null, 'Cannot provide a valueLink and a value or onChange event. If you want ' + 'to use value or onChange, you probably don\'t want to use valueLink.') : invariant(input.props.value == null && input.props.onChange == null));
    }
    function _assertCheckedLink(input) {
      _assertSingleLink(input);
      ("production" !== process.env.NODE_ENV ? invariant(input.props.checked == null && input.props.onChange == null, 'Cannot provide a checkedLink and a checked property or onChange event. ' + 'If you want to use checked or onChange, you probably don\'t want to ' + 'use checkedLink') : invariant(input.props.checked == null && input.props.onChange == null));
    }
    function _handleLinkedValueChange(e) {
      this.props.valueLink.requestChange(e.target.value);
    }
    function _handleLinkedCheckChange(e) {
      this.props.checkedLink.requestChange(e.target.checked);
    }
    var LinkedValueUtils = {
      Mixin: {propTypes: {
          value: function(props, propName, componentName) {
            if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
              return ;
            }
            return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
          },
          checked: function(props, propName, componentName) {
            if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
              return ;
            }
            return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
          },
          onChange: ReactPropTypes.func
        }},
      getValue: function(input) {
        if (input.props.valueLink) {
          _assertValueLink(input);
          return input.props.valueLink.value;
        }
        return input.props.value;
      },
      getChecked: function(input) {
        if (input.props.checkedLink) {
          _assertCheckedLink(input);
          return input.props.checkedLink.value;
        }
        return input.props.checked;
      },
      getOnChange: function(input) {
        if (input.props.valueLink) {
          _assertValueLink(input);
          return _handleLinkedValueChange;
        } else if (input.props.checkedLink) {
          _assertCheckedLink(input);
          return _handleLinkedCheckChange;
        }
        return input.props.onChange;
      }
    };
    module.exports = LinkedValueUtils;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactEventListener", ["npm:react@0.12.2/lib/EventListener", "npm:react@0.12.2/lib/ExecutionEnvironment", "npm:react@0.12.2/lib/PooledClass", "npm:react@0.12.2/lib/ReactInstanceHandles", "npm:react@0.12.2/lib/ReactMount", "npm:react@0.12.2/lib/ReactUpdates", "npm:react@0.12.2/lib/Object.assign", "npm:react@0.12.2/lib/getEventTarget", "npm:react@0.12.2/lib/getUnboundedScrollPosition", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var EventListener = require("npm:react@0.12.2/lib/EventListener");
    var ExecutionEnvironment = require("npm:react@0.12.2/lib/ExecutionEnvironment");
    var PooledClass = require("npm:react@0.12.2/lib/PooledClass");
    var ReactInstanceHandles = require("npm:react@0.12.2/lib/ReactInstanceHandles");
    var ReactMount = require("npm:react@0.12.2/lib/ReactMount");
    var ReactUpdates = require("npm:react@0.12.2/lib/ReactUpdates");
    var assign = require("npm:react@0.12.2/lib/Object.assign");
    var getEventTarget = require("npm:react@0.12.2/lib/getEventTarget");
    var getUnboundedScrollPosition = require("npm:react@0.12.2/lib/getUnboundedScrollPosition");
    function findParent(node) {
      var nodeID = ReactMount.getID(node);
      var rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
      var container = ReactMount.findReactContainerForID(rootID);
      var parent = ReactMount.getFirstReactDOM(container);
      return parent;
    }
    function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
      this.topLevelType = topLevelType;
      this.nativeEvent = nativeEvent;
      this.ancestors = [];
    }
    assign(TopLevelCallbackBookKeeping.prototype, {destructor: function() {
        this.topLevelType = null;
        this.nativeEvent = null;
        this.ancestors.length = 0;
      }});
    PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);
    function handleTopLevelImpl(bookKeeping) {
      var topLevelTarget = ReactMount.getFirstReactDOM(getEventTarget(bookKeeping.nativeEvent)) || window;
      var ancestor = topLevelTarget;
      while (ancestor) {
        bookKeeping.ancestors.push(ancestor);
        ancestor = findParent(ancestor);
      }
      for (var i = 0,
          l = bookKeeping.ancestors.length; i < l; i++) {
        topLevelTarget = bookKeeping.ancestors[i];
        var topLevelTargetID = ReactMount.getID(topLevelTarget) || '';
        ReactEventListener._handleTopLevel(bookKeeping.topLevelType, topLevelTarget, topLevelTargetID, bookKeeping.nativeEvent);
      }
    }
    function scrollValueMonitor(cb) {
      var scrollPosition = getUnboundedScrollPosition(window);
      cb(scrollPosition);
    }
    var ReactEventListener = {
      _enabled: true,
      _handleTopLevel: null,
      WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,
      setHandleTopLevel: function(handleTopLevel) {
        ReactEventListener._handleTopLevel = handleTopLevel;
      },
      setEnabled: function(enabled) {
        ReactEventListener._enabled = !!enabled;
      },
      isEnabled: function() {
        return ReactEventListener._enabled;
      },
      trapBubbledEvent: function(topLevelType, handlerBaseName, handle) {
        var element = handle;
        if (!element) {
          return ;
        }
        return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
      },
      trapCapturedEvent: function(topLevelType, handlerBaseName, handle) {
        var element = handle;
        if (!element) {
          return ;
        }
        return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
      },
      monitorScrollValue: function(refresh) {
        var callback = scrollValueMonitor.bind(null, refresh);
        EventListener.listen(window, 'scroll', callback);
        EventListener.listen(window, 'resize', callback);
      },
      dispatchEvent: function(topLevelType, nativeEvent) {
        if (!ReactEventListener._enabled) {
          return ;
        }
        var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
        try {
          ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
        } finally {
          TopLevelCallbackBookKeeping.release(bookKeeping);
        }
      }
    };
    module.exports = ReactEventListener;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SelectEventPlugin", ["npm:react@0.12.2/lib/EventConstants", "npm:react@0.12.2/lib/EventPropagators", "npm:react@0.12.2/lib/ReactInputSelection", "npm:react@0.12.2/lib/SyntheticEvent", "npm:react@0.12.2/lib/getActiveElement", "npm:react@0.12.2/lib/isTextInputElement", "npm:react@0.12.2/lib/keyOf", "npm:react@0.12.2/lib/shallowEqual"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var EventConstants = require("npm:react@0.12.2/lib/EventConstants");
  var EventPropagators = require("npm:react@0.12.2/lib/EventPropagators");
  var ReactInputSelection = require("npm:react@0.12.2/lib/ReactInputSelection");
  var SyntheticEvent = require("npm:react@0.12.2/lib/SyntheticEvent");
  var getActiveElement = require("npm:react@0.12.2/lib/getActiveElement");
  var isTextInputElement = require("npm:react@0.12.2/lib/isTextInputElement");
  var keyOf = require("npm:react@0.12.2/lib/keyOf");
  var shallowEqual = require("npm:react@0.12.2/lib/shallowEqual");
  var topLevelTypes = EventConstants.topLevelTypes;
  var eventTypes = {select: {
      phasedRegistrationNames: {
        bubbled: keyOf({onSelect: null}),
        captured: keyOf({onSelectCapture: null})
      },
      dependencies: [topLevelTypes.topBlur, topLevelTypes.topContextMenu, topLevelTypes.topFocus, topLevelTypes.topKeyDown, topLevelTypes.topMouseDown, topLevelTypes.topMouseUp, topLevelTypes.topSelectionChange]
    }};
  var activeElement = null;
  var activeElementID = null;
  var lastSelection = null;
  var mouseDown = false;
  function getSelection(node) {
    if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
      return {
        start: node.selectionStart,
        end: node.selectionEnd
      };
    } else if (window.getSelection) {
      var selection = window.getSelection();
      return {
        anchorNode: selection.anchorNode,
        anchorOffset: selection.anchorOffset,
        focusNode: selection.focusNode,
        focusOffset: selection.focusOffset
      };
    } else if (document.selection) {
      var range = document.selection.createRange();
      return {
        parentElement: range.parentElement(),
        text: range.text,
        top: range.boundingTop,
        left: range.boundingLeft
      };
    }
  }
  function constructSelectEvent(nativeEvent) {
    if (mouseDown || activeElement == null || activeElement != getActiveElement()) {
      return ;
    }
    var currentSelection = getSelection(activeElement);
    if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
      lastSelection = currentSelection;
      var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementID, nativeEvent);
      syntheticEvent.type = 'select';
      syntheticEvent.target = activeElement;
      EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);
      return syntheticEvent;
    }
  }
  var SelectEventPlugin = {
    eventTypes: eventTypes,
    extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
      switch (topLevelType) {
        case topLevelTypes.topFocus:
          if (isTextInputElement(topLevelTarget) || topLevelTarget.contentEditable === 'true') {
            activeElement = topLevelTarget;
            activeElementID = topLevelTargetID;
            lastSelection = null;
          }
          break;
        case topLevelTypes.topBlur:
          activeElement = null;
          activeElementID = null;
          lastSelection = null;
          break;
        case topLevelTypes.topMouseDown:
          mouseDown = true;
          break;
        case topLevelTypes.topContextMenu:
        case topLevelTypes.topMouseUp:
          mouseDown = false;
          return constructSelectEvent(nativeEvent);
        case topLevelTypes.topSelectionChange:
        case topLevelTypes.topKeyDown:
        case topLevelTypes.topKeyUp:
          return constructSelectEvent(nativeEvent);
      }
    }
  };
  module.exports = SelectEventPlugin;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SyntheticKeyboardEvent", ["npm:react@0.12.2/lib/SyntheticUIEvent", "npm:react@0.12.2/lib/getEventCharCode", "npm:react@0.12.2/lib/getEventKey", "npm:react@0.12.2/lib/getEventModifierState"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var SyntheticUIEvent = require("npm:react@0.12.2/lib/SyntheticUIEvent");
  var getEventCharCode = require("npm:react@0.12.2/lib/getEventCharCode");
  var getEventKey = require("npm:react@0.12.2/lib/getEventKey");
  var getEventModifierState = require("npm:react@0.12.2/lib/getEventModifierState");
  var KeyboardEventInterface = {
    key: getEventKey,
    location: null,
    ctrlKey: null,
    shiftKey: null,
    altKey: null,
    metaKey: null,
    repeat: null,
    locale: null,
    getModifierState: getEventModifierState,
    charCode: function(event) {
      if (event.type === 'keypress') {
        return getEventCharCode(event);
      }
      return 0;
    },
    keyCode: function(event) {
      if (event.type === 'keydown' || event.type === 'keyup') {
        return event.keyCode;
      }
      return 0;
    },
    which: function(event) {
      if (event.type === 'keypress') {
        return getEventCharCode(event);
      }
      if (event.type === 'keydown' || event.type === 'keyup') {
        return event.keyCode;
      }
      return 0;
    }
  };
  function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);
  module.exports = SyntheticKeyboardEvent;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/performanceNow", ["npm:react@0.12.2/lib/performance"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var performance = require("npm:react@0.12.2/lib/performance");
  if (!performance || !performance.now) {
    performance = Date;
  }
  var performanceNow = performance.now.bind(performance);
  module.exports = performanceNow;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactServerRendering", ["npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/ReactInstanceHandles", "npm:react@0.12.2/lib/ReactMarkupChecksum", "npm:react@0.12.2/lib/ReactServerRenderingTransaction", "npm:react@0.12.2/lib/instantiateReactComponent", "npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
    var ReactInstanceHandles = require("npm:react@0.12.2/lib/ReactInstanceHandles");
    var ReactMarkupChecksum = require("npm:react@0.12.2/lib/ReactMarkupChecksum");
    var ReactServerRenderingTransaction = require("npm:react@0.12.2/lib/ReactServerRenderingTransaction");
    var instantiateReactComponent = require("npm:react@0.12.2/lib/instantiateReactComponent");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    function renderToString(element) {
      ("production" !== process.env.NODE_ENV ? invariant(ReactElement.isValidElement(element), 'renderToString(): You must pass a valid ReactElement.') : invariant(ReactElement.isValidElement(element)));
      var transaction;
      try {
        var id = ReactInstanceHandles.createReactRootID();
        transaction = ReactServerRenderingTransaction.getPooled(false);
        return transaction.perform(function() {
          var componentInstance = instantiateReactComponent(element, null);
          var markup = componentInstance.mountComponent(id, transaction, 0);
          return ReactMarkupChecksum.addChecksumToMarkup(markup);
        }, null);
      } finally {
        ReactServerRenderingTransaction.release(transaction);
      }
    }
    function renderToStaticMarkup(element) {
      ("production" !== process.env.NODE_ENV ? invariant(ReactElement.isValidElement(element), 'renderToStaticMarkup(): You must pass a valid ReactElement.') : invariant(ReactElement.isValidElement(element)));
      var transaction;
      try {
        var id = ReactInstanceHandles.createReactRootID();
        transaction = ReactServerRenderingTransaction.getPooled(true);
        return transaction.perform(function() {
          var componentInstance = instantiateReactComponent(element, null);
          return componentInstance.mountComponent(id, transaction, 0);
        }, null);
      } finally {
        ReactServerRenderingTransaction.release(transaction);
      }
    }
    module.exports = {
      renderToString: renderToString,
      renderToStaticMarkup: renderToStaticMarkup
    };
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:loglevel@1.2.0", ["npm:loglevel@1.2.0/lib/loglevel"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:loglevel@1.2.0/lib/loglevel");
  global.define = __define;
  return module.exports;
});



(function() {
function define(){};  define.amd = {};
System.register("github:components/jquery@2.1.3", ["github:components/jquery@2.1.3/jquery"], false, function(__require, __exports, __module) {
  return (function(main) {
    return main;
  }).call(this, __require('github:components/jquery@2.1.3/jquery'));
});


})();
System.register("github:components/jqueryui@1.11.3", ["github:components/jqueryui@1.11.3/jquery-ui"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:components/jqueryui@1.11.3/jquery-ui");
  global.define = __define;
  return module.exports;
});



System.register("npm:lodash@3.3.1", ["npm:lodash@3.3.1/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:lodash@3.3.1/index");
  global.define = __define;
  return module.exports;
});



System.register("javascripts/models/link", ["javascripts/models/graph-primitive"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function() {
    var GraphPrimitive,
        Link,
        extend = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        },
        hasProp = {}.hasOwnProperty;
    GraphPrimitive = require("javascripts/models/graph-primitive");
    Link = (function(superClass) {
      extend(Link, superClass);
      Link.defaultColor = "#777";
      function Link(options) {
        var base,
            base1,
            ref;
        this.options = options != null ? options : {};
        (base = this.options).color || (base.color = Link.defaultColor);
        (base1 = this.options).title || (base1.title = "");
        ref = this.options, this.sourceNode = ref.sourceNode, this.sourceTerminal = ref.sourceTerminal, this.targetNode = ref.targetNode, this.targetTerminal = ref.targetTerminal, this.color = ref.color, this.title = ref.title;
        Link.__super__.constructor.call(this);
      }
      Link.prototype.type = function() {
        return "Link";
      };
      Link.prototype.terminalKey = function() {
        return this.sourceNode.key + "[" + this.sourceTerminal + "] ---" + this.key + "---> " + this.targetNode.key + "[" + this.targetTerminal + "]";
      };
      Link.prototype.nodeKey = function() {
        return this.sourceNode + " ---" + this.key + "---> " + this.targetNode;
      };
      Link.prototype.outs = function() {
        return [this.targetNode];
      };
      Link.prototype.ins = function() {
        return [this.sourceNode];
      };
      Link.prototype.toExport = function() {
        var sourceNodeKey,
            targetNodeKey;
        sourceNodeKey = this.sourceNode.key;
        targetNodeKey = this.targetNode.key;
        return {
          "title": this.title,
          "color": this.color,
          "sourceNodeKey": sourceNodeKey,
          "sourceTerminal": this.sourceTerminal,
          "targetNodeKey": targetNodeKey,
          "targetTerminal": this.targetTerminal
        };
      };
      return Link;
    })(GraphPrimitive);
    module.exports = Link;
  }).call(this);
  global.define = __define;
  return module.exports;
});



System.register("javascripts/node-well-view", ["npm:react@0.12.2", "javascripts/proto-node-view"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var React = require("npm:react@0.12.2");
  var ProtoNodeView = require("javascripts/proto-node-view");
  var protoNodes = [{
    "title": "Egg",
    "image": "https://dl.dropboxusercontent.com/u/73403/mysystem/images/egg2.png"
  }, {
    "title": "Chick",
    "image": "http://www.charlieschickencompany.com/IMAGES/pic5_09.jpg"
  }, {
    "title": "Chicken",
    "image": "http://news.ucdavis.edu/photos_images/news_images/03_2011/chicken_lg.jpg"
  }, {
    "title": "blank",
    "image": ""
  }];
  var NodeWell = React.createClass({
    displayName: "NodeWell",
    getInitialState: function() {
      return {nodes: []};
    },
    render: function() {
      var self = this;
      var nodeViews = protoNodes.map(function(node) {
        return (React.createElement(ProtoNodeView, {
          key: node.title,
          image: node.image
        }));
      });
      return (React.createElement("div", {className: "node-well"}, nodeViews));
    }
  });
  module.exports = NodeWell;
  global.define = __define;
  return module.exports;
});



System.register("javascripts/status-menu-view", ["npm:react@0.12.2", "npm:loglevel@1.2.0", "javascripts/vendor/touchpunch", "javascripts/google-drive-io"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var React = require("npm:react@0.12.2");
  var log = require("npm:loglevel@1.2.0");
  var $ = require("javascripts/vendor/touchpunch");
  var GoogleDriveIO = require("javascripts/google-drive-io");
  log.setLevel(log.levels.TRACE);
  var StatusMenu = React.createClass({
    displayName: "StatusMenu",
    getInitialState: function() {
      var state = {filename: "model"};
      return state;
    },
    componentWillUpdate: function() {},
    componentDidUpdate: function() {},
    componentDidMount: function() {},
    dataJson: function() {
      return this.props.getData();
    },
    openLink: function() {
      if (this.props.getData) {
        var json = this.props.getData();
        var encoded = encodeURIComponent(json);
        var url = window.location.protocol + "//" + window.location.host + window.location.pathname + "?data=" + encoded;
        window.open(url);
      }
    },
    saveToGDrive: function() {
      var googleDrive = new GoogleDriveIO();
      var filename = this.state.filename;
      var json = this.dataJson();
      log.info('Proposing to save to "' + filename + '"');
      if (!filename || filename.length === 0) {
        filename = 'model';
      }
      if (!/.*\.json$/.test(filename)) {
        filename += '.json';
      }
      log.info('Saving to "' + filename + '"');
      googleDrive.upload({
        fileName: filename,
        mimeType: 'application/json'
      }, json);
    },
    authorize: function() {
      var googleDrive = new GoogleDriveIO();
      googleDrive.authorize();
    },
    changeFilename: function(evnt) {
      log.info('Changing filename: ' + evnt.target.value);
      this.setState({filename: evnt.target.value});
    },
    render: function() {
      var openLink = this.openLink;
      var title = this.props.title || "Building Models";
      var linkText = this.props.linkText || "Link to my model";
      var saveToGDrive = this.saveToGDrive;
      var authorize = this.authorize;
      var changeFilename = this.changeFilename;
      var fileName = this.state.filename;
      return (React.createElement("div", {className: "status-menu"}, React.createElement("div", {className: "title"}, title), React.createElement("div", {className: "file-dialog-view"}, React.createElement("button", {
        id: "authorize",
        onClick: authorize
      }, "Authorize for Google Drive"), React.createElement("label", null, "Filename: "), React.createElement("input", {
        type: "text",
        onChange: changeFilename,
        value: fileName,
        id: "filename"
      }), React.createElement("button", {
        id: "send",
        onClick: saveToGDrive
      }, "Save to Google Drive")), React.createElement("div", {
        className: "open-data-url",
        onClick: openLink
      }, linkText)));
    }
  });
  module.exports = StatusMenu;
  global.define = __define;
  return module.exports;
});



System.register("github:jspm/nodelibs-process@0.1.1/index", ["npm:process@0.10.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? process : require("npm:process@0.10.0");
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/EventPluginUtils", ["npm:react@0.12.2/lib/EventConstants", "npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var EventConstants = require("npm:react@0.12.2/lib/EventConstants");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var injection = {
      Mount: null,
      injectMount: function(InjectedMount) {
        injection.Mount = InjectedMount;
        if ("production" !== process.env.NODE_ENV) {
          ("production" !== process.env.NODE_ENV ? invariant(InjectedMount && InjectedMount.getNode, 'EventPluginUtils.injection.injectMount(...): Injected Mount module ' + 'is missing getNode.') : invariant(InjectedMount && InjectedMount.getNode));
        }
      }
    };
    var topLevelTypes = EventConstants.topLevelTypes;
    function isEndish(topLevelType) {
      return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel;
    }
    function isMoveish(topLevelType) {
      return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove;
    }
    function isStartish(topLevelType) {
      return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart;
    }
    var validateEventDispatches;
    if ("production" !== process.env.NODE_ENV) {
      validateEventDispatches = function(event) {
        var dispatchListeners = event._dispatchListeners;
        var dispatchIDs = event._dispatchIDs;
        var listenersIsArr = Array.isArray(dispatchListeners);
        var idsIsArr = Array.isArray(dispatchIDs);
        var IDsLen = idsIsArr ? dispatchIDs.length : dispatchIDs ? 1 : 0;
        var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
        ("production" !== process.env.NODE_ENV ? invariant(idsIsArr === listenersIsArr && IDsLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : invariant(idsIsArr === listenersIsArr && IDsLen === listenersLen));
      };
    }
    function forEachEventDispatch(event, cb) {
      var dispatchListeners = event._dispatchListeners;
      var dispatchIDs = event._dispatchIDs;
      if ("production" !== process.env.NODE_ENV) {
        validateEventDispatches(event);
      }
      if (Array.isArray(dispatchListeners)) {
        for (var i = 0; i < dispatchListeners.length; i++) {
          if (event.isPropagationStopped()) {
            break;
          }
          cb(event, dispatchListeners[i], dispatchIDs[i]);
        }
      } else if (dispatchListeners) {
        cb(event, dispatchListeners, dispatchIDs);
      }
    }
    function executeDispatch(event, listener, domID) {
      event.currentTarget = injection.Mount.getNode(domID);
      var returnValue = listener(event, domID);
      event.currentTarget = null;
      return returnValue;
    }
    function executeDispatchesInOrder(event, executeDispatch) {
      forEachEventDispatch(event, executeDispatch);
      event._dispatchListeners = null;
      event._dispatchIDs = null;
    }
    function executeDispatchesInOrderStopAtTrueImpl(event) {
      var dispatchListeners = event._dispatchListeners;
      var dispatchIDs = event._dispatchIDs;
      if ("production" !== process.env.NODE_ENV) {
        validateEventDispatches(event);
      }
      if (Array.isArray(dispatchListeners)) {
        for (var i = 0; i < dispatchListeners.length; i++) {
          if (event.isPropagationStopped()) {
            break;
          }
          if (dispatchListeners[i](event, dispatchIDs[i])) {
            return dispatchIDs[i];
          }
        }
      } else if (dispatchListeners) {
        if (dispatchListeners(event, dispatchIDs)) {
          return dispatchIDs;
        }
      }
      return null;
    }
    function executeDispatchesInOrderStopAtTrue(event) {
      var ret = executeDispatchesInOrderStopAtTrueImpl(event);
      event._dispatchIDs = null;
      event._dispatchListeners = null;
      return ret;
    }
    function executeDirectDispatch(event) {
      if ("production" !== process.env.NODE_ENV) {
        validateEventDispatches(event);
      }
      var dispatchListener = event._dispatchListeners;
      var dispatchID = event._dispatchIDs;
      ("production" !== process.env.NODE_ENV ? invariant(!Array.isArray(dispatchListener), 'executeDirectDispatch(...): Invalid `event`.') : invariant(!Array.isArray(dispatchListener)));
      var res = dispatchListener ? dispatchListener(event, dispatchID) : null;
      event._dispatchListeners = null;
      event._dispatchIDs = null;
      return res;
    }
    function hasDispatches(event) {
      return !!event._dispatchListeners;
    }
    var EventPluginUtils = {
      isEndish: isEndish,
      isMoveish: isMoveish,
      isStartish: isStartish,
      executeDirectDispatch: executeDirectDispatch,
      executeDispatch: executeDispatch,
      executeDispatchesInOrder: executeDispatchesInOrder,
      executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
      hasDispatches: hasDispatches,
      injection: injection,
      useTouchEvents: false
    };
    module.exports = EventPluginUtils;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactElement", ["npm:react@0.12.2/lib/ReactContext", "npm:react@0.12.2/lib/ReactCurrentOwner", "npm:react@0.12.2/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactContext = require("npm:react@0.12.2/lib/ReactContext");
    var ReactCurrentOwner = require("npm:react@0.12.2/lib/ReactCurrentOwner");
    var warning = require("npm:react@0.12.2/lib/warning");
    var RESERVED_PROPS = {
      key: true,
      ref: true
    };
    function defineWarningProperty(object, key) {
      Object.defineProperty(object, key, {
        configurable: false,
        enumerable: true,
        get: function() {
          if (!this._store) {
            return null;
          }
          return this._store[key];
        },
        set: function(value) {
          ("production" !== process.env.NODE_ENV ? warning(false, 'Don\'t set the ' + key + ' property of the component. ' + 'Mutate the existing props object instead.') : null);
          this._store[key] = value;
        }
      });
    }
    var useMutationMembrane = false;
    function defineMutationMembrane(prototype) {
      try {
        var pseudoFrozenProperties = {props: true};
        for (var key in pseudoFrozenProperties) {
          defineWarningProperty(prototype, key);
        }
        useMutationMembrane = true;
      } catch (x) {}
    }
    var ReactElement = function(type, key, ref, owner, context, props) {
      this.type = type;
      this.key = key;
      this.ref = ref;
      this._owner = owner;
      this._context = context;
      if ("production" !== process.env.NODE_ENV) {
        this._store = {
          validated: false,
          props: props
        };
        if (useMutationMembrane) {
          Object.freeze(this);
          return ;
        }
      }
      this.props = props;
    };
    ReactElement.prototype = {_isReactElement: true};
    if ("production" !== process.env.NODE_ENV) {
      defineMutationMembrane(ReactElement.prototype);
    }
    ReactElement.createElement = function(type, config, children) {
      var propName;
      var props = {};
      var key = null;
      var ref = null;
      if (config != null) {
        ref = config.ref === undefined ? null : config.ref;
        if ("production" !== process.env.NODE_ENV) {
          ("production" !== process.env.NODE_ENV ? warning(config.key !== null, 'createElement(...): Encountered component with a `key` of null. In ' + 'a future version, this will be treated as equivalent to the string ' + '\'null\'; instead, provide an explicit key or use undefined.') : null);
        }
        key = config.key == null ? null : '' + config.key;
        for (propName in config) {
          if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            props[propName] = config[propName];
          }
        }
      }
      var childrenLength = arguments.length - 2;
      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);
        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }
        props.children = childArray;
      }
      if (type && type.defaultProps) {
        var defaultProps = type.defaultProps;
        for (propName in defaultProps) {
          if (typeof props[propName] === 'undefined') {
            props[propName] = defaultProps[propName];
          }
        }
      }
      return new ReactElement(type, key, ref, ReactCurrentOwner.current, ReactContext.current, props);
    };
    ReactElement.createFactory = function(type) {
      var factory = ReactElement.createElement.bind(null, type);
      factory.type = type;
      return factory;
    };
    ReactElement.cloneAndReplaceProps = function(oldElement, newProps) {
      var newElement = new ReactElement(oldElement.type, oldElement.key, oldElement.ref, oldElement._owner, oldElement._context, newProps);
      if ("production" !== process.env.NODE_ENV) {
        newElement._store.validated = oldElement._store.validated;
      }
      return newElement;
    };
    ReactElement.isValidElement = function(object) {
      var isElement = !!(object && object._isReactElement);
      return isElement;
    };
    module.exports = ReactElement;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactComponent", ["npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/ReactOwner", "npm:react@0.12.2/lib/ReactUpdates", "npm:react@0.12.2/lib/Object.assign", "npm:react@0.12.2/lib/invariant", "npm:react@0.12.2/lib/keyMirror", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
    var ReactOwner = require("npm:react@0.12.2/lib/ReactOwner");
    var ReactUpdates = require("npm:react@0.12.2/lib/ReactUpdates");
    var assign = require("npm:react@0.12.2/lib/Object.assign");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var keyMirror = require("npm:react@0.12.2/lib/keyMirror");
    var ComponentLifeCycle = keyMirror({
      MOUNTED: null,
      UNMOUNTED: null
    });
    var injected = false;
    var unmountIDFromEnvironment = null;
    var mountImageIntoNode = null;
    var ReactComponent = {
      injection: {injectEnvironment: function(ReactComponentEnvironment) {
          ("production" !== process.env.NODE_ENV ? invariant(!injected, 'ReactComponent: injectEnvironment() can only be called once.') : invariant(!injected));
          mountImageIntoNode = ReactComponentEnvironment.mountImageIntoNode;
          unmountIDFromEnvironment = ReactComponentEnvironment.unmountIDFromEnvironment;
          ReactComponent.BackendIDOperations = ReactComponentEnvironment.BackendIDOperations;
          injected = true;
        }},
      LifeCycle: ComponentLifeCycle,
      BackendIDOperations: null,
      Mixin: {
        isMounted: function() {
          return this._lifeCycleState === ComponentLifeCycle.MOUNTED;
        },
        setProps: function(partialProps, callback) {
          var element = this._pendingElement || this._currentElement;
          this.replaceProps(assign({}, element.props, partialProps), callback);
        },
        replaceProps: function(props, callback) {
          ("production" !== process.env.NODE_ENV ? invariant(this.isMounted(), 'replaceProps(...): Can only update a mounted component.') : invariant(this.isMounted()));
          ("production" !== process.env.NODE_ENV ? invariant(this._mountDepth === 0, 'replaceProps(...): You called `setProps` or `replaceProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(this._mountDepth === 0));
          this._pendingElement = ReactElement.cloneAndReplaceProps(this._pendingElement || this._currentElement, props);
          ReactUpdates.enqueueUpdate(this, callback);
        },
        _setPropsInternal: function(partialProps, callback) {
          var element = this._pendingElement || this._currentElement;
          this._pendingElement = ReactElement.cloneAndReplaceProps(element, assign({}, element.props, partialProps));
          ReactUpdates.enqueueUpdate(this, callback);
        },
        construct: function(element) {
          this.props = element.props;
          this._owner = element._owner;
          this._lifeCycleState = ComponentLifeCycle.UNMOUNTED;
          this._pendingCallbacks = null;
          this._currentElement = element;
          this._pendingElement = null;
        },
        mountComponent: function(rootID, transaction, mountDepth) {
          ("production" !== process.env.NODE_ENV ? invariant(!this.isMounted(), 'mountComponent(%s, ...): Can only mount an unmounted component. ' + 'Make sure to avoid storing components between renders or reusing a ' + 'single component instance in multiple places.', rootID) : invariant(!this.isMounted()));
          var ref = this._currentElement.ref;
          if (ref != null) {
            var owner = this._currentElement._owner;
            ReactOwner.addComponentAsRefTo(this, ref, owner);
          }
          this._rootNodeID = rootID;
          this._lifeCycleState = ComponentLifeCycle.MOUNTED;
          this._mountDepth = mountDepth;
        },
        unmountComponent: function() {
          ("production" !== process.env.NODE_ENV ? invariant(this.isMounted(), 'unmountComponent(): Can only unmount a mounted component.') : invariant(this.isMounted()));
          var ref = this._currentElement.ref;
          if (ref != null) {
            ReactOwner.removeComponentAsRefFrom(this, ref, this._owner);
          }
          unmountIDFromEnvironment(this._rootNodeID);
          this._rootNodeID = null;
          this._lifeCycleState = ComponentLifeCycle.UNMOUNTED;
        },
        receiveComponent: function(nextElement, transaction) {
          ("production" !== process.env.NODE_ENV ? invariant(this.isMounted(), 'receiveComponent(...): Can only update a mounted component.') : invariant(this.isMounted()));
          this._pendingElement = nextElement;
          this.performUpdateIfNecessary(transaction);
        },
        performUpdateIfNecessary: function(transaction) {
          if (this._pendingElement == null) {
            return ;
          }
          var prevElement = this._currentElement;
          var nextElement = this._pendingElement;
          this._currentElement = nextElement;
          this.props = nextElement.props;
          this._owner = nextElement._owner;
          this._pendingElement = null;
          this.updateComponent(transaction, prevElement);
        },
        updateComponent: function(transaction, prevElement) {
          var nextElement = this._currentElement;
          if (nextElement._owner !== prevElement._owner || nextElement.ref !== prevElement.ref) {
            if (prevElement.ref != null) {
              ReactOwner.removeComponentAsRefFrom(this, prevElement.ref, prevElement._owner);
            }
            if (nextElement.ref != null) {
              ReactOwner.addComponentAsRefTo(this, nextElement.ref, nextElement._owner);
            }
          }
        },
        mountComponentIntoNode: function(rootID, container, shouldReuseMarkup) {
          var transaction = ReactUpdates.ReactReconcileTransaction.getPooled();
          transaction.perform(this._mountComponentIntoNode, this, rootID, container, transaction, shouldReuseMarkup);
          ReactUpdates.ReactReconcileTransaction.release(transaction);
        },
        _mountComponentIntoNode: function(rootID, container, transaction, shouldReuseMarkup) {
          var markup = this.mountComponent(rootID, transaction, 0);
          mountImageIntoNode(markup, container, shouldReuseMarkup);
        },
        isOwnedBy: function(owner) {
          return this._owner === owner;
        },
        getSiblingByRef: function(ref) {
          var owner = this._owner;
          if (!owner || !owner.refs) {
            return null;
          }
          return owner.refs[ref];
        }
      }
    };
    module.exports = ReactComponent;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactCompositeComponent", ["npm:react@0.12.2/lib/ReactComponent", "npm:react@0.12.2/lib/ReactContext", "npm:react@0.12.2/lib/ReactCurrentOwner", "npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/ReactElementValidator", "npm:react@0.12.2/lib/ReactEmptyComponent", "npm:react@0.12.2/lib/ReactErrorUtils", "npm:react@0.12.2/lib/ReactLegacyElement", "npm:react@0.12.2/lib/ReactOwner", "npm:react@0.12.2/lib/ReactPerf", "npm:react@0.12.2/lib/ReactPropTransferer", "npm:react@0.12.2/lib/ReactPropTypeLocations", "npm:react@0.12.2/lib/ReactPropTypeLocationNames", "npm:react@0.12.2/lib/ReactUpdates", "npm:react@0.12.2/lib/Object.assign", "npm:react@0.12.2/lib/instantiateReactComponent", "npm:react@0.12.2/lib/invariant", "npm:react@0.12.2/lib/keyMirror", "npm:react@0.12.2/lib/keyOf", "npm:react@0.12.2/lib/monitorCodeUse", "npm:react@0.12.2/lib/mapObject", "npm:react@0.12.2/lib/shouldUpdateReactComponent", "npm:react@0.12.2/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactComponent = require("npm:react@0.12.2/lib/ReactComponent");
    var ReactContext = require("npm:react@0.12.2/lib/ReactContext");
    var ReactCurrentOwner = require("npm:react@0.12.2/lib/ReactCurrentOwner");
    var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
    var ReactElementValidator = require("npm:react@0.12.2/lib/ReactElementValidator");
    var ReactEmptyComponent = require("npm:react@0.12.2/lib/ReactEmptyComponent");
    var ReactErrorUtils = require("npm:react@0.12.2/lib/ReactErrorUtils");
    var ReactLegacyElement = require("npm:react@0.12.2/lib/ReactLegacyElement");
    var ReactOwner = require("npm:react@0.12.2/lib/ReactOwner");
    var ReactPerf = require("npm:react@0.12.2/lib/ReactPerf");
    var ReactPropTransferer = require("npm:react@0.12.2/lib/ReactPropTransferer");
    var ReactPropTypeLocations = require("npm:react@0.12.2/lib/ReactPropTypeLocations");
    var ReactPropTypeLocationNames = require("npm:react@0.12.2/lib/ReactPropTypeLocationNames");
    var ReactUpdates = require("npm:react@0.12.2/lib/ReactUpdates");
    var assign = require("npm:react@0.12.2/lib/Object.assign");
    var instantiateReactComponent = require("npm:react@0.12.2/lib/instantiateReactComponent");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var keyMirror = require("npm:react@0.12.2/lib/keyMirror");
    var keyOf = require("npm:react@0.12.2/lib/keyOf");
    var monitorCodeUse = require("npm:react@0.12.2/lib/monitorCodeUse");
    var mapObject = require("npm:react@0.12.2/lib/mapObject");
    var shouldUpdateReactComponent = require("npm:react@0.12.2/lib/shouldUpdateReactComponent");
    var warning = require("npm:react@0.12.2/lib/warning");
    var MIXINS_KEY = keyOf({mixins: null});
    var SpecPolicy = keyMirror({
      DEFINE_ONCE: null,
      DEFINE_MANY: null,
      OVERRIDE_BASE: null,
      DEFINE_MANY_MERGED: null
    });
    var injectedMixins = [];
    var ReactCompositeComponentInterface = {
      mixins: SpecPolicy.DEFINE_MANY,
      statics: SpecPolicy.DEFINE_MANY,
      propTypes: SpecPolicy.DEFINE_MANY,
      contextTypes: SpecPolicy.DEFINE_MANY,
      childContextTypes: SpecPolicy.DEFINE_MANY,
      getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,
      getInitialState: SpecPolicy.DEFINE_MANY_MERGED,
      getChildContext: SpecPolicy.DEFINE_MANY_MERGED,
      render: SpecPolicy.DEFINE_ONCE,
      componentWillMount: SpecPolicy.DEFINE_MANY,
      componentDidMount: SpecPolicy.DEFINE_MANY,
      componentWillReceiveProps: SpecPolicy.DEFINE_MANY,
      shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,
      componentWillUpdate: SpecPolicy.DEFINE_MANY,
      componentDidUpdate: SpecPolicy.DEFINE_MANY,
      componentWillUnmount: SpecPolicy.DEFINE_MANY,
      updateComponent: SpecPolicy.OVERRIDE_BASE
    };
    var RESERVED_SPEC_KEYS = {
      displayName: function(Constructor, displayName) {
        Constructor.displayName = displayName;
      },
      mixins: function(Constructor, mixins) {
        if (mixins) {
          for (var i = 0; i < mixins.length; i++) {
            mixSpecIntoComponent(Constructor, mixins[i]);
          }
        }
      },
      childContextTypes: function(Constructor, childContextTypes) {
        validateTypeDef(Constructor, childContextTypes, ReactPropTypeLocations.childContext);
        Constructor.childContextTypes = assign({}, Constructor.childContextTypes, childContextTypes);
      },
      contextTypes: function(Constructor, contextTypes) {
        validateTypeDef(Constructor, contextTypes, ReactPropTypeLocations.context);
        Constructor.contextTypes = assign({}, Constructor.contextTypes, contextTypes);
      },
      getDefaultProps: function(Constructor, getDefaultProps) {
        if (Constructor.getDefaultProps) {
          Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
        } else {
          Constructor.getDefaultProps = getDefaultProps;
        }
      },
      propTypes: function(Constructor, propTypes) {
        validateTypeDef(Constructor, propTypes, ReactPropTypeLocations.prop);
        Constructor.propTypes = assign({}, Constructor.propTypes, propTypes);
      },
      statics: function(Constructor, statics) {
        mixStaticSpecIntoComponent(Constructor, statics);
      }
    };
    function getDeclarationErrorAddendum(component) {
      var owner = component._owner || null;
      if (owner && owner.constructor && owner.constructor.displayName) {
        return ' Check the render method of `' + owner.constructor.displayName + '`.';
      }
      return '';
    }
    function validateTypeDef(Constructor, typeDef, location) {
      for (var propName in typeDef) {
        if (typeDef.hasOwnProperty(propName)) {
          ("production" !== process.env.NODE_ENV ? invariant(typeof typeDef[propName] == 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactCompositeComponent', ReactPropTypeLocationNames[location], propName) : invariant(typeof typeDef[propName] == 'function'));
        }
      }
    }
    function validateMethodOverride(proto, name) {
      var specPolicy = ReactCompositeComponentInterface.hasOwnProperty(name) ? ReactCompositeComponentInterface[name] : null;
      if (ReactCompositeComponentMixin.hasOwnProperty(name)) {
        ("production" !== process.env.NODE_ENV ? invariant(specPolicy === SpecPolicy.OVERRIDE_BASE, 'ReactCompositeComponentInterface: You are attempting to override ' + '`%s` from your class specification. Ensure that your method names ' + 'do not overlap with React methods.', name) : invariant(specPolicy === SpecPolicy.OVERRIDE_BASE));
      }
      if (proto.hasOwnProperty(name)) {
        ("production" !== process.env.NODE_ENV ? invariant(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED, 'ReactCompositeComponentInterface: You are attempting to define ' + '`%s` on your component more than once. This conflict may be due ' + 'to a mixin.', name) : invariant(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED));
      }
    }
    function validateLifeCycleOnReplaceState(instance) {
      var compositeLifeCycleState = instance._compositeLifeCycleState;
      ("production" !== process.env.NODE_ENV ? invariant(instance.isMounted() || compositeLifeCycleState === CompositeLifeCycle.MOUNTING, 'replaceState(...): Can only update a mounted or mounting component.') : invariant(instance.isMounted() || compositeLifeCycleState === CompositeLifeCycle.MOUNTING));
      ("production" !== process.env.NODE_ENV ? invariant(ReactCurrentOwner.current == null, 'replaceState(...): Cannot update during an existing state transition ' + '(such as within `render`). Render methods should be a pure function ' + 'of props and state.') : invariant(ReactCurrentOwner.current == null));
      ("production" !== process.env.NODE_ENV ? invariant(compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING, 'replaceState(...): Cannot update while unmounting component. This ' + 'usually means you called setState() on an unmounted component.') : invariant(compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING));
    }
    function mixSpecIntoComponent(Constructor, spec) {
      if (!spec) {
        return ;
      }
      ("production" !== process.env.NODE_ENV ? invariant(!ReactLegacyElement.isValidFactory(spec), 'ReactCompositeComponent: You\'re attempting to ' + 'use a component class as a mixin. Instead, just use a regular object.') : invariant(!ReactLegacyElement.isValidFactory(spec)));
      ("production" !== process.env.NODE_ENV ? invariant(!ReactElement.isValidElement(spec), 'ReactCompositeComponent: You\'re attempting to ' + 'use a component as a mixin. Instead, just use a regular object.') : invariant(!ReactElement.isValidElement(spec)));
      var proto = Constructor.prototype;
      if (spec.hasOwnProperty(MIXINS_KEY)) {
        RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
      }
      for (var name in spec) {
        if (!spec.hasOwnProperty(name)) {
          continue;
        }
        if (name === MIXINS_KEY) {
          continue;
        }
        var property = spec[name];
        validateMethodOverride(proto, name);
        if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
          RESERVED_SPEC_KEYS[name](Constructor, property);
        } else {
          var isCompositeComponentMethod = ReactCompositeComponentInterface.hasOwnProperty(name);
          var isAlreadyDefined = proto.hasOwnProperty(name);
          var markedDontBind = property && property.__reactDontBind;
          var isFunction = typeof property === 'function';
          var shouldAutoBind = isFunction && !isCompositeComponentMethod && !isAlreadyDefined && !markedDontBind;
          if (shouldAutoBind) {
            if (!proto.__reactAutoBindMap) {
              proto.__reactAutoBindMap = {};
            }
            proto.__reactAutoBindMap[name] = property;
            proto[name] = property;
          } else {
            if (isAlreadyDefined) {
              var specPolicy = ReactCompositeComponentInterface[name];
              ("production" !== process.env.NODE_ENV ? invariant(isCompositeComponentMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY), 'ReactCompositeComponent: Unexpected spec policy %s for key %s ' + 'when mixing in component specs.', specPolicy, name) : invariant(isCompositeComponentMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)));
              if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
                proto[name] = createMergedResultFunction(proto[name], property);
              } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
                proto[name] = createChainedFunction(proto[name], property);
              }
            } else {
              proto[name] = property;
              if ("production" !== process.env.NODE_ENV) {
                if (typeof property === 'function' && spec.displayName) {
                  proto[name].displayName = spec.displayName + '_' + name;
                }
              }
            }
          }
        }
      }
    }
    function mixStaticSpecIntoComponent(Constructor, statics) {
      if (!statics) {
        return ;
      }
      for (var name in statics) {
        var property = statics[name];
        if (!statics.hasOwnProperty(name)) {
          continue;
        }
        var isReserved = name in RESERVED_SPEC_KEYS;
        ("production" !== process.env.NODE_ENV ? invariant(!isReserved, 'ReactCompositeComponent: You are attempting to define a reserved ' + 'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' + 'as an instance property instead; it will still be accessible on the ' + 'constructor.', name) : invariant(!isReserved));
        var isInherited = name in Constructor;
        ("production" !== process.env.NODE_ENV ? invariant(!isInherited, 'ReactCompositeComponent: You are attempting to define ' + '`%s` on your component more than once. This conflict may be ' + 'due to a mixin.', name) : invariant(!isInherited));
        Constructor[name] = property;
      }
    }
    function mergeObjectsWithNoDuplicateKeys(one, two) {
      ("production" !== process.env.NODE_ENV ? invariant(one && two && typeof one === 'object' && typeof two === 'object', 'mergeObjectsWithNoDuplicateKeys(): Cannot merge non-objects') : invariant(one && two && typeof one === 'object' && typeof two === 'object'));
      mapObject(two, function(value, key) {
        ("production" !== process.env.NODE_ENV ? invariant(one[key] === undefined, 'mergeObjectsWithNoDuplicateKeys(): ' + 'Tried to merge two objects with the same key: `%s`. This conflict ' + 'may be due to a mixin; in particular, this may be caused by two ' + 'getInitialState() or getDefaultProps() methods returning objects ' + 'with clashing keys.', key) : invariant(one[key] === undefined));
        one[key] = value;
      });
      return one;
    }
    function createMergedResultFunction(one, two) {
      return function mergedResult() {
        var a = one.apply(this, arguments);
        var b = two.apply(this, arguments);
        if (a == null) {
          return b;
        } else if (b == null) {
          return a;
        }
        return mergeObjectsWithNoDuplicateKeys(a, b);
      };
    }
    function createChainedFunction(one, two) {
      return function chainedFunction() {
        one.apply(this, arguments);
        two.apply(this, arguments);
      };
    }
    var CompositeLifeCycle = keyMirror({
      MOUNTING: null,
      UNMOUNTING: null,
      RECEIVING_PROPS: null
    });
    var ReactCompositeComponentMixin = {
      construct: function(element) {
        ReactComponent.Mixin.construct.apply(this, arguments);
        ReactOwner.Mixin.construct.apply(this, arguments);
        this.state = null;
        this._pendingState = null;
        this.context = null;
        this._compositeLifeCycleState = null;
      },
      isMounted: function() {
        return ReactComponent.Mixin.isMounted.call(this) && this._compositeLifeCycleState !== CompositeLifeCycle.MOUNTING;
      },
      mountComponent: ReactPerf.measure('ReactCompositeComponent', 'mountComponent', function(rootID, transaction, mountDepth) {
        ReactComponent.Mixin.mountComponent.call(this, rootID, transaction, mountDepth);
        this._compositeLifeCycleState = CompositeLifeCycle.MOUNTING;
        if (this.__reactAutoBindMap) {
          this._bindAutoBindMethods();
        }
        this.context = this._processContext(this._currentElement._context);
        this.props = this._processProps(this.props);
        this.state = this.getInitialState ? this.getInitialState() : null;
        ("production" !== process.env.NODE_ENV ? invariant(typeof this.state === 'object' && !Array.isArray(this.state), '%s.getInitialState(): must return an object or null', this.constructor.displayName || 'ReactCompositeComponent') : invariant(typeof this.state === 'object' && !Array.isArray(this.state)));
        this._pendingState = null;
        this._pendingForceUpdate = false;
        if (this.componentWillMount) {
          this.componentWillMount();
          if (this._pendingState) {
            this.state = this._pendingState;
            this._pendingState = null;
          }
        }
        this._renderedComponent = instantiateReactComponent(this._renderValidatedComponent(), this._currentElement.type);
        this._compositeLifeCycleState = null;
        var markup = this._renderedComponent.mountComponent(rootID, transaction, mountDepth + 1);
        if (this.componentDidMount) {
          transaction.getReactMountReady().enqueue(this.componentDidMount, this);
        }
        return markup;
      }),
      unmountComponent: function() {
        this._compositeLifeCycleState = CompositeLifeCycle.UNMOUNTING;
        if (this.componentWillUnmount) {
          this.componentWillUnmount();
        }
        this._compositeLifeCycleState = null;
        this._renderedComponent.unmountComponent();
        this._renderedComponent = null;
        ReactComponent.Mixin.unmountComponent.call(this);
      },
      setState: function(partialState, callback) {
        ("production" !== process.env.NODE_ENV ? invariant(typeof partialState === 'object' || partialState == null, 'setState(...): takes an object of state variables to update.') : invariant(typeof partialState === 'object' || partialState == null));
        if ("production" !== process.env.NODE_ENV) {
          ("production" !== process.env.NODE_ENV ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : null);
        }
        this.replaceState(assign({}, this._pendingState || this.state, partialState), callback);
      },
      replaceState: function(completeState, callback) {
        validateLifeCycleOnReplaceState(this);
        this._pendingState = completeState;
        if (this._compositeLifeCycleState !== CompositeLifeCycle.MOUNTING) {
          ReactUpdates.enqueueUpdate(this, callback);
        }
      },
      _processContext: function(context) {
        var maskedContext = null;
        var contextTypes = this.constructor.contextTypes;
        if (contextTypes) {
          maskedContext = {};
          for (var contextName in contextTypes) {
            maskedContext[contextName] = context[contextName];
          }
          if ("production" !== process.env.NODE_ENV) {
            this._checkPropTypes(contextTypes, maskedContext, ReactPropTypeLocations.context);
          }
        }
        return maskedContext;
      },
      _processChildContext: function(currentContext) {
        var childContext = this.getChildContext && this.getChildContext();
        var displayName = this.constructor.displayName || 'ReactCompositeComponent';
        if (childContext) {
          ("production" !== process.env.NODE_ENV ? invariant(typeof this.constructor.childContextTypes === 'object', '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', displayName) : invariant(typeof this.constructor.childContextTypes === 'object'));
          if ("production" !== process.env.NODE_ENV) {
            this._checkPropTypes(this.constructor.childContextTypes, childContext, ReactPropTypeLocations.childContext);
          }
          for (var name in childContext) {
            ("production" !== process.env.NODE_ENV ? invariant(name in this.constructor.childContextTypes, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', displayName, name) : invariant(name in this.constructor.childContextTypes));
          }
          return assign({}, currentContext, childContext);
        }
        return currentContext;
      },
      _processProps: function(newProps) {
        if ("production" !== process.env.NODE_ENV) {
          var propTypes = this.constructor.propTypes;
          if (propTypes) {
            this._checkPropTypes(propTypes, newProps, ReactPropTypeLocations.prop);
          }
        }
        return newProps;
      },
      _checkPropTypes: function(propTypes, props, location) {
        var componentName = this.constructor.displayName;
        for (var propName in propTypes) {
          if (propTypes.hasOwnProperty(propName)) {
            var error = propTypes[propName](props, propName, componentName, location);
            if (error instanceof Error) {
              var addendum = getDeclarationErrorAddendum(this);
              ("production" !== process.env.NODE_ENV ? warning(false, error.message + addendum) : null);
            }
          }
        }
      },
      performUpdateIfNecessary: function(transaction) {
        var compositeLifeCycleState = this._compositeLifeCycleState;
        if (compositeLifeCycleState === CompositeLifeCycle.MOUNTING || compositeLifeCycleState === CompositeLifeCycle.RECEIVING_PROPS) {
          return ;
        }
        if (this._pendingElement == null && this._pendingState == null && !this._pendingForceUpdate) {
          return ;
        }
        var nextContext = this.context;
        var nextProps = this.props;
        var nextElement = this._currentElement;
        if (this._pendingElement != null) {
          nextElement = this._pendingElement;
          nextContext = this._processContext(nextElement._context);
          nextProps = this._processProps(nextElement.props);
          this._pendingElement = null;
          this._compositeLifeCycleState = CompositeLifeCycle.RECEIVING_PROPS;
          if (this.componentWillReceiveProps) {
            this.componentWillReceiveProps(nextProps, nextContext);
          }
        }
        this._compositeLifeCycleState = null;
        var nextState = this._pendingState || this.state;
        this._pendingState = null;
        var shouldUpdate = this._pendingForceUpdate || !this.shouldComponentUpdate || this.shouldComponentUpdate(nextProps, nextState, nextContext);
        if ("production" !== process.env.NODE_ENV) {
          if (typeof shouldUpdate === "undefined") {
            console.warn((this.constructor.displayName || 'ReactCompositeComponent') + '.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.');
          }
        }
        if (shouldUpdate) {
          this._pendingForceUpdate = false;
          this._performComponentUpdate(nextElement, nextProps, nextState, nextContext, transaction);
        } else {
          this._currentElement = nextElement;
          this.props = nextProps;
          this.state = nextState;
          this.context = nextContext;
          this._owner = nextElement._owner;
        }
      },
      _performComponentUpdate: function(nextElement, nextProps, nextState, nextContext, transaction) {
        var prevElement = this._currentElement;
        var prevProps = this.props;
        var prevState = this.state;
        var prevContext = this.context;
        if (this.componentWillUpdate) {
          this.componentWillUpdate(nextProps, nextState, nextContext);
        }
        this._currentElement = nextElement;
        this.props = nextProps;
        this.state = nextState;
        this.context = nextContext;
        this._owner = nextElement._owner;
        this.updateComponent(transaction, prevElement);
        if (this.componentDidUpdate) {
          transaction.getReactMountReady().enqueue(this.componentDidUpdate.bind(this, prevProps, prevState, prevContext), this);
        }
      },
      receiveComponent: function(nextElement, transaction) {
        if (nextElement === this._currentElement && nextElement._owner != null) {
          return ;
        }
        ReactComponent.Mixin.receiveComponent.call(this, nextElement, transaction);
      },
      updateComponent: ReactPerf.measure('ReactCompositeComponent', 'updateComponent', function(transaction, prevParentElement) {
        ReactComponent.Mixin.updateComponent.call(this, transaction, prevParentElement);
        var prevComponentInstance = this._renderedComponent;
        var prevElement = prevComponentInstance._currentElement;
        var nextElement = this._renderValidatedComponent();
        if (shouldUpdateReactComponent(prevElement, nextElement)) {
          prevComponentInstance.receiveComponent(nextElement, transaction);
        } else {
          var thisID = this._rootNodeID;
          var prevComponentID = prevComponentInstance._rootNodeID;
          prevComponentInstance.unmountComponent();
          this._renderedComponent = instantiateReactComponent(nextElement, this._currentElement.type);
          var nextMarkup = this._renderedComponent.mountComponent(thisID, transaction, this._mountDepth + 1);
          ReactComponent.BackendIDOperations.dangerouslyReplaceNodeWithMarkupByID(prevComponentID, nextMarkup);
        }
      }),
      forceUpdate: function(callback) {
        var compositeLifeCycleState = this._compositeLifeCycleState;
        ("production" !== process.env.NODE_ENV ? invariant(this.isMounted() || compositeLifeCycleState === CompositeLifeCycle.MOUNTING, 'forceUpdate(...): Can only force an update on mounted or mounting ' + 'components.') : invariant(this.isMounted() || compositeLifeCycleState === CompositeLifeCycle.MOUNTING));
        ("production" !== process.env.NODE_ENV ? invariant(compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING && ReactCurrentOwner.current == null, 'forceUpdate(...): Cannot force an update while unmounting component ' + 'or within a `render` function.') : invariant(compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING && ReactCurrentOwner.current == null));
        this._pendingForceUpdate = true;
        ReactUpdates.enqueueUpdate(this, callback);
      },
      _renderValidatedComponent: ReactPerf.measure('ReactCompositeComponent', '_renderValidatedComponent', function() {
        var renderedComponent;
        var previousContext = ReactContext.current;
        ReactContext.current = this._processChildContext(this._currentElement._context);
        ReactCurrentOwner.current = this;
        try {
          renderedComponent = this.render();
          if (renderedComponent === null || renderedComponent === false) {
            renderedComponent = ReactEmptyComponent.getEmptyComponent();
            ReactEmptyComponent.registerNullComponentID(this._rootNodeID);
          } else {
            ReactEmptyComponent.deregisterNullComponentID(this._rootNodeID);
          }
        } finally {
          ReactContext.current = previousContext;
          ReactCurrentOwner.current = null;
        }
        ("production" !== process.env.NODE_ENV ? invariant(ReactElement.isValidElement(renderedComponent), '%s.render(): A valid ReactComponent must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', this.constructor.displayName || 'ReactCompositeComponent') : invariant(ReactElement.isValidElement(renderedComponent)));
        return renderedComponent;
      }),
      _bindAutoBindMethods: function() {
        for (var autoBindKey in this.__reactAutoBindMap) {
          if (!this.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {
            continue;
          }
          var method = this.__reactAutoBindMap[autoBindKey];
          this[autoBindKey] = this._bindAutoBindMethod(ReactErrorUtils.guard(method, this.constructor.displayName + '.' + autoBindKey));
        }
      },
      _bindAutoBindMethod: function(method) {
        var component = this;
        var boundMethod = method.bind(component);
        if ("production" !== process.env.NODE_ENV) {
          boundMethod.__reactBoundContext = component;
          boundMethod.__reactBoundMethod = method;
          boundMethod.__reactBoundArguments = null;
          var componentName = component.constructor.displayName;
          var _bind = boundMethod.bind;
          boundMethod.bind = function(newThis) {
            for (var args = [],
                $__0 = 1,
                $__1 = arguments.length; $__0 < $__1; $__0++)
              args.push(arguments[$__0]);
            if (newThis !== component && newThis !== null) {
              monitorCodeUse('react_bind_warning', {component: componentName});
              console.warn('bind(): React component methods may only be bound to the ' + 'component instance. See ' + componentName);
            } else if (!args.length) {
              monitorCodeUse('react_bind_warning', {component: componentName});
              console.warn('bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See ' + componentName);
              return boundMethod;
            }
            var reboundMethod = _bind.apply(boundMethod, arguments);
            reboundMethod.__reactBoundContext = component;
            reboundMethod.__reactBoundMethod = method;
            reboundMethod.__reactBoundArguments = args;
            return reboundMethod;
          };
        }
        return boundMethod;
      }
    };
    var ReactCompositeComponentBase = function() {};
    assign(ReactCompositeComponentBase.prototype, ReactComponent.Mixin, ReactOwner.Mixin, ReactPropTransferer.Mixin, ReactCompositeComponentMixin);
    var ReactCompositeComponent = {
      LifeCycle: CompositeLifeCycle,
      Base: ReactCompositeComponentBase,
      createClass: function(spec) {
        var Constructor = function(props) {};
        Constructor.prototype = new ReactCompositeComponentBase();
        Constructor.prototype.constructor = Constructor;
        injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
        mixSpecIntoComponent(Constructor, spec);
        if (Constructor.getDefaultProps) {
          Constructor.defaultProps = Constructor.getDefaultProps();
        }
        ("production" !== process.env.NODE_ENV ? invariant(Constructor.prototype.render, 'createClass(...): Class specification must implement a `render` method.') : invariant(Constructor.prototype.render));
        if ("production" !== process.env.NODE_ENV) {
          if (Constructor.prototype.componentShouldUpdate) {
            monitorCodeUse('react_component_should_update_warning', {component: spec.displayName});
            console.warn((spec.displayName || 'A component') + ' has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.');
          }
        }
        for (var methodName in ReactCompositeComponentInterface) {
          if (!Constructor.prototype[methodName]) {
            Constructor.prototype[methodName] = null;
          }
        }
        if ("production" !== process.env.NODE_ENV) {
          return ReactLegacyElement.wrapFactory(ReactElementValidator.createFactory(Constructor));
        }
        return ReactLegacyElement.wrapFactory(ReactElement.createFactory(Constructor));
      },
      injection: {injectMixin: function(mixin) {
          injectedMixins.push(mixin);
        }}
    };
    module.exports = ReactCompositeComponent;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/CSSPropertyOperations", ["npm:react@0.12.2/lib/CSSProperty", "npm:react@0.12.2/lib/ExecutionEnvironment", "npm:react@0.12.2/lib/camelizeStyleName", "npm:react@0.12.2/lib/dangerousStyleValue", "npm:react@0.12.2/lib/hyphenateStyleName", "npm:react@0.12.2/lib/memoizeStringOnly", "npm:react@0.12.2/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var CSSProperty = require("npm:react@0.12.2/lib/CSSProperty");
    var ExecutionEnvironment = require("npm:react@0.12.2/lib/ExecutionEnvironment");
    var camelizeStyleName = require("npm:react@0.12.2/lib/camelizeStyleName");
    var dangerousStyleValue = require("npm:react@0.12.2/lib/dangerousStyleValue");
    var hyphenateStyleName = require("npm:react@0.12.2/lib/hyphenateStyleName");
    var memoizeStringOnly = require("npm:react@0.12.2/lib/memoizeStringOnly");
    var warning = require("npm:react@0.12.2/lib/warning");
    var processStyleName = memoizeStringOnly(function(styleName) {
      return hyphenateStyleName(styleName);
    });
    var styleFloatAccessor = 'cssFloat';
    if (ExecutionEnvironment.canUseDOM) {
      if (document.documentElement.style.cssFloat === undefined) {
        styleFloatAccessor = 'styleFloat';
      }
    }
    if ("production" !== process.env.NODE_ENV) {
      var warnedStyleNames = {};
      var warnHyphenatedStyleName = function(name) {
        if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
          return ;
        }
        warnedStyleNames[name] = true;
        ("production" !== process.env.NODE_ENV ? warning(false, 'Unsupported style property ' + name + '. Did you mean ' + camelizeStyleName(name) + '?') : null);
      };
    }
    var CSSPropertyOperations = {
      createMarkupForStyles: function(styles) {
        var serialized = '';
        for (var styleName in styles) {
          if (!styles.hasOwnProperty(styleName)) {
            continue;
          }
          if ("production" !== process.env.NODE_ENV) {
            if (styleName.indexOf('-') > -1) {
              warnHyphenatedStyleName(styleName);
            }
          }
          var styleValue = styles[styleName];
          if (styleValue != null) {
            serialized += processStyleName(styleName) + ':';
            serialized += dangerousStyleValue(styleName, styleValue) + ';';
          }
        }
        return serialized || null;
      },
      setValueForStyles: function(node, styles) {
        var style = node.style;
        for (var styleName in styles) {
          if (!styles.hasOwnProperty(styleName)) {
            continue;
          }
          if ("production" !== process.env.NODE_ENV) {
            if (styleName.indexOf('-') > -1) {
              warnHyphenatedStyleName(styleName);
            }
          }
          var styleValue = dangerousStyleValue(styleName, styles[styleName]);
          if (styleName === 'float') {
            styleName = styleFloatAccessor;
          }
          if (styleValue) {
            style[styleName] = styleValue;
          } else {
            var expansion = CSSProperty.shorthandPropertyExpansions[styleName];
            if (expansion) {
              for (var individualStyleName in expansion) {
                style[individualStyleName] = '';
              }
            } else {
              style[styleName] = '';
            }
          }
        }
      }
    };
    module.exports = CSSPropertyOperations;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactBrowserEventEmitter", ["npm:react@0.12.2/lib/EventConstants", "npm:react@0.12.2/lib/EventPluginHub", "npm:react@0.12.2/lib/EventPluginRegistry", "npm:react@0.12.2/lib/ReactEventEmitterMixin", "npm:react@0.12.2/lib/ViewportMetrics", "npm:react@0.12.2/lib/Object.assign", "npm:react@0.12.2/lib/isEventSupported", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var EventConstants = require("npm:react@0.12.2/lib/EventConstants");
    var EventPluginHub = require("npm:react@0.12.2/lib/EventPluginHub");
    var EventPluginRegistry = require("npm:react@0.12.2/lib/EventPluginRegistry");
    var ReactEventEmitterMixin = require("npm:react@0.12.2/lib/ReactEventEmitterMixin");
    var ViewportMetrics = require("npm:react@0.12.2/lib/ViewportMetrics");
    var assign = require("npm:react@0.12.2/lib/Object.assign");
    var isEventSupported = require("npm:react@0.12.2/lib/isEventSupported");
    var alreadyListeningTo = {};
    var isMonitoringScrollValue = false;
    var reactTopListenersCounter = 0;
    var topEventMapping = {
      topBlur: 'blur',
      topChange: 'change',
      topClick: 'click',
      topCompositionEnd: 'compositionend',
      topCompositionStart: 'compositionstart',
      topCompositionUpdate: 'compositionupdate',
      topContextMenu: 'contextmenu',
      topCopy: 'copy',
      topCut: 'cut',
      topDoubleClick: 'dblclick',
      topDrag: 'drag',
      topDragEnd: 'dragend',
      topDragEnter: 'dragenter',
      topDragExit: 'dragexit',
      topDragLeave: 'dragleave',
      topDragOver: 'dragover',
      topDragStart: 'dragstart',
      topDrop: 'drop',
      topFocus: 'focus',
      topInput: 'input',
      topKeyDown: 'keydown',
      topKeyPress: 'keypress',
      topKeyUp: 'keyup',
      topMouseDown: 'mousedown',
      topMouseMove: 'mousemove',
      topMouseOut: 'mouseout',
      topMouseOver: 'mouseover',
      topMouseUp: 'mouseup',
      topPaste: 'paste',
      topScroll: 'scroll',
      topSelectionChange: 'selectionchange',
      topTextInput: 'textInput',
      topTouchCancel: 'touchcancel',
      topTouchEnd: 'touchend',
      topTouchMove: 'touchmove',
      topTouchStart: 'touchstart',
      topWheel: 'wheel'
    };
    var topListenersIDKey = "_reactListenersID" + String(Math.random()).slice(2);
    function getListeningForDocument(mountAt) {
      if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
        mountAt[topListenersIDKey] = reactTopListenersCounter++;
        alreadyListeningTo[mountAt[topListenersIDKey]] = {};
      }
      return alreadyListeningTo[mountAt[topListenersIDKey]];
    }
    var ReactBrowserEventEmitter = assign({}, ReactEventEmitterMixin, {
      ReactEventListener: null,
      injection: {injectReactEventListener: function(ReactEventListener) {
          ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
          ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
        }},
      setEnabled: function(enabled) {
        if (ReactBrowserEventEmitter.ReactEventListener) {
          ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
        }
      },
      isEnabled: function() {
        return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
      },
      listenTo: function(registrationName, contentDocumentHandle) {
        var mountAt = contentDocumentHandle;
        var isListening = getListeningForDocument(mountAt);
        var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];
        var topLevelTypes = EventConstants.topLevelTypes;
        for (var i = 0,
            l = dependencies.length; i < l; i++) {
          var dependency = dependencies[i];
          if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
            if (dependency === topLevelTypes.topWheel) {
              if (isEventSupported('wheel')) {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'wheel', mountAt);
              } else if (isEventSupported('mousewheel')) {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'mousewheel', mountAt);
              } else {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'DOMMouseScroll', mountAt);
              }
            } else if (dependency === topLevelTypes.topScroll) {
              if (isEventSupported('scroll', true)) {
                ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topScroll, 'scroll', mountAt);
              } else {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topScroll, 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
              }
            } else if (dependency === topLevelTypes.topFocus || dependency === topLevelTypes.topBlur) {
              if (isEventSupported('focus', true)) {
                ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topFocus, 'focus', mountAt);
                ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topBlur, 'blur', mountAt);
              } else if (isEventSupported('focusin')) {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topFocus, 'focusin', mountAt);
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topBlur, 'focusout', mountAt);
              }
              isListening[topLevelTypes.topBlur] = true;
              isListening[topLevelTypes.topFocus] = true;
            } else if (topEventMapping.hasOwnProperty(dependency)) {
              ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
            }
            isListening[dependency] = true;
          }
        }
      },
      trapBubbledEvent: function(topLevelType, handlerBaseName, handle) {
        return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
      },
      trapCapturedEvent: function(topLevelType, handlerBaseName, handle) {
        return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
      },
      ensureScrollValueMonitoring: function() {
        if (!isMonitoringScrollValue) {
          var refresh = ViewportMetrics.refreshScrollValues;
          ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
          isMonitoringScrollValue = true;
        }
      },
      eventNameDispatchConfigs: EventPluginHub.eventNameDispatchConfigs,
      registrationNameModules: EventPluginHub.registrationNameModules,
      putListener: EventPluginHub.putListener,
      getListener: EventPluginHub.getListener,
      deleteListener: EventPluginHub.deleteListener,
      deleteAllListeners: EventPluginHub.deleteAllListeners
    });
    module.exports = ReactBrowserEventEmitter;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/containsNode", ["npm:react@0.12.2/lib/isTextNode"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var isTextNode = require("npm:react@0.12.2/lib/isTextNode");
  function containsNode(outerNode, innerNode) {
    if (!outerNode || !innerNode) {
      return false;
    } else if (outerNode === innerNode) {
      return true;
    } else if (isTextNode(outerNode)) {
      return false;
    } else if (isTextNode(innerNode)) {
      return containsNode(outerNode, innerNode.parentNode);
    } else if (outerNode.contains) {
      return outerNode.contains(innerNode);
    } else if (outerNode.compareDocumentPosition) {
      return !!(outerNode.compareDocumentPosition(innerNode) & 16);
    } else {
      return false;
    }
  }
  module.exports = containsNode;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactMultiChild", ["npm:react@0.12.2/lib/ReactComponent", "npm:react@0.12.2/lib/ReactMultiChildUpdateTypes", "npm:react@0.12.2/lib/flattenChildren", "npm:react@0.12.2/lib/instantiateReactComponent", "npm:react@0.12.2/lib/shouldUpdateReactComponent", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactComponent = require("npm:react@0.12.2/lib/ReactComponent");
    var ReactMultiChildUpdateTypes = require("npm:react@0.12.2/lib/ReactMultiChildUpdateTypes");
    var flattenChildren = require("npm:react@0.12.2/lib/flattenChildren");
    var instantiateReactComponent = require("npm:react@0.12.2/lib/instantiateReactComponent");
    var shouldUpdateReactComponent = require("npm:react@0.12.2/lib/shouldUpdateReactComponent");
    var updateDepth = 0;
    var updateQueue = [];
    var markupQueue = [];
    function enqueueMarkup(parentID, markup, toIndex) {
      updateQueue.push({
        parentID: parentID,
        parentNode: null,
        type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
        markupIndex: markupQueue.push(markup) - 1,
        textContent: null,
        fromIndex: null,
        toIndex: toIndex
      });
    }
    function enqueueMove(parentID, fromIndex, toIndex) {
      updateQueue.push({
        parentID: parentID,
        parentNode: null,
        type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
        markupIndex: null,
        textContent: null,
        fromIndex: fromIndex,
        toIndex: toIndex
      });
    }
    function enqueueRemove(parentID, fromIndex) {
      updateQueue.push({
        parentID: parentID,
        parentNode: null,
        type: ReactMultiChildUpdateTypes.REMOVE_NODE,
        markupIndex: null,
        textContent: null,
        fromIndex: fromIndex,
        toIndex: null
      });
    }
    function enqueueTextContent(parentID, textContent) {
      updateQueue.push({
        parentID: parentID,
        parentNode: null,
        type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
        markupIndex: null,
        textContent: textContent,
        fromIndex: null,
        toIndex: null
      });
    }
    function processQueue() {
      if (updateQueue.length) {
        ReactComponent.BackendIDOperations.dangerouslyProcessChildrenUpdates(updateQueue, markupQueue);
        clearQueue();
      }
    }
    function clearQueue() {
      updateQueue.length = 0;
      markupQueue.length = 0;
    }
    var ReactMultiChild = {Mixin: {
        mountChildren: function(nestedChildren, transaction) {
          var children = flattenChildren(nestedChildren);
          var mountImages = [];
          var index = 0;
          this._renderedChildren = children;
          for (var name in children) {
            var child = children[name];
            if (children.hasOwnProperty(name)) {
              var childInstance = instantiateReactComponent(child, null);
              children[name] = childInstance;
              var rootID = this._rootNodeID + name;
              var mountImage = childInstance.mountComponent(rootID, transaction, this._mountDepth + 1);
              childInstance._mountIndex = index;
              mountImages.push(mountImage);
              index++;
            }
          }
          return mountImages;
        },
        updateTextContent: function(nextContent) {
          updateDepth++;
          var errorThrown = true;
          try {
            var prevChildren = this._renderedChildren;
            for (var name in prevChildren) {
              if (prevChildren.hasOwnProperty(name)) {
                this._unmountChildByName(prevChildren[name], name);
              }
            }
            this.setTextContent(nextContent);
            errorThrown = false;
          } finally {
            updateDepth--;
            if (!updateDepth) {
              errorThrown ? clearQueue() : processQueue();
            }
          }
        },
        updateChildren: function(nextNestedChildren, transaction) {
          updateDepth++;
          var errorThrown = true;
          try {
            this._updateChildren(nextNestedChildren, transaction);
            errorThrown = false;
          } finally {
            updateDepth--;
            if (!updateDepth) {
              errorThrown ? clearQueue() : processQueue();
            }
          }
        },
        _updateChildren: function(nextNestedChildren, transaction) {
          var nextChildren = flattenChildren(nextNestedChildren);
          var prevChildren = this._renderedChildren;
          if (!nextChildren && !prevChildren) {
            return ;
          }
          var name;
          var lastIndex = 0;
          var nextIndex = 0;
          for (name in nextChildren) {
            if (!nextChildren.hasOwnProperty(name)) {
              continue;
            }
            var prevChild = prevChildren && prevChildren[name];
            var prevElement = prevChild && prevChild._currentElement;
            var nextElement = nextChildren[name];
            if (shouldUpdateReactComponent(prevElement, nextElement)) {
              this.moveChild(prevChild, nextIndex, lastIndex);
              lastIndex = Math.max(prevChild._mountIndex, lastIndex);
              prevChild.receiveComponent(nextElement, transaction);
              prevChild._mountIndex = nextIndex;
            } else {
              if (prevChild) {
                lastIndex = Math.max(prevChild._mountIndex, lastIndex);
                this._unmountChildByName(prevChild, name);
              }
              var nextChildInstance = instantiateReactComponent(nextElement, null);
              this._mountChildByNameAtIndex(nextChildInstance, name, nextIndex, transaction);
            }
            nextIndex++;
          }
          for (name in prevChildren) {
            if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren[name])) {
              this._unmountChildByName(prevChildren[name], name);
            }
          }
        },
        unmountChildren: function() {
          var renderedChildren = this._renderedChildren;
          for (var name in renderedChildren) {
            var renderedChild = renderedChildren[name];
            if (renderedChild.unmountComponent) {
              renderedChild.unmountComponent();
            }
          }
          this._renderedChildren = null;
        },
        moveChild: function(child, toIndex, lastIndex) {
          if (child._mountIndex < lastIndex) {
            enqueueMove(this._rootNodeID, child._mountIndex, toIndex);
          }
        },
        createChild: function(child, mountImage) {
          enqueueMarkup(this._rootNodeID, mountImage, child._mountIndex);
        },
        removeChild: function(child) {
          enqueueRemove(this._rootNodeID, child._mountIndex);
        },
        setTextContent: function(textContent) {
          enqueueTextContent(this._rootNodeID, textContent);
        },
        _mountChildByNameAtIndex: function(child, name, index, transaction) {
          var rootID = this._rootNodeID + name;
          var mountImage = child.mountComponent(rootID, transaction, this._mountDepth + 1);
          child._mountIndex = index;
          this.createChild(child, mountImage);
          this._renderedChildren = this._renderedChildren || {};
          this._renderedChildren[name] = child;
        },
        _unmountChildByName: function(child, name) {
          this.removeChild(child);
          child._mountIndex = null;
          child.unmountComponent();
          delete this._renderedChildren[name];
        }
      }};
    module.exports = ReactMultiChild;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SyntheticInputEvent", ["npm:react@0.12.2/lib/SyntheticEvent"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var SyntheticEvent = require("npm:react@0.12.2/lib/SyntheticEvent");
  var InputEventInterface = {data: null};
  function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent) {
    SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
  }
  SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);
  module.exports = SyntheticInputEvent;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactInputSelection", ["npm:react@0.12.2/lib/ReactDOMSelection", "npm:react@0.12.2/lib/containsNode", "npm:react@0.12.2/lib/focusNode", "npm:react@0.12.2/lib/getActiveElement"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var ReactDOMSelection = require("npm:react@0.12.2/lib/ReactDOMSelection");
  var containsNode = require("npm:react@0.12.2/lib/containsNode");
  var focusNode = require("npm:react@0.12.2/lib/focusNode");
  var getActiveElement = require("npm:react@0.12.2/lib/getActiveElement");
  function isInDocument(node) {
    return containsNode(document.documentElement, node);
  }
  var ReactInputSelection = {
    hasSelectionCapabilities: function(elem) {
      return elem && ((elem.nodeName === 'INPUT' && elem.type === 'text') || elem.nodeName === 'TEXTAREA' || elem.contentEditable === 'true');
    },
    getSelectionInformation: function() {
      var focusedElem = getActiveElement();
      return {
        focusedElem: focusedElem,
        selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
      };
    },
    restoreSelection: function(priorSelectionInformation) {
      var curFocusedElem = getActiveElement();
      var priorFocusedElem = priorSelectionInformation.focusedElem;
      var priorSelectionRange = priorSelectionInformation.selectionRange;
      if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
        if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
          ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
        }
        focusNode(priorFocusedElem);
      }
    },
    getSelection: function(input) {
      var selection;
      if ('selectionStart' in input) {
        selection = {
          start: input.selectionStart,
          end: input.selectionEnd
        };
      } else if (document.selection && input.nodeName === 'INPUT') {
        var range = document.selection.createRange();
        if (range.parentElement() === input) {
          selection = {
            start: -range.moveStart('character', -input.value.length),
            end: -range.moveEnd('character', -input.value.length)
          };
        }
      } else {
        selection = ReactDOMSelection.getOffsets(input);
      }
      return selection || {
        start: 0,
        end: 0
      };
    },
    setSelection: function(input, offsets) {
      var start = offsets.start;
      var end = offsets.end;
      if (typeof end === 'undefined') {
        end = start;
      }
      if ('selectionStart' in input) {
        input.selectionStart = start;
        input.selectionEnd = Math.min(end, input.value.length);
      } else if (document.selection && input.nodeName === 'INPUT') {
        var range = input.createTextRange();
        range.collapse(true);
        range.moveStart('character', start);
        range.moveEnd('character', end - start);
        range.select();
      } else {
        ReactDOMSelection.setOffsets(input, offsets);
      }
    }
  };
  module.exports = ReactInputSelection;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/EnterLeaveEventPlugin", ["npm:react@0.12.2/lib/EventConstants", "npm:react@0.12.2/lib/EventPropagators", "npm:react@0.12.2/lib/SyntheticMouseEvent", "npm:react@0.12.2/lib/ReactMount", "npm:react@0.12.2/lib/keyOf"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var EventConstants = require("npm:react@0.12.2/lib/EventConstants");
  var EventPropagators = require("npm:react@0.12.2/lib/EventPropagators");
  var SyntheticMouseEvent = require("npm:react@0.12.2/lib/SyntheticMouseEvent");
  var ReactMount = require("npm:react@0.12.2/lib/ReactMount");
  var keyOf = require("npm:react@0.12.2/lib/keyOf");
  var topLevelTypes = EventConstants.topLevelTypes;
  var getFirstReactDOM = ReactMount.getFirstReactDOM;
  var eventTypes = {
    mouseEnter: {
      registrationName: keyOf({onMouseEnter: null}),
      dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
    },
    mouseLeave: {
      registrationName: keyOf({onMouseLeave: null}),
      dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
    }
  };
  var extractedEvents = [null, null];
  var EnterLeaveEventPlugin = {
    eventTypes: eventTypes,
    extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
      if (topLevelType === topLevelTypes.topMouseOver && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
        return null;
      }
      if (topLevelType !== topLevelTypes.topMouseOut && topLevelType !== topLevelTypes.topMouseOver) {
        return null;
      }
      var win;
      if (topLevelTarget.window === topLevelTarget) {
        win = topLevelTarget;
      } else {
        var doc = topLevelTarget.ownerDocument;
        if (doc) {
          win = doc.defaultView || doc.parentWindow;
        } else {
          win = window;
        }
      }
      var from,
          to;
      if (topLevelType === topLevelTypes.topMouseOut) {
        from = topLevelTarget;
        to = getFirstReactDOM(nativeEvent.relatedTarget || nativeEvent.toElement) || win;
      } else {
        from = win;
        to = topLevelTarget;
      }
      if (from === to) {
        return null;
      }
      var fromID = from ? ReactMount.getID(from) : '';
      var toID = to ? ReactMount.getID(to) : '';
      var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, fromID, nativeEvent);
      leave.type = 'mouseleave';
      leave.target = from;
      leave.relatedTarget = to;
      var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, toID, nativeEvent);
      enter.type = 'mouseenter';
      enter.target = to;
      enter.relatedTarget = from;
      EventPropagators.accumulateEnterLeaveDispatches(leave, enter, fromID, toID);
      extractedEvents[0] = leave;
      extractedEvents[1] = enter;
      return extractedEvents;
    }
  };
  module.exports = EnterLeaveEventPlugin;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/createNodesFromMarkup", ["npm:react@0.12.2/lib/ExecutionEnvironment", "npm:react@0.12.2/lib/createArrayFrom", "npm:react@0.12.2/lib/getMarkupWrap", "npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var ExecutionEnvironment = require("npm:react@0.12.2/lib/ExecutionEnvironment");
    var createArrayFrom = require("npm:react@0.12.2/lib/createArrayFrom");
    var getMarkupWrap = require("npm:react@0.12.2/lib/getMarkupWrap");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
    var nodeNamePattern = /^\s*<(\w+)/;
    function getNodeName(markup) {
      var nodeNameMatch = markup.match(nodeNamePattern);
      return nodeNameMatch && nodeNameMatch[1].toLowerCase();
    }
    function createNodesFromMarkup(markup, handleScript) {
      var node = dummyNode;
      ("production" !== process.env.NODE_ENV ? invariant(!!dummyNode, 'createNodesFromMarkup dummy not initialized') : invariant(!!dummyNode));
      var nodeName = getNodeName(markup);
      var wrap = nodeName && getMarkupWrap(nodeName);
      if (wrap) {
        node.innerHTML = wrap[1] + markup + wrap[2];
        var wrapDepth = wrap[0];
        while (wrapDepth--) {
          node = node.lastChild;
        }
      } else {
        node.innerHTML = markup;
      }
      var scripts = node.getElementsByTagName('script');
      if (scripts.length) {
        ("production" !== process.env.NODE_ENV ? invariant(handleScript, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(handleScript));
        createArrayFrom(scripts).forEach(handleScript);
      }
      var nodes = createArrayFrom(node.childNodes);
      while (node.lastChild) {
        node.removeChild(node.lastChild);
      }
      return nodes;
    }
    module.exports = createNodesFromMarkup;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDOMInput", ["npm:react@0.12.2/lib/AutoFocusMixin", "npm:react@0.12.2/lib/DOMPropertyOperations", "npm:react@0.12.2/lib/LinkedValueUtils", "npm:react@0.12.2/lib/ReactBrowserComponentMixin", "npm:react@0.12.2/lib/ReactCompositeComponent", "npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/ReactDOM", "npm:react@0.12.2/lib/ReactMount", "npm:react@0.12.2/lib/ReactUpdates", "npm:react@0.12.2/lib/Object.assign", "npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var AutoFocusMixin = require("npm:react@0.12.2/lib/AutoFocusMixin");
    var DOMPropertyOperations = require("npm:react@0.12.2/lib/DOMPropertyOperations");
    var LinkedValueUtils = require("npm:react@0.12.2/lib/LinkedValueUtils");
    var ReactBrowserComponentMixin = require("npm:react@0.12.2/lib/ReactBrowserComponentMixin");
    var ReactCompositeComponent = require("npm:react@0.12.2/lib/ReactCompositeComponent");
    var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
    var ReactDOM = require("npm:react@0.12.2/lib/ReactDOM");
    var ReactMount = require("npm:react@0.12.2/lib/ReactMount");
    var ReactUpdates = require("npm:react@0.12.2/lib/ReactUpdates");
    var assign = require("npm:react@0.12.2/lib/Object.assign");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var input = ReactElement.createFactory(ReactDOM.input.type);
    var instancesByReactID = {};
    function forceUpdateIfMounted() {
      if (this.isMounted()) {
        this.forceUpdate();
      }
    }
    var ReactDOMInput = ReactCompositeComponent.createClass({
      displayName: 'ReactDOMInput',
      mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],
      getInitialState: function() {
        var defaultValue = this.props.defaultValue;
        return {
          initialChecked: this.props.defaultChecked || false,
          initialValue: defaultValue != null ? defaultValue : null
        };
      },
      render: function() {
        var props = assign({}, this.props);
        props.defaultChecked = null;
        props.defaultValue = null;
        var value = LinkedValueUtils.getValue(this);
        props.value = value != null ? value : this.state.initialValue;
        var checked = LinkedValueUtils.getChecked(this);
        props.checked = checked != null ? checked : this.state.initialChecked;
        props.onChange = this._handleChange;
        return input(props, this.props.children);
      },
      componentDidMount: function() {
        var id = ReactMount.getID(this.getDOMNode());
        instancesByReactID[id] = this;
      },
      componentWillUnmount: function() {
        var rootNode = this.getDOMNode();
        var id = ReactMount.getID(rootNode);
        delete instancesByReactID[id];
      },
      componentDidUpdate: function(prevProps, prevState, prevContext) {
        var rootNode = this.getDOMNode();
        if (this.props.checked != null) {
          DOMPropertyOperations.setValueForProperty(rootNode, 'checked', this.props.checked || false);
        }
        var value = LinkedValueUtils.getValue(this);
        if (value != null) {
          DOMPropertyOperations.setValueForProperty(rootNode, 'value', '' + value);
        }
      },
      _handleChange: function(event) {
        var returnValue;
        var onChange = LinkedValueUtils.getOnChange(this);
        if (onChange) {
          returnValue = onChange.call(this, event);
        }
        ReactUpdates.asap(forceUpdateIfMounted, this);
        var name = this.props.name;
        if (this.props.type === 'radio' && name != null) {
          var rootNode = this.getDOMNode();
          var queryRoot = rootNode;
          while (queryRoot.parentNode) {
            queryRoot = queryRoot.parentNode;
          }
          var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');
          for (var i = 0,
              groupLen = group.length; i < groupLen; i++) {
            var otherNode = group[i];
            if (otherNode === rootNode || otherNode.form !== rootNode.form) {
              continue;
            }
            var otherID = ReactMount.getID(otherNode);
            ("production" !== process.env.NODE_ENV ? invariant(otherID, 'ReactDOMInput: Mixing React and non-React radio inputs with the ' + 'same `name` is not supported.') : invariant(otherID));
            var otherInstance = instancesByReactID[otherID];
            ("production" !== process.env.NODE_ENV ? invariant(otherInstance, 'ReactDOMInput: Unknown radio button ID %s.', otherID) : invariant(otherInstance));
            ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
          }
        }
        return returnValue;
      }
    });
    module.exports = ReactDOMInput;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/SimpleEventPlugin", ["npm:react@0.12.2/lib/EventConstants", "npm:react@0.12.2/lib/EventPluginUtils", "npm:react@0.12.2/lib/EventPropagators", "npm:react@0.12.2/lib/SyntheticClipboardEvent", "npm:react@0.12.2/lib/SyntheticEvent", "npm:react@0.12.2/lib/SyntheticFocusEvent", "npm:react@0.12.2/lib/SyntheticKeyboardEvent", "npm:react@0.12.2/lib/SyntheticMouseEvent", "npm:react@0.12.2/lib/SyntheticDragEvent", "npm:react@0.12.2/lib/SyntheticTouchEvent", "npm:react@0.12.2/lib/SyntheticUIEvent", "npm:react@0.12.2/lib/SyntheticWheelEvent", "npm:react@0.12.2/lib/getEventCharCode", "npm:react@0.12.2/lib/invariant", "npm:react@0.12.2/lib/keyOf", "npm:react@0.12.2/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var EventConstants = require("npm:react@0.12.2/lib/EventConstants");
    var EventPluginUtils = require("npm:react@0.12.2/lib/EventPluginUtils");
    var EventPropagators = require("npm:react@0.12.2/lib/EventPropagators");
    var SyntheticClipboardEvent = require("npm:react@0.12.2/lib/SyntheticClipboardEvent");
    var SyntheticEvent = require("npm:react@0.12.2/lib/SyntheticEvent");
    var SyntheticFocusEvent = require("npm:react@0.12.2/lib/SyntheticFocusEvent");
    var SyntheticKeyboardEvent = require("npm:react@0.12.2/lib/SyntheticKeyboardEvent");
    var SyntheticMouseEvent = require("npm:react@0.12.2/lib/SyntheticMouseEvent");
    var SyntheticDragEvent = require("npm:react@0.12.2/lib/SyntheticDragEvent");
    var SyntheticTouchEvent = require("npm:react@0.12.2/lib/SyntheticTouchEvent");
    var SyntheticUIEvent = require("npm:react@0.12.2/lib/SyntheticUIEvent");
    var SyntheticWheelEvent = require("npm:react@0.12.2/lib/SyntheticWheelEvent");
    var getEventCharCode = require("npm:react@0.12.2/lib/getEventCharCode");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var keyOf = require("npm:react@0.12.2/lib/keyOf");
    var warning = require("npm:react@0.12.2/lib/warning");
    var topLevelTypes = EventConstants.topLevelTypes;
    var eventTypes = {
      blur: {phasedRegistrationNames: {
          bubbled: keyOf({onBlur: true}),
          captured: keyOf({onBlurCapture: true})
        }},
      click: {phasedRegistrationNames: {
          bubbled: keyOf({onClick: true}),
          captured: keyOf({onClickCapture: true})
        }},
      contextMenu: {phasedRegistrationNames: {
          bubbled: keyOf({onContextMenu: true}),
          captured: keyOf({onContextMenuCapture: true})
        }},
      copy: {phasedRegistrationNames: {
          bubbled: keyOf({onCopy: true}),
          captured: keyOf({onCopyCapture: true})
        }},
      cut: {phasedRegistrationNames: {
          bubbled: keyOf({onCut: true}),
          captured: keyOf({onCutCapture: true})
        }},
      doubleClick: {phasedRegistrationNames: {
          bubbled: keyOf({onDoubleClick: true}),
          captured: keyOf({onDoubleClickCapture: true})
        }},
      drag: {phasedRegistrationNames: {
          bubbled: keyOf({onDrag: true}),
          captured: keyOf({onDragCapture: true})
        }},
      dragEnd: {phasedRegistrationNames: {
          bubbled: keyOf({onDragEnd: true}),
          captured: keyOf({onDragEndCapture: true})
        }},
      dragEnter: {phasedRegistrationNames: {
          bubbled: keyOf({onDragEnter: true}),
          captured: keyOf({onDragEnterCapture: true})
        }},
      dragExit: {phasedRegistrationNames: {
          bubbled: keyOf({onDragExit: true}),
          captured: keyOf({onDragExitCapture: true})
        }},
      dragLeave: {phasedRegistrationNames: {
          bubbled: keyOf({onDragLeave: true}),
          captured: keyOf({onDragLeaveCapture: true})
        }},
      dragOver: {phasedRegistrationNames: {
          bubbled: keyOf({onDragOver: true}),
          captured: keyOf({onDragOverCapture: true})
        }},
      dragStart: {phasedRegistrationNames: {
          bubbled: keyOf({onDragStart: true}),
          captured: keyOf({onDragStartCapture: true})
        }},
      drop: {phasedRegistrationNames: {
          bubbled: keyOf({onDrop: true}),
          captured: keyOf({onDropCapture: true})
        }},
      focus: {phasedRegistrationNames: {
          bubbled: keyOf({onFocus: true}),
          captured: keyOf({onFocusCapture: true})
        }},
      input: {phasedRegistrationNames: {
          bubbled: keyOf({onInput: true}),
          captured: keyOf({onInputCapture: true})
        }},
      keyDown: {phasedRegistrationNames: {
          bubbled: keyOf({onKeyDown: true}),
          captured: keyOf({onKeyDownCapture: true})
        }},
      keyPress: {phasedRegistrationNames: {
          bubbled: keyOf({onKeyPress: true}),
          captured: keyOf({onKeyPressCapture: true})
        }},
      keyUp: {phasedRegistrationNames: {
          bubbled: keyOf({onKeyUp: true}),
          captured: keyOf({onKeyUpCapture: true})
        }},
      load: {phasedRegistrationNames: {
          bubbled: keyOf({onLoad: true}),
          captured: keyOf({onLoadCapture: true})
        }},
      error: {phasedRegistrationNames: {
          bubbled: keyOf({onError: true}),
          captured: keyOf({onErrorCapture: true})
        }},
      mouseDown: {phasedRegistrationNames: {
          bubbled: keyOf({onMouseDown: true}),
          captured: keyOf({onMouseDownCapture: true})
        }},
      mouseMove: {phasedRegistrationNames: {
          bubbled: keyOf({onMouseMove: true}),
          captured: keyOf({onMouseMoveCapture: true})
        }},
      mouseOut: {phasedRegistrationNames: {
          bubbled: keyOf({onMouseOut: true}),
          captured: keyOf({onMouseOutCapture: true})
        }},
      mouseOver: {phasedRegistrationNames: {
          bubbled: keyOf({onMouseOver: true}),
          captured: keyOf({onMouseOverCapture: true})
        }},
      mouseUp: {phasedRegistrationNames: {
          bubbled: keyOf({onMouseUp: true}),
          captured: keyOf({onMouseUpCapture: true})
        }},
      paste: {phasedRegistrationNames: {
          bubbled: keyOf({onPaste: true}),
          captured: keyOf({onPasteCapture: true})
        }},
      reset: {phasedRegistrationNames: {
          bubbled: keyOf({onReset: true}),
          captured: keyOf({onResetCapture: true})
        }},
      scroll: {phasedRegistrationNames: {
          bubbled: keyOf({onScroll: true}),
          captured: keyOf({onScrollCapture: true})
        }},
      submit: {phasedRegistrationNames: {
          bubbled: keyOf({onSubmit: true}),
          captured: keyOf({onSubmitCapture: true})
        }},
      touchCancel: {phasedRegistrationNames: {
          bubbled: keyOf({onTouchCancel: true}),
          captured: keyOf({onTouchCancelCapture: true})
        }},
      touchEnd: {phasedRegistrationNames: {
          bubbled: keyOf({onTouchEnd: true}),
          captured: keyOf({onTouchEndCapture: true})
        }},
      touchMove: {phasedRegistrationNames: {
          bubbled: keyOf({onTouchMove: true}),
          captured: keyOf({onTouchMoveCapture: true})
        }},
      touchStart: {phasedRegistrationNames: {
          bubbled: keyOf({onTouchStart: true}),
          captured: keyOf({onTouchStartCapture: true})
        }},
      wheel: {phasedRegistrationNames: {
          bubbled: keyOf({onWheel: true}),
          captured: keyOf({onWheelCapture: true})
        }}
    };
    var topLevelEventsToDispatchConfig = {
      topBlur: eventTypes.blur,
      topClick: eventTypes.click,
      topContextMenu: eventTypes.contextMenu,
      topCopy: eventTypes.copy,
      topCut: eventTypes.cut,
      topDoubleClick: eventTypes.doubleClick,
      topDrag: eventTypes.drag,
      topDragEnd: eventTypes.dragEnd,
      topDragEnter: eventTypes.dragEnter,
      topDragExit: eventTypes.dragExit,
      topDragLeave: eventTypes.dragLeave,
      topDragOver: eventTypes.dragOver,
      topDragStart: eventTypes.dragStart,
      topDrop: eventTypes.drop,
      topError: eventTypes.error,
      topFocus: eventTypes.focus,
      topInput: eventTypes.input,
      topKeyDown: eventTypes.keyDown,
      topKeyPress: eventTypes.keyPress,
      topKeyUp: eventTypes.keyUp,
      topLoad: eventTypes.load,
      topMouseDown: eventTypes.mouseDown,
      topMouseMove: eventTypes.mouseMove,
      topMouseOut: eventTypes.mouseOut,
      topMouseOver: eventTypes.mouseOver,
      topMouseUp: eventTypes.mouseUp,
      topPaste: eventTypes.paste,
      topReset: eventTypes.reset,
      topScroll: eventTypes.scroll,
      topSubmit: eventTypes.submit,
      topTouchCancel: eventTypes.touchCancel,
      topTouchEnd: eventTypes.touchEnd,
      topTouchMove: eventTypes.touchMove,
      topTouchStart: eventTypes.touchStart,
      topWheel: eventTypes.wheel
    };
    for (var topLevelType in topLevelEventsToDispatchConfig) {
      topLevelEventsToDispatchConfig[topLevelType].dependencies = [topLevelType];
    }
    var SimpleEventPlugin = {
      eventTypes: eventTypes,
      executeDispatch: function(event, listener, domID) {
        var returnValue = EventPluginUtils.executeDispatch(event, listener, domID);
        ("production" !== process.env.NODE_ENV ? warning(typeof returnValue !== 'boolean', 'Returning `false` from an event handler is deprecated and will be ' + 'ignored in a future release. Instead, manually call ' + 'e.stopPropagation() or e.preventDefault(), as appropriate.') : null);
        if (returnValue === false) {
          event.stopPropagation();
          event.preventDefault();
        }
      },
      extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
        var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
        if (!dispatchConfig) {
          return null;
        }
        var EventConstructor;
        switch (topLevelType) {
          case topLevelTypes.topInput:
          case topLevelTypes.topLoad:
          case topLevelTypes.topError:
          case topLevelTypes.topReset:
          case topLevelTypes.topSubmit:
            EventConstructor = SyntheticEvent;
            break;
          case topLevelTypes.topKeyPress:
            if (getEventCharCode(nativeEvent) === 0) {
              return null;
            }
          case topLevelTypes.topKeyDown:
          case topLevelTypes.topKeyUp:
            EventConstructor = SyntheticKeyboardEvent;
            break;
          case topLevelTypes.topBlur:
          case topLevelTypes.topFocus:
            EventConstructor = SyntheticFocusEvent;
            break;
          case topLevelTypes.topClick:
            if (nativeEvent.button === 2) {
              return null;
            }
          case topLevelTypes.topContextMenu:
          case topLevelTypes.topDoubleClick:
          case topLevelTypes.topMouseDown:
          case topLevelTypes.topMouseMove:
          case topLevelTypes.topMouseOut:
          case topLevelTypes.topMouseOver:
          case topLevelTypes.topMouseUp:
            EventConstructor = SyntheticMouseEvent;
            break;
          case topLevelTypes.topDrag:
          case topLevelTypes.topDragEnd:
          case topLevelTypes.topDragEnter:
          case topLevelTypes.topDragExit:
          case topLevelTypes.topDragLeave:
          case topLevelTypes.topDragOver:
          case topLevelTypes.topDragStart:
          case topLevelTypes.topDrop:
            EventConstructor = SyntheticDragEvent;
            break;
          case topLevelTypes.topTouchCancel:
          case topLevelTypes.topTouchEnd:
          case topLevelTypes.topTouchMove:
          case topLevelTypes.topTouchStart:
            EventConstructor = SyntheticTouchEvent;
            break;
          case topLevelTypes.topScroll:
            EventConstructor = SyntheticUIEvent;
            break;
          case topLevelTypes.topWheel:
            EventConstructor = SyntheticWheelEvent;
            break;
          case topLevelTypes.topCopy:
          case topLevelTypes.topCut:
          case topLevelTypes.topPaste:
            EventConstructor = SyntheticClipboardEvent;
            break;
        }
        ("production" !== process.env.NODE_ENV ? invariant(EventConstructor, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : invariant(EventConstructor));
        var event = EventConstructor.getPooled(dispatchConfig, topLevelTargetID, nativeEvent);
        EventPropagators.accumulateTwoPhaseDispatches(event);
        return event;
      }
    };
    module.exports = SimpleEventPlugin;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDefaultPerf", ["npm:react@0.12.2/lib/DOMProperty", "npm:react@0.12.2/lib/ReactDefaultPerfAnalysis", "npm:react@0.12.2/lib/ReactMount", "npm:react@0.12.2/lib/ReactPerf", "npm:react@0.12.2/lib/performanceNow"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var DOMProperty = require("npm:react@0.12.2/lib/DOMProperty");
  var ReactDefaultPerfAnalysis = require("npm:react@0.12.2/lib/ReactDefaultPerfAnalysis");
  var ReactMount = require("npm:react@0.12.2/lib/ReactMount");
  var ReactPerf = require("npm:react@0.12.2/lib/ReactPerf");
  var performanceNow = require("npm:react@0.12.2/lib/performanceNow");
  function roundFloat(val) {
    return Math.floor(val * 100) / 100;
  }
  function addValue(obj, key, val) {
    obj[key] = (obj[key] || 0) + val;
  }
  var ReactDefaultPerf = {
    _allMeasurements: [],
    _mountStack: [0],
    _injected: false,
    start: function() {
      if (!ReactDefaultPerf._injected) {
        ReactPerf.injection.injectMeasure(ReactDefaultPerf.measure);
      }
      ReactDefaultPerf._allMeasurements.length = 0;
      ReactPerf.enableMeasure = true;
    },
    stop: function() {
      ReactPerf.enableMeasure = false;
    },
    getLastMeasurements: function() {
      return ReactDefaultPerf._allMeasurements;
    },
    printExclusive: function(measurements) {
      measurements = measurements || ReactDefaultPerf._allMeasurements;
      var summary = ReactDefaultPerfAnalysis.getExclusiveSummary(measurements);
      console.table(summary.map(function(item) {
        return {
          'Component class name': item.componentName,
          'Total inclusive time (ms)': roundFloat(item.inclusive),
          'Exclusive mount time (ms)': roundFloat(item.exclusive),
          'Exclusive render time (ms)': roundFloat(item.render),
          'Mount time per instance (ms)': roundFloat(item.exclusive / item.count),
          'Render time per instance (ms)': roundFloat(item.render / item.count),
          'Instances': item.count
        };
      }));
    },
    printInclusive: function(measurements) {
      measurements = measurements || ReactDefaultPerf._allMeasurements;
      var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements);
      console.table(summary.map(function(item) {
        return {
          'Owner > component': item.componentName,
          'Inclusive time (ms)': roundFloat(item.time),
          'Instances': item.count
        };
      }));
      console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
    },
    getMeasurementsSummaryMap: function(measurements) {
      var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements, true);
      return summary.map(function(item) {
        return {
          'Owner > component': item.componentName,
          'Wasted time (ms)': item.time,
          'Instances': item.count
        };
      });
    },
    printWasted: function(measurements) {
      measurements = measurements || ReactDefaultPerf._allMeasurements;
      console.table(ReactDefaultPerf.getMeasurementsSummaryMap(measurements));
      console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
    },
    printDOM: function(measurements) {
      measurements = measurements || ReactDefaultPerf._allMeasurements;
      var summary = ReactDefaultPerfAnalysis.getDOMSummary(measurements);
      console.table(summary.map(function(item) {
        var result = {};
        result[DOMProperty.ID_ATTRIBUTE_NAME] = item.id;
        result['type'] = item.type;
        result['args'] = JSON.stringify(item.args);
        return result;
      }));
      console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
    },
    _recordWrite: function(id, fnName, totalTime, args) {
      var writes = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].writes;
      writes[id] = writes[id] || [];
      writes[id].push({
        type: fnName,
        time: totalTime,
        args: args
      });
    },
    measure: function(moduleName, fnName, func) {
      return function() {
        for (var args = [],
            $__0 = 0,
            $__1 = arguments.length; $__0 < $__1; $__0++)
          args.push(arguments[$__0]);
        var totalTime;
        var rv;
        var start;
        if (fnName === '_renderNewRootComponent' || fnName === 'flushBatchedUpdates') {
          ReactDefaultPerf._allMeasurements.push({
            exclusive: {},
            inclusive: {},
            render: {},
            counts: {},
            writes: {},
            displayNames: {},
            totalTime: 0
          });
          start = performanceNow();
          rv = func.apply(this, args);
          ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].totalTime = performanceNow() - start;
          return rv;
        } else if (moduleName === 'ReactDOMIDOperations' || moduleName === 'ReactComponentBrowserEnvironment') {
          start = performanceNow();
          rv = func.apply(this, args);
          totalTime = performanceNow() - start;
          if (fnName === 'mountImageIntoNode') {
            var mountID = ReactMount.getID(args[1]);
            ReactDefaultPerf._recordWrite(mountID, fnName, totalTime, args[0]);
          } else if (fnName === 'dangerouslyProcessChildrenUpdates') {
            args[0].forEach(function(update) {
              var writeArgs = {};
              if (update.fromIndex !== null) {
                writeArgs.fromIndex = update.fromIndex;
              }
              if (update.toIndex !== null) {
                writeArgs.toIndex = update.toIndex;
              }
              if (update.textContent !== null) {
                writeArgs.textContent = update.textContent;
              }
              if (update.markupIndex !== null) {
                writeArgs.markup = args[1][update.markupIndex];
              }
              ReactDefaultPerf._recordWrite(update.parentID, update.type, totalTime, writeArgs);
            });
          } else {
            ReactDefaultPerf._recordWrite(args[0], fnName, totalTime, Array.prototype.slice.call(args, 1));
          }
          return rv;
        } else if (moduleName === 'ReactCompositeComponent' && (fnName === 'mountComponent' || fnName === 'updateComponent' || fnName === '_renderValidatedComponent')) {
          var rootNodeID = fnName === 'mountComponent' ? args[0] : this._rootNodeID;
          var isRender = fnName === '_renderValidatedComponent';
          var isMount = fnName === 'mountComponent';
          var mountStack = ReactDefaultPerf._mountStack;
          var entry = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1];
          if (isRender) {
            addValue(entry.counts, rootNodeID, 1);
          } else if (isMount) {
            mountStack.push(0);
          }
          start = performanceNow();
          rv = func.apply(this, args);
          totalTime = performanceNow() - start;
          if (isRender) {
            addValue(entry.render, rootNodeID, totalTime);
          } else if (isMount) {
            var subMountTime = mountStack.pop();
            mountStack[mountStack.length - 1] += totalTime;
            addValue(entry.exclusive, rootNodeID, totalTime - subMountTime);
            addValue(entry.inclusive, rootNodeID, totalTime);
          } else {
            addValue(entry.inclusive, rootNodeID, totalTime);
          }
          entry.displayNames[rootNodeID] = {
            current: this.constructor.displayName,
            owner: this._owner ? this._owner.constructor.displayName : '<root>'
          };
          return rv;
        } else {
          return func.apply(this, args);
        }
      };
    }
  };
  module.exports = ReactDefaultPerf;
  global.define = __define;
  return module.exports;
});



System.register("javascripts/vendor/touchpunch", ["github:components/jquery@2.1.3", "github:components/jqueryui@1.11.3"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var TouchPunch = function(jQuery) {
    jQuery.support.touch = 'ontouchend' in document;
    if (!jQuery.support.touch) {
      return ;
    }
    var mouseProto = jQuery.ui.mouse.prototype,
        _mouseInit = mouseProto._mouseInit,
        _mouseDestroy = mouseProto._mouseDestroy,
        touchHandled;
    function simulateMouseEvent(event, simulatedType) {
      if (event.originalEvent.touches.length > 1) {
        return ;
      }
      event.preventDefault();
      var touch = event.originalEvent.changedTouches[0],
          simulatedEvent = document.createEvent('MouseEvents');
      simulatedEvent.initMouseEvent(simulatedType, true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
      event.target.dispatchEvent(simulatedEvent);
    }
    mouseProto._touchStart = function(event) {
      var self = this;
      if (touchHandled || !self._mouseCapture(event.originalEvent.changedTouches[0])) {
        return ;
      }
      touchHandled = true;
      self._touchMoved = false;
      simulateMouseEvent(event, 'mouseover');
      simulateMouseEvent(event, 'mousemove');
      simulateMouseEvent(event, 'mousedown');
    };
    mouseProto._touchMove = function(event) {
      if (!touchHandled) {
        return ;
      }
      this._touchMoved = true;
      simulateMouseEvent(event, 'mousemove');
    };
    mouseProto._touchEnd = function(event) {
      if (!touchHandled) {
        return ;
      }
      simulateMouseEvent(event, 'mouseup');
      simulateMouseEvent(event, 'mouseout');
      if (!this._touchMoved) {
        simulateMouseEvent(event, 'click');
      }
      touchHandled = false;
    };
    mouseProto._mouseInit = function() {
      var self = this;
      self.element.bind({
        touchstart: jQuery.proxy(self, '_touchStart'),
        touchmove: jQuery.proxy(self, '_touchMove'),
        touchend: jQuery.proxy(self, '_touchEnd')
      });
      _mouseInit.call(self);
    };
    mouseProto._mouseDestroy = function() {
      var self = this;
      self.element.unbind({
        touchstart: jQuery.proxy(self, '_touchStart'),
        touchmove: jQuery.proxy(self, '_touchMove'),
        touchend: jQuery.proxy(self, '_touchEnd')
      });
      _mouseDestroy.call(self);
    };
  };
  jQuery = require("github:components/jquery@2.1.3");
  jQueryUI = require("github:components/jqueryui@1.11.3");
  TouchPunch(jQuery);
  module.exports = jQuery;
  global.define = __define;
  return module.exports;
});



System.register("javascripts/models/link-manager", ["npm:lodash@3.3.1", "npm:loglevel@1.2.0", "github:components/jquery@2.1.3", "javascripts/importer", "javascripts/models/link", "javascripts/models/Node"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function() {
    var $,
        DiagramNode,
        Importer,
        Link,
        LinkManager,
        _,
        log,
        bind = function(fn, me) {
          return function() {
            return fn.apply(me, arguments);
          };
        };
    _ = require("npm:lodash@3.3.1");
    log = require("npm:loglevel@1.2.0");
    $ = require("github:components/jquery@2.1.3");
    Importer = require("javascripts/importer");
    Link = require("javascripts/models/link");
    DiagramNode = require("javascripts/models/Node");
    LinkManager = (function() {
      LinkManager.instances = {};
      LinkManager.instance = function(context) {
        var base;
        (base = this.instances)[context] || (base[context] = new this(context));
        return this.instances[context];
      };
      function LinkManager(context) {
        this.loadDataFromUrl = bind(this.loadDataFromUrl, this);
        this.linkKeys = {};
        this.nodeKeys = {};
        this.linkListeners = [];
        this.nodeListeners = [];
        this.selectionListeners = [];
        this.selectedNode = {};
      }
      LinkManager.prototype.addLinkListener = function(listener) {
        log.info("adding link listener");
        return this.linkListeners.push(listener);
      };
      LinkManager.prototype.addNodeListener = function(listener) {
        log.info("adding node listener");
        return this.nodeListeners.push(listener);
      };
      LinkManager.prototype.addSelectionListener = function(listener) {
        log.info("adding selection listener " + listener);
        return this.selectionListeners.push(listener);
      };
      LinkManager.prototype.getLinks = function() {
        var key,
            value;
        return (function() {
          var ref,
              results;
          ref = this.linkKeys;
          results = [];
          for (key in ref) {
            value = ref[key];
            results.push(value);
          }
          return results;
        }).call(this);
      };
      LinkManager.prototype.getNodes = function() {
        var key,
            value;
        return (function() {
          var ref,
              results;
          ref = this.nodeKeys;
          results = [];
          for (key in ref) {
            value = ref[key];
            results.push(value);
          }
          return results;
        }).call(this);
      };
      LinkManager.prototype.hasLink = function(link) {
        return this.linkKeys[link.terminalKey()] != null;
      };
      LinkManager.prototype.hasNode = function(node) {
        return this.nodeKeys[node.key];
      };
      LinkManager.prototype.importLink = function(linkSpec) {
        var link,
            sourceNode,
            targetNode;
        sourceNode = this.nodeKeys[linkSpec.sourceNode];
        targetNode = this.nodeKeys[linkSpec.targetNode];
        linkSpec.sourceNode = sourceNode;
        linkSpec.targetNode = targetNode;
        link = new Link(linkSpec);
        return this.addLink(link);
      };
      LinkManager.prototype.addLink = function(link) {
        var i,
            len,
            listener,
            ref;
        if (!this.hasLink(link)) {
          this.linkKeys[link.terminalKey()] = link;
          this.nodeKeys[link.sourceNode.key].addLink(link);
          this.nodeKeys[link.targetNode.key].addLink(link);
          ref = this.linkListeners;
          for (i = 0, len = ref.length; i < len; i++) {
            listener = ref[i];
            log.info("notifying of new link: " + (link.terminalKey()));
            listener.handleLinkAdd(link);
          }
          this.selectLink(link);
          return true;
        }
        return false;
      };
      LinkManager.prototype.importNode = function(nodeSpec) {
        var node;
        node = new DiagramNode(nodeSpec.data, nodeSpec.key);
        return this.addNode(node);
      };
      LinkManager.prototype.addNode = function(node) {
        var i,
            len,
            listener,
            ref;
        if (!this.hasNode(node)) {
          this.nodeKeys[node.key] = node;
          ref = this.nodeListeners;
          for (i = 0, len = ref.length; i < len; i++) {
            listener = ref[i];
            log.info("notifying of new Node");
            listener.handleNodeAdd(node);
          }
          this.selectNode(node.key);
          return true;
        }
        return false;
      };
      LinkManager.prototype.moveNode = function(nodeKey, x, y) {
        var i,
            len,
            listener,
            node,
            ref,
            results;
        node = this.nodeKeys[nodeKey];
        if (!node) {
          return ;
        }
        node.x = x;
        node.y = y;
        ref = this.nodeListeners;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          listener = ref[i];
          log.info("notifying of NodeMove");
          results.push(listener.handleNodeMove(node));
        }
        return results;
      };
      LinkManager.prototype.selectNode = function(nodeKey) {
        var i,
            len,
            listener,
            ref,
            results;
        if (this.selectedNode) {
          this.selectedNode.selected = false;
        }
        if (this.selectedLink) {
          this.selectedLink.selected = false;
          this.selectedLink = null;
        }
        this.selectedNode = this.nodeKeys[nodeKey];
        if (this.selectedNode) {
          this.selectedNode.selected = true;
          log.info("Selection happened for " + nodeKey + " -- " + this.selectedNode.title);
        }
        ref = this.selectionListeners;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          listener = ref[i];
          results.push(listener({
            node: this.selectedNode,
            connection: null
          }));
        }
        return results;
      };
      LinkManager.prototype.changeNode = function(title, image) {
        var i,
            len,
            listener,
            ref,
            results;
        if (this.selectedNode) {
          log.info("Change  for " + this.selectedNode.title);
          this.selectedNode.title = title;
          this.selectedNode.image = image;
          ref = this.selectionListeners;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            listener = ref[i];
            results.push(listener({
              node: this.selectedNode,
              connection: null
            }));
          }
          return results;
        }
      };
      LinkManager.prototype.selectLink = function(link) {
        var i,
            len,
            listener,
            ref,
            results;
        if (this.selectedLink) {
          this.selectedLink.selected = false;
        }
        if (this.selectedNode) {
          this.selectedNode.selected = false;
          this.selectedNode = null;
        }
        this.selectedLink = link;
        link.selected = true;
        ref = this.selectionListeners;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          listener = ref[i];
          results.push(listener({
            node: null,
            connection: this.selectedLink
          }));
        }
        return results;
      };
      LinkManager.prototype.changeLink = function(title, color, deleted) {
        var i,
            len,
            listener,
            ref,
            results;
        if (this.selectedLink) {
          log.info("Change  for " + this.selectedLink.title);
          if (deleted) {
            return this.removeSelectedLink();
          } else {
            this.selectedLink.title = title;
            this.selectedLink.color = color;
            ref = this.selectionListeners;
            results = [];
            for (i = 0, len = ref.length; i < len; i++) {
              listener = ref[i];
              results.push(listener({
                node: null,
                connection: this.selectedLink
              }));
            }
            return results;
          }
        }
      };
      LinkManager.prototype._nameForNode = function(node) {
        return this.nodeKeys[node];
      };
      LinkManager.prototype.newLinkFromEvent = function(info) {
        var endKey,
            endTerminal,
            newLink,
            startKey,
            startTerminal;
        newLink = {};
        startKey = $(info.source).data('node-key') || 'undefined';
        endKey = $(info.target).data('node-key') || 'undefined';
        startTerminal = info.connection.endpoints[0].anchor.type === "Top" ? "a" : "b";
        endTerminal = info.connection.endpoints[1].anchor.type === "Top" ? "a" : "b";
        this.importLink({
          sourceNode: startKey,
          targetNode: endKey,
          sourceTerminal: startTerminal,
          targetTerminal: endTerminal,
          color: info.color,
          title: info.title
        });
        return true;
      };
      LinkManager.prototype.removelink = function(link) {
        var key;
        key = link.terminalKey();
        return delete this.linkKeys[key];
      };
      LinkManager.prototype.deleteSelected = function() {
        log.info("Deleting selected items");
        this.removeSelectedLink();
        return this.removeSelectedNode();
      };
      LinkManager.prototype.removeSelectedNode = function() {
        var i,
            len,
            listener,
            ref,
            results;
        if (this.selectedNode) {
          this.removeNode(this.selectedNode.key);
          ref = this.selectionListeners;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            listener = ref[i];
            results.push(listener({
              node: null,
              connection: null
            }));
          }
          return results;
        }
      };
      LinkManager.prototype.removeSelectedLink = function() {
        var i,
            j,
            len,
            len1,
            listener,
            ref,
            ref1,
            results;
        if (this.selectedLink) {
          this.removelink(this.selectedLink);
          ref = this.linkListeners;
          for (i = 0, len = ref.length; i < len; i++) {
            listener = ref[i];
            log.info("notifying of deleted Link");
            listener.handleLinkRm(this.selectedLink);
          }
          this.selectedLink = null;
          ref1 = this.selectionListeners;
          results = [];
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            listener = ref1[j];
            results.push(listener({
              node: null,
              connection: null
            }));
          }
          return results;
        }
      };
      LinkManager.prototype.removeLinksForNode = function(node) {
        var i,
            len,
            link,
            ref,
            results;
        ref = node.links;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          link = ref[i];
          results.push(this.removelink(link));
        }
        return results;
      };
      LinkManager.prototype.removeNode = function(nodeKey) {
        var i,
            j,
            len,
            len1,
            listener,
            node,
            ref,
            ref1,
            results;
        node = this.nodeKeys[nodeKey];
        delete this.nodeKeys[nodeKey];
        this.removeLinksForNode(node);
        ref = this.nodeListeners;
        for (i = 0, len = ref.length; i < len; i++) {
          listener = ref[i];
          log.info("notifying of deleted Node");
          listener.handleNodeRm(node);
        }
        this.selectedNode = null;
        ref1 = this.selectionListeners;
        results = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          listener = ref1[j];
          results.push(listener({
            node: null,
            connection: null
          }));
        }
        return results;
      };
      LinkManager.prototype.loadData = function(data) {
        var importer;
        log.info("json success");
        importer = new Importer(this);
        return importer.importData(data);
      };
      LinkManager.prototype.loadDataFromUrl = function(url) {
        log.info("loading local data");
        log.info("url " + url);
        return $.ajax({
          url: url,
          dataType: 'json',
          success: (function(_this) {
            return function(data) {
              return _this.loadData(data);
            };
          })(this),
          error: function(xhr, status, err) {
            return log.error(url, status, err.toString());
          }
        });
      };
      LinkManager.prototype.serialize = function() {
        var key,
            link,
            linkExports,
            node,
            nodeExports;
        nodeExports = (function() {
          var ref,
              results;
          ref = this.nodeKeys;
          results = [];
          for (key in ref) {
            node = ref[key];
            results.push(node.toExport());
          }
          return results;
        }).call(this);
        linkExports = (function() {
          var ref,
              results;
          ref = this.linkKeys;
          results = [];
          for (key in ref) {
            link = ref[key];
            results.push(link.toExport());
          }
          return results;
        }).call(this);
        return {
          nodes: nodeExports,
          links: linkExports
        };
      };
      LinkManager.prototype.toJsonString = function() {
        return JSON.stringify(this.serialize());
      };
      return LinkManager;
    })();
    module.exports = LinkManager;
  }).call(this);
  global.define = __define;
  return module.exports;
});



System.register("github:jspm/nodelibs-process@0.1.1", ["github:jspm/nodelibs-process@0.1.1/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:jspm/nodelibs-process@0.1.1/index");
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/traverseAllChildren", ["npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/ReactInstanceHandles", "npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
    var ReactInstanceHandles = require("npm:react@0.12.2/lib/ReactInstanceHandles");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var SEPARATOR = ReactInstanceHandles.SEPARATOR;
    var SUBSEPARATOR = ':';
    var userProvidedKeyEscaperLookup = {
      '=': '=0',
      '.': '=1',
      ':': '=2'
    };
    var userProvidedKeyEscapeRegex = /[=.:]/g;
    function userProvidedKeyEscaper(match) {
      return userProvidedKeyEscaperLookup[match];
    }
    function getComponentKey(component, index) {
      if (component && component.key != null) {
        return wrapUserProvidedKey(component.key);
      }
      return index.toString(36);
    }
    function escapeUserProvidedKey(text) {
      return ('' + text).replace(userProvidedKeyEscapeRegex, userProvidedKeyEscaper);
    }
    function wrapUserProvidedKey(key) {
      return '$' + escapeUserProvidedKey(key);
    }
    var traverseAllChildrenImpl = function(children, nameSoFar, indexSoFar, callback, traverseContext) {
      var nextName,
          nextIndex;
      var subtreeCount = 0;
      if (Array.isArray(children)) {
        for (var i = 0; i < children.length; i++) {
          var child = children[i];
          nextName = (nameSoFar + (nameSoFar ? SUBSEPARATOR : SEPARATOR) + getComponentKey(child, i));
          nextIndex = indexSoFar + subtreeCount;
          subtreeCount += traverseAllChildrenImpl(child, nextName, nextIndex, callback, traverseContext);
        }
      } else {
        var type = typeof children;
        var isOnlyChild = nameSoFar === '';
        var storageName = isOnlyChild ? SEPARATOR + getComponentKey(children, 0) : nameSoFar;
        if (children == null || type === 'boolean') {
          callback(traverseContext, null, storageName, indexSoFar);
          subtreeCount = 1;
        } else if (type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {
          callback(traverseContext, children, storageName, indexSoFar);
          subtreeCount = 1;
        } else if (type === 'object') {
          ("production" !== process.env.NODE_ENV ? invariant(!children || children.nodeType !== 1, 'traverseAllChildren(...): Encountered an invalid child; DOM ' + 'elements are not valid children of React components.') : invariant(!children || children.nodeType !== 1));
          for (var key in children) {
            if (children.hasOwnProperty(key)) {
              nextName = (nameSoFar + (nameSoFar ? SUBSEPARATOR : SEPARATOR) + wrapUserProvidedKey(key) + SUBSEPARATOR + getComponentKey(children[key], 0));
              nextIndex = indexSoFar + subtreeCount;
              subtreeCount += traverseAllChildrenImpl(children[key], nextName, nextIndex, callback, traverseContext);
            }
          }
        }
      }
      return subtreeCount;
    };
    function traverseAllChildren(children, callback, traverseContext) {
      if (children == null) {
        return 0;
      }
      return traverseAllChildrenImpl(children, '', 0, callback, traverseContext);
    }
    module.exports = traverseAllChildren;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactMount", ["npm:react@0.12.2/lib/DOMProperty", "npm:react@0.12.2/lib/ReactBrowserEventEmitter", "npm:react@0.12.2/lib/ReactCurrentOwner", "npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/ReactLegacyElement", "npm:react@0.12.2/lib/ReactInstanceHandles", "npm:react@0.12.2/lib/ReactPerf", "npm:react@0.12.2/lib/containsNode", "npm:react@0.12.2/lib/deprecated", "npm:react@0.12.2/lib/getReactRootElementInContainer", "npm:react@0.12.2/lib/instantiateReactComponent", "npm:react@0.12.2/lib/invariant", "npm:react@0.12.2/lib/shouldUpdateReactComponent", "npm:react@0.12.2/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var DOMProperty = require("npm:react@0.12.2/lib/DOMProperty");
    var ReactBrowserEventEmitter = require("npm:react@0.12.2/lib/ReactBrowserEventEmitter");
    var ReactCurrentOwner = require("npm:react@0.12.2/lib/ReactCurrentOwner");
    var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
    var ReactLegacyElement = require("npm:react@0.12.2/lib/ReactLegacyElement");
    var ReactInstanceHandles = require("npm:react@0.12.2/lib/ReactInstanceHandles");
    var ReactPerf = require("npm:react@0.12.2/lib/ReactPerf");
    var containsNode = require("npm:react@0.12.2/lib/containsNode");
    var deprecated = require("npm:react@0.12.2/lib/deprecated");
    var getReactRootElementInContainer = require("npm:react@0.12.2/lib/getReactRootElementInContainer");
    var instantiateReactComponent = require("npm:react@0.12.2/lib/instantiateReactComponent");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var shouldUpdateReactComponent = require("npm:react@0.12.2/lib/shouldUpdateReactComponent");
    var warning = require("npm:react@0.12.2/lib/warning");
    var createElement = ReactLegacyElement.wrapCreateElement(ReactElement.createElement);
    var SEPARATOR = ReactInstanceHandles.SEPARATOR;
    var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
    var nodeCache = {};
    var ELEMENT_NODE_TYPE = 1;
    var DOC_NODE_TYPE = 9;
    var instancesByReactRootID = {};
    var containersByReactRootID = {};
    if ("production" !== process.env.NODE_ENV) {
      var rootElementsByReactRootID = {};
    }
    var findComponentRootReusableArray = [];
    function getReactRootID(container) {
      var rootElement = getReactRootElementInContainer(container);
      return rootElement && ReactMount.getID(rootElement);
    }
    function getID(node) {
      var id = internalGetID(node);
      if (id) {
        if (nodeCache.hasOwnProperty(id)) {
          var cached = nodeCache[id];
          if (cached !== node) {
            ("production" !== process.env.NODE_ENV ? invariant(!isValid(cached, id), 'ReactMount: Two valid but unequal nodes with the same `%s`: %s', ATTR_NAME, id) : invariant(!isValid(cached, id)));
            nodeCache[id] = node;
          }
        } else {
          nodeCache[id] = node;
        }
      }
      return id;
    }
    function internalGetID(node) {
      return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';
    }
    function setID(node, id) {
      var oldID = internalGetID(node);
      if (oldID !== id) {
        delete nodeCache[oldID];
      }
      node.setAttribute(ATTR_NAME, id);
      nodeCache[id] = node;
    }
    function getNode(id) {
      if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
        nodeCache[id] = ReactMount.findReactNodeByID(id);
      }
      return nodeCache[id];
    }
    function isValid(node, id) {
      if (node) {
        ("production" !== process.env.NODE_ENV ? invariant(internalGetID(node) === id, 'ReactMount: Unexpected modification of `%s`', ATTR_NAME) : invariant(internalGetID(node) === id));
        var container = ReactMount.findReactContainerForID(id);
        if (container && containsNode(container, node)) {
          return true;
        }
      }
      return false;
    }
    function purgeID(id) {
      delete nodeCache[id];
    }
    var deepestNodeSoFar = null;
    function findDeepestCachedAncestorImpl(ancestorID) {
      var ancestor = nodeCache[ancestorID];
      if (ancestor && isValid(ancestor, ancestorID)) {
        deepestNodeSoFar = ancestor;
      } else {
        return false;
      }
    }
    function findDeepestCachedAncestor(targetID) {
      deepestNodeSoFar = null;
      ReactInstanceHandles.traverseAncestors(targetID, findDeepestCachedAncestorImpl);
      var foundNode = deepestNodeSoFar;
      deepestNodeSoFar = null;
      return foundNode;
    }
    var ReactMount = {
      _instancesByReactRootID: instancesByReactRootID,
      scrollMonitor: function(container, renderCallback) {
        renderCallback();
      },
      _updateRootComponent: function(prevComponent, nextComponent, container, callback) {
        var nextProps = nextComponent.props;
        ReactMount.scrollMonitor(container, function() {
          prevComponent.replaceProps(nextProps, callback);
        });
        if ("production" !== process.env.NODE_ENV) {
          rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container);
        }
        return prevComponent;
      },
      _registerComponent: function(nextComponent, container) {
        ("production" !== process.env.NODE_ENV ? invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE), '_registerComponent(...): Target container is not a DOM element.') : invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE)));
        ReactBrowserEventEmitter.ensureScrollValueMonitoring();
        var reactRootID = ReactMount.registerContainer(container);
        instancesByReactRootID[reactRootID] = nextComponent;
        return reactRootID;
      },
      _renderNewRootComponent: ReactPerf.measure('ReactMount', '_renderNewRootComponent', function(nextComponent, container, shouldReuseMarkup) {
        ("production" !== process.env.NODE_ENV ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate.') : null);
        var componentInstance = instantiateReactComponent(nextComponent, null);
        var reactRootID = ReactMount._registerComponent(componentInstance, container);
        componentInstance.mountComponentIntoNode(reactRootID, container, shouldReuseMarkup);
        if ("production" !== process.env.NODE_ENV) {
          rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container);
        }
        return componentInstance;
      }),
      render: function(nextElement, container, callback) {
        ("production" !== process.env.NODE_ENV ? invariant(ReactElement.isValidElement(nextElement), 'renderComponent(): Invalid component element.%s', (typeof nextElement === 'string' ? ' Instead of passing an element string, make sure to instantiate ' + 'it by passing it to React.createElement.' : ReactLegacyElement.isValidFactory(nextElement) ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' : typeof nextElement.props !== "undefined" ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '')) : invariant(ReactElement.isValidElement(nextElement)));
        var prevComponent = instancesByReactRootID[getReactRootID(container)];
        if (prevComponent) {
          var prevElement = prevComponent._currentElement;
          if (shouldUpdateReactComponent(prevElement, nextElement)) {
            return ReactMount._updateRootComponent(prevComponent, nextElement, container, callback);
          } else {
            ReactMount.unmountComponentAtNode(container);
          }
        }
        var reactRootElement = getReactRootElementInContainer(container);
        var containerHasReactMarkup = reactRootElement && ReactMount.isRenderedByReact(reactRootElement);
        var shouldReuseMarkup = containerHasReactMarkup && !prevComponent;
        var component = ReactMount._renderNewRootComponent(nextElement, container, shouldReuseMarkup);
        callback && callback.call(component);
        return component;
      },
      constructAndRenderComponent: function(constructor, props, container) {
        var element = createElement(constructor, props);
        return ReactMount.render(element, container);
      },
      constructAndRenderComponentByID: function(constructor, props, id) {
        var domNode = document.getElementById(id);
        ("production" !== process.env.NODE_ENV ? invariant(domNode, 'Tried to get element with id of "%s" but it is not present on the page.', id) : invariant(domNode));
        return ReactMount.constructAndRenderComponent(constructor, props, domNode);
      },
      registerContainer: function(container) {
        var reactRootID = getReactRootID(container);
        if (reactRootID) {
          reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);
        }
        if (!reactRootID) {
          reactRootID = ReactInstanceHandles.createReactRootID();
        }
        containersByReactRootID[reactRootID] = container;
        return reactRootID;
      },
      unmountComponentAtNode: function(container) {
        ("production" !== process.env.NODE_ENV ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function of ' + 'props and state; triggering nested component updates from render is ' + 'not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate.') : null);
        var reactRootID = getReactRootID(container);
        var component = instancesByReactRootID[reactRootID];
        if (!component) {
          return false;
        }
        ReactMount.unmountComponentFromNode(component, container);
        delete instancesByReactRootID[reactRootID];
        delete containersByReactRootID[reactRootID];
        if ("production" !== process.env.NODE_ENV) {
          delete rootElementsByReactRootID[reactRootID];
        }
        return true;
      },
      unmountComponentFromNode: function(instance, container) {
        instance.unmountComponent();
        if (container.nodeType === DOC_NODE_TYPE) {
          container = container.documentElement;
        }
        while (container.lastChild) {
          container.removeChild(container.lastChild);
        }
      },
      findReactContainerForID: function(id) {
        var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);
        var container = containersByReactRootID[reactRootID];
        if ("production" !== process.env.NODE_ENV) {
          var rootElement = rootElementsByReactRootID[reactRootID];
          if (rootElement && rootElement.parentNode !== container) {
            ("production" !== process.env.NODE_ENV ? invariant(internalGetID(rootElement) === reactRootID, 'ReactMount: Root element ID differed from reactRootID.') : invariant(internalGetID(rootElement) === reactRootID));
            var containerChild = container.firstChild;
            if (containerChild && reactRootID === internalGetID(containerChild)) {
              rootElementsByReactRootID[reactRootID] = containerChild;
            } else {
              console.warn('ReactMount: Root element has been removed from its original ' + 'container. New container:', rootElement.parentNode);
            }
          }
        }
        return container;
      },
      findReactNodeByID: function(id) {
        var reactRoot = ReactMount.findReactContainerForID(id);
        return ReactMount.findComponentRoot(reactRoot, id);
      },
      isRenderedByReact: function(node) {
        if (node.nodeType !== 1) {
          return false;
        }
        var id = ReactMount.getID(node);
        return id ? id.charAt(0) === SEPARATOR : false;
      },
      getFirstReactDOM: function(node) {
        var current = node;
        while (current && current.parentNode !== current) {
          if (ReactMount.isRenderedByReact(current)) {
            return current;
          }
          current = current.parentNode;
        }
        return null;
      },
      findComponentRoot: function(ancestorNode, targetID) {
        var firstChildren = findComponentRootReusableArray;
        var childIndex = 0;
        var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;
        firstChildren[0] = deepestAncestor.firstChild;
        firstChildren.length = 1;
        while (childIndex < firstChildren.length) {
          var child = firstChildren[childIndex++];
          var targetChild;
          while (child) {
            var childID = ReactMount.getID(child);
            if (childID) {
              if (targetID === childID) {
                targetChild = child;
              } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {
                firstChildren.length = childIndex = 0;
                firstChildren.push(child.firstChild);
              }
            } else {
              firstChildren.push(child.firstChild);
            }
            child = child.nextSibling;
          }
          if (targetChild) {
            firstChildren.length = 0;
            return targetChild;
          }
        }
        firstChildren.length = 0;
        ("production" !== process.env.NODE_ENV ? invariant(false, 'findComponentRoot(..., %s): Unable to find element. This probably ' + 'means the DOM was unexpectedly mutated (e.g., by the browser), ' + 'usually due to forgetting a <tbody> when using tables, nesting tags ' + 'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' + 'parent. ' + 'Try inspecting the child nodes of the element with React ID `%s`.', targetID, ReactMount.getID(ancestorNode)) : invariant(false));
      },
      getReactRootID: getReactRootID,
      getID: getID,
      setID: setID,
      getNode: getNode,
      purgeID: purgeID
    };
    ReactMount.renderComponent = deprecated('ReactMount', 'renderComponent', 'render', this, ReactMount.render);
    module.exports = ReactMount;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/BeforeInputEventPlugin", ["npm:react@0.12.2/lib/EventConstants", "npm:react@0.12.2/lib/EventPropagators", "npm:react@0.12.2/lib/ExecutionEnvironment", "npm:react@0.12.2/lib/SyntheticInputEvent", "npm:react@0.12.2/lib/keyOf"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var EventConstants = require("npm:react@0.12.2/lib/EventConstants");
  var EventPropagators = require("npm:react@0.12.2/lib/EventPropagators");
  var ExecutionEnvironment = require("npm:react@0.12.2/lib/ExecutionEnvironment");
  var SyntheticInputEvent = require("npm:react@0.12.2/lib/SyntheticInputEvent");
  var keyOf = require("npm:react@0.12.2/lib/keyOf");
  var canUseTextInputEvent = (ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !('documentMode' in document || isPresto()));
  function isPresto() {
    var opera = window.opera;
    return (typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12);
  }
  var SPACEBAR_CODE = 32;
  var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
  var topLevelTypes = EventConstants.topLevelTypes;
  var eventTypes = {beforeInput: {
      phasedRegistrationNames: {
        bubbled: keyOf({onBeforeInput: null}),
        captured: keyOf({onBeforeInputCapture: null})
      },
      dependencies: [topLevelTypes.topCompositionEnd, topLevelTypes.topKeyPress, topLevelTypes.topTextInput, topLevelTypes.topPaste]
    }};
  var fallbackChars = null;
  var hasSpaceKeypress = false;
  function isKeypressCommand(nativeEvent) {
    return ((nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && !(nativeEvent.ctrlKey && nativeEvent.altKey));
  }
  var BeforeInputEventPlugin = {
    eventTypes: eventTypes,
    extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
      var chars;
      if (canUseTextInputEvent) {
        switch (topLevelType) {
          case topLevelTypes.topKeyPress:
            var which = nativeEvent.which;
            if (which !== SPACEBAR_CODE) {
              return ;
            }
            hasSpaceKeypress = true;
            chars = SPACEBAR_CHAR;
            break;
          case topLevelTypes.topTextInput:
            chars = nativeEvent.data;
            if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
              return ;
            }
            break;
          default:
            return ;
        }
      } else {
        switch (topLevelType) {
          case topLevelTypes.topPaste:
            fallbackChars = null;
            break;
          case topLevelTypes.topKeyPress:
            if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
              fallbackChars = String.fromCharCode(nativeEvent.which);
            }
            break;
          case topLevelTypes.topCompositionEnd:
            fallbackChars = nativeEvent.data;
            break;
        }
        if (fallbackChars === null) {
          return ;
        }
        chars = fallbackChars;
      }
      if (!chars) {
        return ;
      }
      var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, topLevelTargetID, nativeEvent);
      event.data = chars;
      fallbackChars = null;
      EventPropagators.accumulateTwoPhaseDispatches(event);
      return event;
    }
  };
  module.exports = BeforeInputEventPlugin;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/CompositionEventPlugin", ["npm:react@0.12.2/lib/EventConstants", "npm:react@0.12.2/lib/EventPropagators", "npm:react@0.12.2/lib/ExecutionEnvironment", "npm:react@0.12.2/lib/ReactInputSelection", "npm:react@0.12.2/lib/SyntheticCompositionEvent", "npm:react@0.12.2/lib/getTextContentAccessor", "npm:react@0.12.2/lib/keyOf"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var EventConstants = require("npm:react@0.12.2/lib/EventConstants");
  var EventPropagators = require("npm:react@0.12.2/lib/EventPropagators");
  var ExecutionEnvironment = require("npm:react@0.12.2/lib/ExecutionEnvironment");
  var ReactInputSelection = require("npm:react@0.12.2/lib/ReactInputSelection");
  var SyntheticCompositionEvent = require("npm:react@0.12.2/lib/SyntheticCompositionEvent");
  var getTextContentAccessor = require("npm:react@0.12.2/lib/getTextContentAccessor");
  var keyOf = require("npm:react@0.12.2/lib/keyOf");
  var END_KEYCODES = [9, 13, 27, 32];
  var START_KEYCODE = 229;
  var useCompositionEvent = (ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window);
  var useFallbackData = (!useCompositionEvent || ('documentMode' in document && document.documentMode > 8 && document.documentMode <= 11));
  var topLevelTypes = EventConstants.topLevelTypes;
  var currentComposition = null;
  var eventTypes = {
    compositionEnd: {
      phasedRegistrationNames: {
        bubbled: keyOf({onCompositionEnd: null}),
        captured: keyOf({onCompositionEndCapture: null})
      },
      dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionEnd, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
    },
    compositionStart: {
      phasedRegistrationNames: {
        bubbled: keyOf({onCompositionStart: null}),
        captured: keyOf({onCompositionStartCapture: null})
      },
      dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionStart, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
    },
    compositionUpdate: {
      phasedRegistrationNames: {
        bubbled: keyOf({onCompositionUpdate: null}),
        captured: keyOf({onCompositionUpdateCapture: null})
      },
      dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionUpdate, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
    }
  };
  function getCompositionEventType(topLevelType) {
    switch (topLevelType) {
      case topLevelTypes.topCompositionStart:
        return eventTypes.compositionStart;
      case topLevelTypes.topCompositionEnd:
        return eventTypes.compositionEnd;
      case topLevelTypes.topCompositionUpdate:
        return eventTypes.compositionUpdate;
    }
  }
  function isFallbackStart(topLevelType, nativeEvent) {
    return (topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE);
  }
  function isFallbackEnd(topLevelType, nativeEvent) {
    switch (topLevelType) {
      case topLevelTypes.topKeyUp:
        return (END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1);
      case topLevelTypes.topKeyDown:
        return (nativeEvent.keyCode !== START_KEYCODE);
      case topLevelTypes.topKeyPress:
      case topLevelTypes.topMouseDown:
      case topLevelTypes.topBlur:
        return true;
      default:
        return false;
    }
  }
  function FallbackCompositionState(root) {
    this.root = root;
    this.startSelection = ReactInputSelection.getSelection(root);
    this.startValue = this.getText();
  }
  FallbackCompositionState.prototype.getText = function() {
    return this.root.value || this.root[getTextContentAccessor()];
  };
  FallbackCompositionState.prototype.getData = function() {
    var endValue = this.getText();
    var prefixLength = this.startSelection.start;
    var suffixLength = this.startValue.length - this.startSelection.end;
    return endValue.substr(prefixLength, endValue.length - suffixLength - prefixLength);
  };
  var CompositionEventPlugin = {
    eventTypes: eventTypes,
    extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
      var eventType;
      var data;
      if (useCompositionEvent) {
        eventType = getCompositionEventType(topLevelType);
      } else if (!currentComposition) {
        if (isFallbackStart(topLevelType, nativeEvent)) {
          eventType = eventTypes.compositionStart;
        }
      } else if (isFallbackEnd(topLevelType, nativeEvent)) {
        eventType = eventTypes.compositionEnd;
      }
      if (useFallbackData) {
        if (!currentComposition && eventType === eventTypes.compositionStart) {
          currentComposition = new FallbackCompositionState(topLevelTarget);
        } else if (eventType === eventTypes.compositionEnd) {
          if (currentComposition) {
            data = currentComposition.getData();
            currentComposition = null;
          }
        }
      }
      if (eventType) {
        var event = SyntheticCompositionEvent.getPooled(eventType, topLevelTargetID, nativeEvent);
        if (data) {
          event.data = data;
        }
        EventPropagators.accumulateTwoPhaseDispatches(event);
        return event;
      }
    }
  };
  module.exports = CompositionEventPlugin;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/Danger", ["npm:react@0.12.2/lib/ExecutionEnvironment", "npm:react@0.12.2/lib/createNodesFromMarkup", "npm:react@0.12.2/lib/emptyFunction", "npm:react@0.12.2/lib/getMarkupWrap", "npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ExecutionEnvironment = require("npm:react@0.12.2/lib/ExecutionEnvironment");
    var createNodesFromMarkup = require("npm:react@0.12.2/lib/createNodesFromMarkup");
    var emptyFunction = require("npm:react@0.12.2/lib/emptyFunction");
    var getMarkupWrap = require("npm:react@0.12.2/lib/getMarkupWrap");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var OPEN_TAG_NAME_EXP = /^(<[^ \/>]+)/;
    var RESULT_INDEX_ATTR = 'data-danger-index';
    function getNodeName(markup) {
      return markup.substring(1, markup.indexOf(' '));
    }
    var Danger = {
      dangerouslyRenderMarkup: function(markupList) {
        ("production" !== process.env.NODE_ENV ? invariant(ExecutionEnvironment.canUseDOM, 'dangerouslyRenderMarkup(...): Cannot render markup in a worker ' + 'thread. Make sure `window` and `document` are available globally ' + 'before requiring React when unit testing or use ' + 'React.renderToString for server rendering.') : invariant(ExecutionEnvironment.canUseDOM));
        var nodeName;
        var markupByNodeName = {};
        for (var i = 0; i < markupList.length; i++) {
          ("production" !== process.env.NODE_ENV ? invariant(markupList[i], 'dangerouslyRenderMarkup(...): Missing markup.') : invariant(markupList[i]));
          nodeName = getNodeName(markupList[i]);
          nodeName = getMarkupWrap(nodeName) ? nodeName : '*';
          markupByNodeName[nodeName] = markupByNodeName[nodeName] || [];
          markupByNodeName[nodeName][i] = markupList[i];
        }
        var resultList = [];
        var resultListAssignmentCount = 0;
        for (nodeName in markupByNodeName) {
          if (!markupByNodeName.hasOwnProperty(nodeName)) {
            continue;
          }
          var markupListByNodeName = markupByNodeName[nodeName];
          for (var resultIndex in markupListByNodeName) {
            if (markupListByNodeName.hasOwnProperty(resultIndex)) {
              var markup = markupListByNodeName[resultIndex];
              markupListByNodeName[resultIndex] = markup.replace(OPEN_TAG_NAME_EXP, '$1 ' + RESULT_INDEX_ATTR + '="' + resultIndex + '" ');
            }
          }
          var renderNodes = createNodesFromMarkup(markupListByNodeName.join(''), emptyFunction);
          for (i = 0; i < renderNodes.length; ++i) {
            var renderNode = renderNodes[i];
            if (renderNode.hasAttribute && renderNode.hasAttribute(RESULT_INDEX_ATTR)) {
              resultIndex = +renderNode.getAttribute(RESULT_INDEX_ATTR);
              renderNode.removeAttribute(RESULT_INDEX_ATTR);
              ("production" !== process.env.NODE_ENV ? invariant(!resultList.hasOwnProperty(resultIndex), 'Danger: Assigning to an already-occupied result index.') : invariant(!resultList.hasOwnProperty(resultIndex)));
              resultList[resultIndex] = renderNode;
              resultListAssignmentCount += 1;
            } else if ("production" !== process.env.NODE_ENV) {
              console.error("Danger: Discarding unexpected node:", renderNode);
            }
          }
        }
        ("production" !== process.env.NODE_ENV ? invariant(resultListAssignmentCount === resultList.length, 'Danger: Did not assign to every index of resultList.') : invariant(resultListAssignmentCount === resultList.length));
        ("production" !== process.env.NODE_ENV ? invariant(resultList.length === markupList.length, 'Danger: Expected markup to render %s nodes, but rendered %s.', markupList.length, resultList.length) : invariant(resultList.length === markupList.length));
        return resultList;
      },
      dangerouslyReplaceNodeWithMarkup: function(oldChild, markup) {
        ("production" !== process.env.NODE_ENV ? invariant(ExecutionEnvironment.canUseDOM, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a ' + 'worker thread. Make sure `window` and `document` are available ' + 'globally before requiring React when unit testing or use ' + 'React.renderToString for server rendering.') : invariant(ExecutionEnvironment.canUseDOM));
        ("production" !== process.env.NODE_ENV ? invariant(markup, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : invariant(markup));
        ("production" !== process.env.NODE_ENV ? invariant(oldChild.tagName.toLowerCase() !== 'html', 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the ' + '<html> node. This is because browser quirks make this unreliable ' + 'and/or slow. If you want to render to the root you must use ' + 'server rendering. See renderComponentToString().') : invariant(oldChild.tagName.toLowerCase() !== 'html'));
        var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
        oldChild.parentNode.replaceChild(newChild, oldChild);
      }
    };
    module.exports = Danger;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("javascripts/node-view", ["npm:react@0.12.2", "npm:loglevel@1.2.0", "javascripts/vendor/touchpunch"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var React = require("npm:react@0.12.2");
  var log = require("npm:loglevel@1.2.0");
  var $ = require("javascripts/vendor/touchpunch");
  var DiagramNode = React.createClass({
    displayName: "DiagramNode",
    componentDidMount: function() {
      var $elem = $(this.getDOMNode());
      var nodeKey = this.props.nodeKey;
      var movedHandler = this.doMove;
      $elem.draggable({
        drag: movedHandler,
        containment: "parent"
      });
      var selectCallback = function() {
        this.handleSelected(true);
      }.bind(this);
      var deselectCallback = function() {
        selected = this.props.selected;
        if (!selected) {
          this.handleSelected(false);
        }
      }.bind(this);
      $elem.bind('mouseup touchend', selectCallback);
    },
    handleSelected: function(actually_select) {
      var selectionKey = 'dont-select-anything';
      if (this.props.linkManager) {
        if (actually_select) {
          selectionKey = this.props.nodeKey;
        }
        this.props.linkManager.selectNode(selectionKey);
      }
    },
    propTypes: {
      onDelete: React.PropTypes.func,
      onMove: React.PropTypes.func,
      onSelect: React.PropTypes.func,
      nodeKey: React.PropTypes.string
    },
    getDefaultProps: function() {
      return {
        onMove: function() {
          log.info("internal move handler");
        },
        onStop: function() {
          log.info("internal move handler");
        },
        onDelete: function() {
          log.info("internal on-delete handler");
        },
        onSelect: function() {
          log.info("internal select handler");
        }
      };
    },
    doMove: function(evt, extra) {
      this.props.onMove({
        nodeKey: this.props.nodeKey,
        reactComponent: this,
        domElement: this.getDOMNode(),
        syntheticEvent: evt,
        extra: extra
      });
    },
    doDelete: function(evt, extra) {
      this.props.onDelete({
        nodeKey: this.props.nodeKey,
        reactComponent: this,
        domElement: this.getDOMNode(),
        syntheticEvent: evt
      });
    },
    render: function() {
      var style = {
        top: this.props.data.y,
        left: this.props.data.x
      };
      var nodeKey = this.props.nodeKey;
      var deleteHandler = this.doDelete;
      var className = "elm";
      if (this.props.selected) {
        className = className + " selected";
      }
      var imgSrc = this.props.data.image;
      var imageTag = "";
      if (imgSrc.length > 0) {
        imageTag = (React.createElement("img", {src: imgSrc}));
      }
      ;
      return (React.createElement("div", {
        className: className,
        style: style,
        "data-node-key": nodeKey
      }, React.createElement("div", {className: "img-background"}, React.createElement("div", {
        className: "delete-box",
        onClick: deleteHandler
      }, React.createElement("i", {className: "fa fa-times-circle"})), imageTag, React.createElement("div", {className: "node-title"}, this.props.data.title))));
    }
  });
  module.exports = DiagramNode;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/invariant", ["github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var invariant = function(condition, format, a, b, c, d, e, f) {
      if ("production" !== process.env.NODE_ENV) {
        if (format === undefined) {
          throw new Error('invariant requires an error message argument');
        }
      }
      if (!condition) {
        var error;
        if (format === undefined) {
          error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
        } else {
          var args = [a, b, c, d, e, f];
          var argIndex = 0;
          error = new Error('Invariant Violation: ' + format.replace(/%s/g, function() {
            return args[argIndex++];
          }));
        }
        error.framesToPop = 1;
        throw error;
      }
    };
    module.exports = invariant;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactChildren", ["npm:react@0.12.2/lib/PooledClass", "npm:react@0.12.2/lib/traverseAllChildren", "npm:react@0.12.2/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var PooledClass = require("npm:react@0.12.2/lib/PooledClass");
    var traverseAllChildren = require("npm:react@0.12.2/lib/traverseAllChildren");
    var warning = require("npm:react@0.12.2/lib/warning");
    var twoArgumentPooler = PooledClass.twoArgumentPooler;
    var threeArgumentPooler = PooledClass.threeArgumentPooler;
    function ForEachBookKeeping(forEachFunction, forEachContext) {
      this.forEachFunction = forEachFunction;
      this.forEachContext = forEachContext;
    }
    PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);
    function forEachSingleChild(traverseContext, child, name, i) {
      var forEachBookKeeping = traverseContext;
      forEachBookKeeping.forEachFunction.call(forEachBookKeeping.forEachContext, child, i);
    }
    function forEachChildren(children, forEachFunc, forEachContext) {
      if (children == null) {
        return children;
      }
      var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
      traverseAllChildren(children, forEachSingleChild, traverseContext);
      ForEachBookKeeping.release(traverseContext);
    }
    function MapBookKeeping(mapResult, mapFunction, mapContext) {
      this.mapResult = mapResult;
      this.mapFunction = mapFunction;
      this.mapContext = mapContext;
    }
    PooledClass.addPoolingTo(MapBookKeeping, threeArgumentPooler);
    function mapSingleChildIntoContext(traverseContext, child, name, i) {
      var mapBookKeeping = traverseContext;
      var mapResult = mapBookKeeping.mapResult;
      var keyUnique = !mapResult.hasOwnProperty(name);
      ("production" !== process.env.NODE_ENV ? warning(keyUnique, 'ReactChildren.map(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : null);
      if (keyUnique) {
        var mappedChild = mapBookKeeping.mapFunction.call(mapBookKeeping.mapContext, child, i);
        mapResult[name] = mappedChild;
      }
    }
    function mapChildren(children, func, context) {
      if (children == null) {
        return children;
      }
      var mapResult = {};
      var traverseContext = MapBookKeeping.getPooled(mapResult, func, context);
      traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
      MapBookKeeping.release(traverseContext);
      return mapResult;
    }
    function forEachSingleChildDummy(traverseContext, child, name, i) {
      return null;
    }
    function countChildren(children, context) {
      return traverseAllChildren(children, forEachSingleChildDummy, null);
    }
    var ReactChildren = {
      forEach: forEachChildren,
      map: mapChildren,
      count: countChildren
    };
    module.exports = ReactChildren;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactBrowserComponentMixin", ["npm:react@0.12.2/lib/ReactEmptyComponent", "npm:react@0.12.2/lib/ReactMount", "npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactEmptyComponent = require("npm:react@0.12.2/lib/ReactEmptyComponent");
    var ReactMount = require("npm:react@0.12.2/lib/ReactMount");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var ReactBrowserComponentMixin = {getDOMNode: function() {
        ("production" !== process.env.NODE_ENV ? invariant(this.isMounted(), 'getDOMNode(): A component must be mounted to have a DOM node.') : invariant(this.isMounted()));
        if (ReactEmptyComponent.isNullComponentID(this._rootNodeID)) {
          return null;
        }
        return ReactMount.getNode(this._rootNodeID);
      }};
    module.exports = ReactBrowserComponentMixin;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/DOMChildrenOperations", ["npm:react@0.12.2/lib/Danger", "npm:react@0.12.2/lib/ReactMultiChildUpdateTypes", "npm:react@0.12.2/lib/getTextContentAccessor", "npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var Danger = require("npm:react@0.12.2/lib/Danger");
    var ReactMultiChildUpdateTypes = require("npm:react@0.12.2/lib/ReactMultiChildUpdateTypes");
    var getTextContentAccessor = require("npm:react@0.12.2/lib/getTextContentAccessor");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var textContentAccessor = getTextContentAccessor();
    function insertChildAt(parentNode, childNode, index) {
      parentNode.insertBefore(childNode, parentNode.childNodes[index] || null);
    }
    var updateTextContent;
    if (textContentAccessor === 'textContent') {
      updateTextContent = function(node, text) {
        node.textContent = text;
      };
    } else {
      updateTextContent = function(node, text) {
        while (node.firstChild) {
          node.removeChild(node.firstChild);
        }
        if (text) {
          var doc = node.ownerDocument || document;
          node.appendChild(doc.createTextNode(text));
        }
      };
    }
    var DOMChildrenOperations = {
      dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup,
      updateTextContent: updateTextContent,
      processUpdates: function(updates, markupList) {
        var update;
        var initialChildren = null;
        var updatedChildren = null;
        for (var i = 0; update = updates[i]; i++) {
          if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING || update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {
            var updatedIndex = update.fromIndex;
            var updatedChild = update.parentNode.childNodes[updatedIndex];
            var parentID = update.parentID;
            ("production" !== process.env.NODE_ENV ? invariant(updatedChild, 'processUpdates(): Unable to find child %s of element. This ' + 'probably means the DOM was unexpectedly mutated (e.g., by the ' + 'browser), usually due to forgetting a <tbody> when using tables, ' + 'nesting tags like <form>, <p>, or <a>, or using non-SVG elements ' + 'in an <svg> parent. Try inspecting the child nodes of the element ' + 'with React ID `%s`.', updatedIndex, parentID) : invariant(updatedChild));
            initialChildren = initialChildren || {};
            initialChildren[parentID] = initialChildren[parentID] || [];
            initialChildren[parentID][updatedIndex] = updatedChild;
            updatedChildren = updatedChildren || [];
            updatedChildren.push(updatedChild);
          }
        }
        var renderedMarkup = Danger.dangerouslyRenderMarkup(markupList);
        if (updatedChildren) {
          for (var j = 0; j < updatedChildren.length; j++) {
            updatedChildren[j].parentNode.removeChild(updatedChildren[j]);
          }
        }
        for (var k = 0; update = updates[k]; k++) {
          switch (update.type) {
            case ReactMultiChildUpdateTypes.INSERT_MARKUP:
              insertChildAt(update.parentNode, renderedMarkup[update.markupIndex], update.toIndex);
              break;
            case ReactMultiChildUpdateTypes.MOVE_EXISTING:
              insertChildAt(update.parentNode, initialChildren[update.parentID][update.fromIndex], update.toIndex);
              break;
            case ReactMultiChildUpdateTypes.TEXT_CONTENT:
              updateTextContent(update.parentNode, update.textContent);
              break;
            case ReactMultiChildUpdateTypes.REMOVE_NODE:
              break;
          }
        }
      }
    };
    module.exports = DOMChildrenOperations;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("javascripts/link-view", ["npm:react@0.12.2", "javascripts/node-view", "javascripts/info-pane", "javascripts/importer", "javascripts/models/link-manager", "javascripts/js_plumb_diagram_toolkit", "javascripts/vendor/touchpunch", "npm:lodash@3.3.1", "npm:loglevel@1.2.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var React = require("npm:react@0.12.2");
  var Node = require("javascripts/node-view");
  var InfoPane = require("javascripts/info-pane");
  var Importer = require("javascripts/importer");
  var NodeList = require("javascripts/models/link-manager");
  var DiagramTookkit = require("javascripts/js_plumb_diagram_toolkit");
  var $ = require("javascripts/vendor/touchpunch");
  var _ = require("npm:lodash@3.3.1");
  log = require("npm:loglevel@1.2.0");
  var LinkView = React.createClass({
    displayName: "LinkView",
    componentDidMount: function() {
      this._bindDiagramToolkit();
      this.linkManager = this.props.linkManager;
      this.linkManager.addLinkListener(this);
      this.linkManager.addNodeListener(this);
      var comp = this.getDOMNode();
      $(comp).find(".container").droppable({
        accept: '.proto-node',
        hoverClass: "ui-state-highlight",
        drop: this.addNode
      });
    },
    addNode: function(event, ui) {
      var nodeData = ui.draggable.data();
      var offset = $(this.getDOMNode()).offset();
      var x = ui.offset.left - offset.left;
      var y = ui.offset.top - offset.top;
      var nodeProps = {
        x: x,
        y: y,
        title: nodeData.title,
        image: nodeData.image
      };
      var node = this.linkManager.importNode({data: nodeProps});
    },
    getInitialState: function() {
      return {
        nodes: [],
        links: []
      };
    },
    componentWillUpdate: function() {
      if (this.diagramToolkit && this.diagramToolkit.clear) {
        this.diagramToolkit.clear();
      }
    },
    componentDidUpdate: function() {
      this._updateToolkit();
    },
    onNodeMoved: function(node_event) {
      if (this.ignoringEvents) {
        return ;
      }
      var x = node_event.extra.position.left;
      var y = node_event.extra.position.top;
      this.linkManager.moveNode(node_event.nodeKey, x, y);
      return true;
    },
    onNodeDeleted: function(node_event) {
      if (this.ignoringEvents) {
        return ;
      }
      this.linkManager.removeNode(node_event.nodeKey);
      return true;
    },
    handleConnect: function(info, evnt) {
      if (this.ignoringEvents) {
        return ;
      }
      this.linkManager.newLinkFromEvent(info, evnt);
      return true;
    },
    handleClick: function(connection, evnt) {
      if (this.ignoringEvents) {
        return ;
      }
      this.linkManager.selectLink(connection.linkModel);
    },
    handleLinkAdd: function(info, evnt) {
      var links = this.linkManager.getLinks();
      this.setState({links: links});
      return true;
    },
    handleLinkRm: function() {
      var links = this.linkManager.getLinks();
      this.setState({links: links});
    },
    handleNodeAdd: function(nodeData) {
      var nodes = this.linkManager.getNodes();
      this.setState({nodes: nodes});
      return true;
    },
    handleNodeMove: function(nodeData) {
      var nodes = this.linkManager.getNodes();
      this.setState({nodes: nodes});
      this.diagramToolkit.repaint();
      return true;
    },
    handleNodeRm: function() {
      var nodes = this.linkManager.getNodes();
      this.setState({nodes: nodes});
    },
    _nodeForName: function(name) {
      if (!this.refs[name]) {
        return false;
      }
      return this.refs[name].getDOMNode();
    },
    _updateNodeValue: function(name, key, value) {
      var changed = 0;
      var nodes = this.state.nodes;
      this.state.nodes.forEach(function(node) {
        if (node.key == name) {
          node[key] = value;
          changed = changed + 1;
        }
      });
      if (changed > 0) {
        this.setState({nodes: nodes});
      }
    },
    _bindDiagramToolkit: function() {
      var container = $(this.getDOMNode()).find(".container");
      var opts = {
        Container: container[0],
        handleConnect: this.handleConnect.bind(this),
        handleClick: this.handleClick.bind(this)
      };
      this.diagramToolkit = new DiagramTookkit(container, opts);
      this._updateToolkit();
    },
    _updateToolkit: function() {
      if (this.diagramToolkit) {
        this.ignoringEvents = true;
        this.diagramToolkit.supspendDrawing();
        this._redrawLinks();
        this._redrawTargets();
        this.diagramToolkit.resumeDrawing();
        this.ignoringEvents = false;
      }
    },
    _redrawTargets: function() {
      var targetSources = $(this.getDOMNode()).find(".elm");
      this.diagramToolkit.makeTarget(targetSources);
    },
    _redrawLinks: function() {
      var links = this.state.links;
      links.forEach(function(l) {
        var source = this._nodeForName(l.sourceNode.key);
        var target = this._nodeForName(l.targetNode.key);
        var label = l.title;
        var color = l.color;
        var sourceTerminal = (l.sourceTerminal == "a") ? "Top" : "Bottom";
        var targetTerminal = (l.targetTerminal == "a") ? "Top" : "Bottom";
        if (source && target) {
          this.diagramToolkit.addLink(source, target, label, color, sourceTerminal, targetTerminal, l);
        }
      }.bind(this));
    },
    render: function() {
      var moveHandler = this.onNodeMoved;
      var deleteHandler = this.onNodeDeleted;
      var linkManager = this.linkManager;
      var linkData = this.state.links;
      var nodeData = this.state.nodes;
      var nodes = this.state.nodes.map(function(node) {
        return (React.createElement(Node, {
          key: node.key,
          data: node,
          selected: node.selected,
          nodeKey: node.key,
          ref: node.key,
          onMove: moveHandler,
          onDelete: deleteHandler,
          linkManager: linkManager
        }));
      });
      return (React.createElement("div", {className: "link-view"}, React.createElement("div", {className: "container"}, nodes)));
    }
  });
  module.exports = LinkView;
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/DOMProperty", ["npm:react@0.12.2/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var invariant = require("npm:react@0.12.2/lib/invariant");
    function checkMask(value, bitmask) {
      return (value & bitmask) === bitmask;
    }
    var DOMPropertyInjection = {
      MUST_USE_ATTRIBUTE: 0x1,
      MUST_USE_PROPERTY: 0x2,
      HAS_SIDE_EFFECTS: 0x4,
      HAS_BOOLEAN_VALUE: 0x8,
      HAS_NUMERIC_VALUE: 0x10,
      HAS_POSITIVE_NUMERIC_VALUE: 0x20 | 0x10,
      HAS_OVERLOADED_BOOLEAN_VALUE: 0x40,
      injectDOMPropertyConfig: function(domPropertyConfig) {
        var Properties = domPropertyConfig.Properties || {};
        var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
        var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
        var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};
        if (domPropertyConfig.isCustomAttribute) {
          DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
        }
        for (var propName in Properties) {
          ("production" !== process.env.NODE_ENV ? invariant(!DOMProperty.isStandardName.hasOwnProperty(propName), 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property ' + '\'%s\' which has already been injected. You may be accidentally ' + 'injecting the same DOM property config twice, or you may be ' + 'injecting two configs that have conflicting property names.', propName) : invariant(!DOMProperty.isStandardName.hasOwnProperty(propName)));
          DOMProperty.isStandardName[propName] = true;
          var lowerCased = propName.toLowerCase();
          DOMProperty.getPossibleStandardName[lowerCased] = propName;
          if (DOMAttributeNames.hasOwnProperty(propName)) {
            var attributeName = DOMAttributeNames[propName];
            DOMProperty.getPossibleStandardName[attributeName] = propName;
            DOMProperty.getAttributeName[propName] = attributeName;
          } else {
            DOMProperty.getAttributeName[propName] = lowerCased;
          }
          DOMProperty.getPropertyName[propName] = DOMPropertyNames.hasOwnProperty(propName) ? DOMPropertyNames[propName] : propName;
          if (DOMMutationMethods.hasOwnProperty(propName)) {
            DOMProperty.getMutationMethod[propName] = DOMMutationMethods[propName];
          } else {
            DOMProperty.getMutationMethod[propName] = null;
          }
          var propConfig = Properties[propName];
          DOMProperty.mustUseAttribute[propName] = checkMask(propConfig, DOMPropertyInjection.MUST_USE_ATTRIBUTE);
          DOMProperty.mustUseProperty[propName] = checkMask(propConfig, DOMPropertyInjection.MUST_USE_PROPERTY);
          DOMProperty.hasSideEffects[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_SIDE_EFFECTS);
          DOMProperty.hasBooleanValue[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_BOOLEAN_VALUE);
          DOMProperty.hasNumericValue[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_NUMERIC_VALUE);
          DOMProperty.hasPositiveNumericValue[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_POSITIVE_NUMERIC_VALUE);
          DOMProperty.hasOverloadedBooleanValue[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_OVERLOADED_BOOLEAN_VALUE);
          ("production" !== process.env.NODE_ENV ? invariant(!DOMProperty.mustUseAttribute[propName] || !DOMProperty.mustUseProperty[propName], 'DOMProperty: Cannot require using both attribute and property: %s', propName) : invariant(!DOMProperty.mustUseAttribute[propName] || !DOMProperty.mustUseProperty[propName]));
          ("production" !== process.env.NODE_ENV ? invariant(DOMProperty.mustUseProperty[propName] || !DOMProperty.hasSideEffects[propName], 'DOMProperty: Properties that have side effects must use property: %s', propName) : invariant(DOMProperty.mustUseProperty[propName] || !DOMProperty.hasSideEffects[propName]));
          ("production" !== process.env.NODE_ENV ? invariant(!!DOMProperty.hasBooleanValue[propName] + !!DOMProperty.hasNumericValue[propName] + !!DOMProperty.hasOverloadedBooleanValue[propName] <= 1, 'DOMProperty: Value can be one of boolean, overloaded boolean, or ' + 'numeric value, but not a combination: %s', propName) : invariant(!!DOMProperty.hasBooleanValue[propName] + !!DOMProperty.hasNumericValue[propName] + !!DOMProperty.hasOverloadedBooleanValue[propName] <= 1));
        }
      }
    };
    var defaultValueCache = {};
    var DOMProperty = {
      ID_ATTRIBUTE_NAME: 'data-reactid',
      isStandardName: {},
      getPossibleStandardName: {},
      getAttributeName: {},
      getPropertyName: {},
      getMutationMethod: {},
      mustUseAttribute: {},
      mustUseProperty: {},
      hasSideEffects: {},
      hasBooleanValue: {},
      hasNumericValue: {},
      hasPositiveNumericValue: {},
      hasOverloadedBooleanValue: {},
      _isCustomAttributeFunctions: [],
      isCustomAttribute: function(attributeName) {
        for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
          var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
          if (isCustomAttributeFn(attributeName)) {
            return true;
          }
        }
        return false;
      },
      getDefaultValueForProperty: function(nodeName, prop) {
        var nodeDefaults = defaultValueCache[nodeName];
        var testElement;
        if (!nodeDefaults) {
          defaultValueCache[nodeName] = nodeDefaults = {};
        }
        if (!(prop in nodeDefaults)) {
          testElement = document.createElement(nodeName);
          nodeDefaults[prop] = testElement[prop];
        }
        return nodeDefaults[prop];
      },
      injection: DOMPropertyInjection
    };
    module.exports = DOMProperty;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDOMComponent", ["npm:react@0.12.2/lib/CSSPropertyOperations", "npm:react@0.12.2/lib/DOMProperty", "npm:react@0.12.2/lib/DOMPropertyOperations", "npm:react@0.12.2/lib/ReactBrowserComponentMixin", "npm:react@0.12.2/lib/ReactComponent", "npm:react@0.12.2/lib/ReactBrowserEventEmitter", "npm:react@0.12.2/lib/ReactMount", "npm:react@0.12.2/lib/ReactMultiChild", "npm:react@0.12.2/lib/ReactPerf", "npm:react@0.12.2/lib/Object.assign", "npm:react@0.12.2/lib/escapeTextForBrowser", "npm:react@0.12.2/lib/invariant", "npm:react@0.12.2/lib/isEventSupported", "npm:react@0.12.2/lib/keyOf", "npm:react@0.12.2/lib/monitorCodeUse", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var CSSPropertyOperations = require("npm:react@0.12.2/lib/CSSPropertyOperations");
    var DOMProperty = require("npm:react@0.12.2/lib/DOMProperty");
    var DOMPropertyOperations = require("npm:react@0.12.2/lib/DOMPropertyOperations");
    var ReactBrowserComponentMixin = require("npm:react@0.12.2/lib/ReactBrowserComponentMixin");
    var ReactComponent = require("npm:react@0.12.2/lib/ReactComponent");
    var ReactBrowserEventEmitter = require("npm:react@0.12.2/lib/ReactBrowserEventEmitter");
    var ReactMount = require("npm:react@0.12.2/lib/ReactMount");
    var ReactMultiChild = require("npm:react@0.12.2/lib/ReactMultiChild");
    var ReactPerf = require("npm:react@0.12.2/lib/ReactPerf");
    var assign = require("npm:react@0.12.2/lib/Object.assign");
    var escapeTextForBrowser = require("npm:react@0.12.2/lib/escapeTextForBrowser");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var isEventSupported = require("npm:react@0.12.2/lib/isEventSupported");
    var keyOf = require("npm:react@0.12.2/lib/keyOf");
    var monitorCodeUse = require("npm:react@0.12.2/lib/monitorCodeUse");
    var deleteListener = ReactBrowserEventEmitter.deleteListener;
    var listenTo = ReactBrowserEventEmitter.listenTo;
    var registrationNameModules = ReactBrowserEventEmitter.registrationNameModules;
    var CONTENT_TYPES = {
      'string': true,
      'number': true
    };
    var STYLE = keyOf({style: null});
    var ELEMENT_NODE_TYPE = 1;
    function assertValidProps(props) {
      if (!props) {
        return ;
      }
      ("production" !== process.env.NODE_ENV ? invariant(props.children == null || props.dangerouslySetInnerHTML == null, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : invariant(props.children == null || props.dangerouslySetInnerHTML == null));
      if ("production" !== process.env.NODE_ENV) {
        if (props.contentEditable && props.children != null) {
          console.warn('A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of those ' + 'nodes are unexpectedly modified or duplicated. This is probably not ' + 'intentional.');
        }
      }
      ("production" !== process.env.NODE_ENV ? invariant(props.style == null || typeof props.style === 'object', 'The `style` prop expects a mapping from style properties to values, ' + 'not a string.') : invariant(props.style == null || typeof props.style === 'object'));
    }
    function putListener(id, registrationName, listener, transaction) {
      if ("production" !== process.env.NODE_ENV) {
        if (registrationName === 'onScroll' && !isEventSupported('scroll', true)) {
          monitorCodeUse('react_no_scroll_event');
          console.warn('This browser doesn\'t support the `onScroll` event');
        }
      }
      var container = ReactMount.findReactContainerForID(id);
      if (container) {
        var doc = container.nodeType === ELEMENT_NODE_TYPE ? container.ownerDocument : container;
        listenTo(registrationName, doc);
      }
      transaction.getPutListenerQueue().enqueuePutListener(id, registrationName, listener);
    }
    var omittedCloseTags = {
      'area': true,
      'base': true,
      'br': true,
      'col': true,
      'embed': true,
      'hr': true,
      'img': true,
      'input': true,
      'keygen': true,
      'link': true,
      'meta': true,
      'param': true,
      'source': true,
      'track': true,
      'wbr': true
    };
    var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
    var validatedTagCache = {};
    var hasOwnProperty = {}.hasOwnProperty;
    function validateDangerousTag(tag) {
      if (!hasOwnProperty.call(validatedTagCache, tag)) {
        ("production" !== process.env.NODE_ENV ? invariant(VALID_TAG_REGEX.test(tag), 'Invalid tag: %s', tag) : invariant(VALID_TAG_REGEX.test(tag)));
        validatedTagCache[tag] = true;
      }
    }
    function ReactDOMComponent(tag) {
      validateDangerousTag(tag);
      this._tag = tag;
      this.tagName = tag.toUpperCase();
    }
    ReactDOMComponent.displayName = 'ReactDOMComponent';
    ReactDOMComponent.Mixin = {
      mountComponent: ReactPerf.measure('ReactDOMComponent', 'mountComponent', function(rootID, transaction, mountDepth) {
        ReactComponent.Mixin.mountComponent.call(this, rootID, transaction, mountDepth);
        assertValidProps(this.props);
        var closeTag = omittedCloseTags[this._tag] ? '' : '</' + this._tag + '>';
        return (this._createOpenTagMarkupAndPutListeners(transaction) + this._createContentMarkup(transaction) + closeTag);
      }),
      _createOpenTagMarkupAndPutListeners: function(transaction) {
        var props = this.props;
        var ret = '<' + this._tag;
        for (var propKey in props) {
          if (!props.hasOwnProperty(propKey)) {
            continue;
          }
          var propValue = props[propKey];
          if (propValue == null) {
            continue;
          }
          if (registrationNameModules.hasOwnProperty(propKey)) {
            putListener(this._rootNodeID, propKey, propValue, transaction);
          } else {
            if (propKey === STYLE) {
              if (propValue) {
                propValue = props.style = assign({}, props.style);
              }
              propValue = CSSPropertyOperations.createMarkupForStyles(propValue);
            }
            var markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
            if (markup) {
              ret += ' ' + markup;
            }
          }
        }
        if (transaction.renderToStaticMarkup) {
          return ret + '>';
        }
        var markupForID = DOMPropertyOperations.createMarkupForID(this._rootNodeID);
        return ret + ' ' + markupForID + '>';
      },
      _createContentMarkup: function(transaction) {
        var innerHTML = this.props.dangerouslySetInnerHTML;
        if (innerHTML != null) {
          if (innerHTML.__html != null) {
            return innerHTML.__html;
          }
        } else {
          var contentToUse = CONTENT_TYPES[typeof this.props.children] ? this.props.children : null;
          var childrenToUse = contentToUse != null ? null : this.props.children;
          if (contentToUse != null) {
            return escapeTextForBrowser(contentToUse);
          } else if (childrenToUse != null) {
            var mountImages = this.mountChildren(childrenToUse, transaction);
            return mountImages.join('');
          }
        }
        return '';
      },
      receiveComponent: function(nextElement, transaction) {
        if (nextElement === this._currentElement && nextElement._owner != null) {
          return ;
        }
        ReactComponent.Mixin.receiveComponent.call(this, nextElement, transaction);
      },
      updateComponent: ReactPerf.measure('ReactDOMComponent', 'updateComponent', function(transaction, prevElement) {
        assertValidProps(this._currentElement.props);
        ReactComponent.Mixin.updateComponent.call(this, transaction, prevElement);
        this._updateDOMProperties(prevElement.props, transaction);
        this._updateDOMChildren(prevElement.props, transaction);
      }),
      _updateDOMProperties: function(lastProps, transaction) {
        var nextProps = this.props;
        var propKey;
        var styleName;
        var styleUpdates;
        for (propKey in lastProps) {
          if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey)) {
            continue;
          }
          if (propKey === STYLE) {
            var lastStyle = lastProps[propKey];
            for (styleName in lastStyle) {
              if (lastStyle.hasOwnProperty(styleName)) {
                styleUpdates = styleUpdates || {};
                styleUpdates[styleName] = '';
              }
            }
          } else if (registrationNameModules.hasOwnProperty(propKey)) {
            deleteListener(this._rootNodeID, propKey);
          } else if (DOMProperty.isStandardName[propKey] || DOMProperty.isCustomAttribute(propKey)) {
            ReactComponent.BackendIDOperations.deletePropertyByID(this._rootNodeID, propKey);
          }
        }
        for (propKey in nextProps) {
          var nextProp = nextProps[propKey];
          var lastProp = lastProps[propKey];
          if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp) {
            continue;
          }
          if (propKey === STYLE) {
            if (nextProp) {
              nextProp = nextProps.style = assign({}, nextProp);
            }
            if (lastProp) {
              for (styleName in lastProp) {
                if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                  styleUpdates = styleUpdates || {};
                  styleUpdates[styleName] = '';
                }
              }
              for (styleName in nextProp) {
                if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                  styleUpdates = styleUpdates || {};
                  styleUpdates[styleName] = nextProp[styleName];
                }
              }
            } else {
              styleUpdates = nextProp;
            }
          } else if (registrationNameModules.hasOwnProperty(propKey)) {
            putListener(this._rootNodeID, propKey, nextProp, transaction);
          } else if (DOMProperty.isStandardName[propKey] || DOMProperty.isCustomAttribute(propKey)) {
            ReactComponent.BackendIDOperations.updatePropertyByID(this._rootNodeID, propKey, nextProp);
          }
        }
        if (styleUpdates) {
          ReactComponent.BackendIDOperations.updateStylesByID(this._rootNodeID, styleUpdates);
        }
      },
      _updateDOMChildren: function(lastProps, transaction) {
        var nextProps = this.props;
        var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
        var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;
        var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
        var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;
        var lastChildren = lastContent != null ? null : lastProps.children;
        var nextChildren = nextContent != null ? null : nextProps.children;
        var lastHasContentOrHtml = lastContent != null || lastHtml != null;
        var nextHasContentOrHtml = nextContent != null || nextHtml != null;
        if (lastChildren != null && nextChildren == null) {
          this.updateChildren(null, transaction);
        } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
          this.updateTextContent('');
        }
        if (nextContent != null) {
          if (lastContent !== nextContent) {
            this.updateTextContent('' + nextContent);
          }
        } else if (nextHtml != null) {
          if (lastHtml !== nextHtml) {
            ReactComponent.BackendIDOperations.updateInnerHTMLByID(this._rootNodeID, nextHtml);
          }
        } else if (nextChildren != null) {
          this.updateChildren(nextChildren, transaction);
        }
      },
      unmountComponent: function() {
        this.unmountChildren();
        ReactBrowserEventEmitter.deleteAllListeners(this._rootNodeID);
        ReactComponent.Mixin.unmountComponent.call(this);
      }
    };
    assign(ReactDOMComponent.prototype, ReactComponent.Mixin, ReactDOMComponent.Mixin, ReactMultiChild.Mixin, ReactBrowserComponentMixin);
    module.exports = ReactDOMComponent;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDOMIDOperations", ["npm:react@0.12.2/lib/CSSPropertyOperations", "npm:react@0.12.2/lib/DOMChildrenOperations", "npm:react@0.12.2/lib/DOMPropertyOperations", "npm:react@0.12.2/lib/ReactMount", "npm:react@0.12.2/lib/ReactPerf", "npm:react@0.12.2/lib/invariant", "npm:react@0.12.2/lib/setInnerHTML", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var CSSPropertyOperations = require("npm:react@0.12.2/lib/CSSPropertyOperations");
    var DOMChildrenOperations = require("npm:react@0.12.2/lib/DOMChildrenOperations");
    var DOMPropertyOperations = require("npm:react@0.12.2/lib/DOMPropertyOperations");
    var ReactMount = require("npm:react@0.12.2/lib/ReactMount");
    var ReactPerf = require("npm:react@0.12.2/lib/ReactPerf");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var setInnerHTML = require("npm:react@0.12.2/lib/setInnerHTML");
    var INVALID_PROPERTY_ERRORS = {
      dangerouslySetInnerHTML: '`dangerouslySetInnerHTML` must be set using `updateInnerHTMLByID()`.',
      style: '`style` must be set using `updateStylesByID()`.'
    };
    var ReactDOMIDOperations = {
      updatePropertyByID: ReactPerf.measure('ReactDOMIDOperations', 'updatePropertyByID', function(id, name, value) {
        var node = ReactMount.getNode(id);
        ("production" !== process.env.NODE_ENV ? invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name), 'updatePropertyByID(...): %s', INVALID_PROPERTY_ERRORS[name]) : invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name)));
        if (value != null) {
          DOMPropertyOperations.setValueForProperty(node, name, value);
        } else {
          DOMPropertyOperations.deleteValueForProperty(node, name);
        }
      }),
      deletePropertyByID: ReactPerf.measure('ReactDOMIDOperations', 'deletePropertyByID', function(id, name, value) {
        var node = ReactMount.getNode(id);
        ("production" !== process.env.NODE_ENV ? invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name), 'updatePropertyByID(...): %s', INVALID_PROPERTY_ERRORS[name]) : invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name)));
        DOMPropertyOperations.deleteValueForProperty(node, name, value);
      }),
      updateStylesByID: ReactPerf.measure('ReactDOMIDOperations', 'updateStylesByID', function(id, styles) {
        var node = ReactMount.getNode(id);
        CSSPropertyOperations.setValueForStyles(node, styles);
      }),
      updateInnerHTMLByID: ReactPerf.measure('ReactDOMIDOperations', 'updateInnerHTMLByID', function(id, html) {
        var node = ReactMount.getNode(id);
        setInnerHTML(node, html);
      }),
      updateTextContentByID: ReactPerf.measure('ReactDOMIDOperations', 'updateTextContentByID', function(id, content) {
        var node = ReactMount.getNode(id);
        DOMChildrenOperations.updateTextContent(node, content);
      }),
      dangerouslyReplaceNodeWithMarkupByID: ReactPerf.measure('ReactDOMIDOperations', 'dangerouslyReplaceNodeWithMarkupByID', function(id, markup) {
        var node = ReactMount.getNode(id);
        DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup(node, markup);
      }),
      dangerouslyProcessChildrenUpdates: ReactPerf.measure('ReactDOMIDOperations', 'dangerouslyProcessChildrenUpdates', function(updates, markup) {
        for (var i = 0; i < updates.length; i++) {
          updates[i].parentNode = ReactMount.getNode(updates[i].parentID);
        }
        DOMChildrenOperations.processUpdates(updates, markup);
      })
    };
    module.exports = ReactDOMIDOperations;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/DOMPropertyOperations", ["npm:react@0.12.2/lib/DOMProperty", "npm:react@0.12.2/lib/escapeTextForBrowser", "npm:react@0.12.2/lib/memoizeStringOnly", "npm:react@0.12.2/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var DOMProperty = require("npm:react@0.12.2/lib/DOMProperty");
    var escapeTextForBrowser = require("npm:react@0.12.2/lib/escapeTextForBrowser");
    var memoizeStringOnly = require("npm:react@0.12.2/lib/memoizeStringOnly");
    var warning = require("npm:react@0.12.2/lib/warning");
    function shouldIgnoreValue(name, value) {
      return value == null || (DOMProperty.hasBooleanValue[name] && !value) || (DOMProperty.hasNumericValue[name] && isNaN(value)) || (DOMProperty.hasPositiveNumericValue[name] && (value < 1)) || (DOMProperty.hasOverloadedBooleanValue[name] && value === false);
    }
    var processAttributeNameAndPrefix = memoizeStringOnly(function(name) {
      return escapeTextForBrowser(name) + '="';
    });
    if ("production" !== process.env.NODE_ENV) {
      var reactProps = {
        children: true,
        dangerouslySetInnerHTML: true,
        key: true,
        ref: true
      };
      var warnedProperties = {};
      var warnUnknownProperty = function(name) {
        if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
          return ;
        }
        warnedProperties[name] = true;
        var lowerCasedName = name.toLowerCase();
        var standardName = (DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null);
        ("production" !== process.env.NODE_ENV ? warning(standardName == null, 'Unknown DOM property ' + name + '. Did you mean ' + standardName + '?') : null);
      };
    }
    var DOMPropertyOperations = {
      createMarkupForID: function(id) {
        return processAttributeNameAndPrefix(DOMProperty.ID_ATTRIBUTE_NAME) + escapeTextForBrowser(id) + '"';
      },
      createMarkupForProperty: function(name, value) {
        if (DOMProperty.isStandardName.hasOwnProperty(name) && DOMProperty.isStandardName[name]) {
          if (shouldIgnoreValue(name, value)) {
            return '';
          }
          var attributeName = DOMProperty.getAttributeName[name];
          if (DOMProperty.hasBooleanValue[name] || (DOMProperty.hasOverloadedBooleanValue[name] && value === true)) {
            return escapeTextForBrowser(attributeName);
          }
          return processAttributeNameAndPrefix(attributeName) + escapeTextForBrowser(value) + '"';
        } else if (DOMProperty.isCustomAttribute(name)) {
          if (value == null) {
            return '';
          }
          return processAttributeNameAndPrefix(name) + escapeTextForBrowser(value) + '"';
        } else if ("production" !== process.env.NODE_ENV) {
          warnUnknownProperty(name);
        }
        return null;
      },
      setValueForProperty: function(node, name, value) {
        if (DOMProperty.isStandardName.hasOwnProperty(name) && DOMProperty.isStandardName[name]) {
          var mutationMethod = DOMProperty.getMutationMethod[name];
          if (mutationMethod) {
            mutationMethod(node, value);
          } else if (shouldIgnoreValue(name, value)) {
            this.deleteValueForProperty(node, name);
          } else if (DOMProperty.mustUseAttribute[name]) {
            node.setAttribute(DOMProperty.getAttributeName[name], '' + value);
          } else {
            var propName = DOMProperty.getPropertyName[name];
            if (!DOMProperty.hasSideEffects[name] || ('' + node[propName]) !== ('' + value)) {
              node[propName] = value;
            }
          }
        } else if (DOMProperty.isCustomAttribute(name)) {
          if (value == null) {
            node.removeAttribute(name);
          } else {
            node.setAttribute(name, '' + value);
          }
        } else if ("production" !== process.env.NODE_ENV) {
          warnUnknownProperty(name);
        }
      },
      deleteValueForProperty: function(node, name) {
        if (DOMProperty.isStandardName.hasOwnProperty(name) && DOMProperty.isStandardName[name]) {
          var mutationMethod = DOMProperty.getMutationMethod[name];
          if (mutationMethod) {
            mutationMethod(node, undefined);
          } else if (DOMProperty.mustUseAttribute[name]) {
            node.removeAttribute(DOMProperty.getAttributeName[name]);
          } else {
            var propName = DOMProperty.getPropertyName[name];
            var defaultValue = DOMProperty.getDefaultValueForProperty(node.nodeName, propName);
            if (!DOMProperty.hasSideEffects[name] || ('' + node[propName]) !== defaultValue) {
              node[propName] = defaultValue;
            }
          }
        } else if (DOMProperty.isCustomAttribute(name)) {
          node.removeAttribute(name);
        } else if ("production" !== process.env.NODE_ENV) {
          warnUnknownProperty(name);
        }
      }
    };
    module.exports = DOMPropertyOperations;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactComponentBrowserEnvironment", ["npm:react@0.12.2/lib/ReactDOMIDOperations", "npm:react@0.12.2/lib/ReactMarkupChecksum", "npm:react@0.12.2/lib/ReactMount", "npm:react@0.12.2/lib/ReactPerf", "npm:react@0.12.2/lib/ReactReconcileTransaction", "npm:react@0.12.2/lib/getReactRootElementInContainer", "npm:react@0.12.2/lib/invariant", "npm:react@0.12.2/lib/setInnerHTML", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var ReactDOMIDOperations = require("npm:react@0.12.2/lib/ReactDOMIDOperations");
    var ReactMarkupChecksum = require("npm:react@0.12.2/lib/ReactMarkupChecksum");
    var ReactMount = require("npm:react@0.12.2/lib/ReactMount");
    var ReactPerf = require("npm:react@0.12.2/lib/ReactPerf");
    var ReactReconcileTransaction = require("npm:react@0.12.2/lib/ReactReconcileTransaction");
    var getReactRootElementInContainer = require("npm:react@0.12.2/lib/getReactRootElementInContainer");
    var invariant = require("npm:react@0.12.2/lib/invariant");
    var setInnerHTML = require("npm:react@0.12.2/lib/setInnerHTML");
    var ELEMENT_NODE_TYPE = 1;
    var DOC_NODE_TYPE = 9;
    var ReactComponentBrowserEnvironment = {
      ReactReconcileTransaction: ReactReconcileTransaction,
      BackendIDOperations: ReactDOMIDOperations,
      unmountIDFromEnvironment: function(rootNodeID) {
        ReactMount.purgeID(rootNodeID);
      },
      mountImageIntoNode: ReactPerf.measure('ReactComponentBrowserEnvironment', 'mountImageIntoNode', function(markup, container, shouldReuseMarkup) {
        ("production" !== process.env.NODE_ENV ? invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE), 'mountComponentIntoNode(...): Target container is not valid.') : invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE)));
        if (shouldReuseMarkup) {
          if (ReactMarkupChecksum.canReuseMarkup(markup, getReactRootElementInContainer(container))) {
            return ;
          } else {
            ("production" !== process.env.NODE_ENV ? invariant(container.nodeType !== DOC_NODE_TYPE, 'You\'re trying to render a component to the document using ' + 'server rendering but the checksum was invalid. This usually ' + 'means you rendered a different component type or props on ' + 'the client from the one on the server, or your render() ' + 'methods are impure. React cannot handle this case due to ' + 'cross-browser quirks by rendering at the document root. You ' + 'should look for environment dependent code in your components ' + 'and ensure the props are the same client and server side.') : invariant(container.nodeType !== DOC_NODE_TYPE));
            if ("production" !== process.env.NODE_ENV) {
              console.warn('React attempted to use reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server.');
            }
          }
        }
        ("production" !== process.env.NODE_ENV ? invariant(container.nodeType !== DOC_NODE_TYPE, 'You\'re trying to render a component to the document but ' + 'you didn\'t use server rendering. We can\'t do this ' + 'without using server rendering due to cross-browser quirks. ' + 'See renderComponentToString() for server rendering.') : invariant(container.nodeType !== DOC_NODE_TYPE));
        setInnerHTML(container, markup);
      })
    };
    module.exports = ReactComponentBrowserEnvironment;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/ReactDefaultInjection", ["npm:react@0.12.2/lib/BeforeInputEventPlugin", "npm:react@0.12.2/lib/ChangeEventPlugin", "npm:react@0.12.2/lib/ClientReactRootIndex", "npm:react@0.12.2/lib/CompositionEventPlugin", "npm:react@0.12.2/lib/DefaultEventPluginOrder", "npm:react@0.12.2/lib/EnterLeaveEventPlugin", "npm:react@0.12.2/lib/ExecutionEnvironment", "npm:react@0.12.2/lib/HTMLDOMPropertyConfig", "npm:react@0.12.2/lib/MobileSafariClickEventPlugin", "npm:react@0.12.2/lib/ReactBrowserComponentMixin", "npm:react@0.12.2/lib/ReactComponentBrowserEnvironment", "npm:react@0.12.2/lib/ReactDefaultBatchingStrategy", "npm:react@0.12.2/lib/ReactDOMComponent", "npm:react@0.12.2/lib/ReactDOMButton", "npm:react@0.12.2/lib/ReactDOMForm", "npm:react@0.12.2/lib/ReactDOMImg", "npm:react@0.12.2/lib/ReactDOMInput", "npm:react@0.12.2/lib/ReactDOMOption", "npm:react@0.12.2/lib/ReactDOMSelect", "npm:react@0.12.2/lib/ReactDOMTextarea", "npm:react@0.12.2/lib/ReactEventListener", "npm:react@0.12.2/lib/ReactInjection", "npm:react@0.12.2/lib/ReactInstanceHandles", "npm:react@0.12.2/lib/ReactMount", "npm:react@0.12.2/lib/SelectEventPlugin", "npm:react@0.12.2/lib/ServerReactRootIndex", "npm:react@0.12.2/lib/SimpleEventPlugin", "npm:react@0.12.2/lib/SVGDOMPropertyConfig", "npm:react@0.12.2/lib/createFullPageComponent", "npm:react@0.12.2/lib/ReactDefaultPerf", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var BeforeInputEventPlugin = require("npm:react@0.12.2/lib/BeforeInputEventPlugin");
    var ChangeEventPlugin = require("npm:react@0.12.2/lib/ChangeEventPlugin");
    var ClientReactRootIndex = require("npm:react@0.12.2/lib/ClientReactRootIndex");
    var CompositionEventPlugin = require("npm:react@0.12.2/lib/CompositionEventPlugin");
    var DefaultEventPluginOrder = require("npm:react@0.12.2/lib/DefaultEventPluginOrder");
    var EnterLeaveEventPlugin = require("npm:react@0.12.2/lib/EnterLeaveEventPlugin");
    var ExecutionEnvironment = require("npm:react@0.12.2/lib/ExecutionEnvironment");
    var HTMLDOMPropertyConfig = require("npm:react@0.12.2/lib/HTMLDOMPropertyConfig");
    var MobileSafariClickEventPlugin = require("npm:react@0.12.2/lib/MobileSafariClickEventPlugin");
    var ReactBrowserComponentMixin = require("npm:react@0.12.2/lib/ReactBrowserComponentMixin");
    var ReactComponentBrowserEnvironment = require("npm:react@0.12.2/lib/ReactComponentBrowserEnvironment");
    var ReactDefaultBatchingStrategy = require("npm:react@0.12.2/lib/ReactDefaultBatchingStrategy");
    var ReactDOMComponent = require("npm:react@0.12.2/lib/ReactDOMComponent");
    var ReactDOMButton = require("npm:react@0.12.2/lib/ReactDOMButton");
    var ReactDOMForm = require("npm:react@0.12.2/lib/ReactDOMForm");
    var ReactDOMImg = require("npm:react@0.12.2/lib/ReactDOMImg");
    var ReactDOMInput = require("npm:react@0.12.2/lib/ReactDOMInput");
    var ReactDOMOption = require("npm:react@0.12.2/lib/ReactDOMOption");
    var ReactDOMSelect = require("npm:react@0.12.2/lib/ReactDOMSelect");
    var ReactDOMTextarea = require("npm:react@0.12.2/lib/ReactDOMTextarea");
    var ReactEventListener = require("npm:react@0.12.2/lib/ReactEventListener");
    var ReactInjection = require("npm:react@0.12.2/lib/ReactInjection");
    var ReactInstanceHandles = require("npm:react@0.12.2/lib/ReactInstanceHandles");
    var ReactMount = require("npm:react@0.12.2/lib/ReactMount");
    var SelectEventPlugin = require("npm:react@0.12.2/lib/SelectEventPlugin");
    var ServerReactRootIndex = require("npm:react@0.12.2/lib/ServerReactRootIndex");
    var SimpleEventPlugin = require("npm:react@0.12.2/lib/SimpleEventPlugin");
    var SVGDOMPropertyConfig = require("npm:react@0.12.2/lib/SVGDOMPropertyConfig");
    var createFullPageComponent = require("npm:react@0.12.2/lib/createFullPageComponent");
    function inject() {
      ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);
      ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
      ReactInjection.EventPluginHub.injectInstanceHandle(ReactInstanceHandles);
      ReactInjection.EventPluginHub.injectMount(ReactMount);
      ReactInjection.EventPluginHub.injectEventPluginsByName({
        SimpleEventPlugin: SimpleEventPlugin,
        EnterLeaveEventPlugin: EnterLeaveEventPlugin,
        ChangeEventPlugin: ChangeEventPlugin,
        CompositionEventPlugin: CompositionEventPlugin,
        MobileSafariClickEventPlugin: MobileSafariClickEventPlugin,
        SelectEventPlugin: SelectEventPlugin,
        BeforeInputEventPlugin: BeforeInputEventPlugin
      });
      ReactInjection.NativeComponent.injectGenericComponentClass(ReactDOMComponent);
      ReactInjection.NativeComponent.injectComponentClasses({
        'button': ReactDOMButton,
        'form': ReactDOMForm,
        'img': ReactDOMImg,
        'input': ReactDOMInput,
        'option': ReactDOMOption,
        'select': ReactDOMSelect,
        'textarea': ReactDOMTextarea,
        'html': createFullPageComponent('html'),
        'head': createFullPageComponent('head'),
        'body': createFullPageComponent('body')
      });
      ReactInjection.CompositeComponent.injectMixin(ReactBrowserComponentMixin);
      ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
      ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);
      ReactInjection.EmptyComponent.injectEmptyComponent('noscript');
      ReactInjection.Updates.injectReconcileTransaction(ReactComponentBrowserEnvironment.ReactReconcileTransaction);
      ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);
      ReactInjection.RootIndex.injectCreateReactRootIndex(ExecutionEnvironment.canUseDOM ? ClientReactRootIndex.createReactRootIndex : ServerReactRootIndex.createReactRootIndex);
      ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
      if ("production" !== process.env.NODE_ENV) {
        var url = (ExecutionEnvironment.canUseDOM && window.location.href) || '';
        if ((/[?&]react_perf\b/).test(url)) {
          var ReactDefaultPerf = require("npm:react@0.12.2/lib/ReactDefaultPerf");
          ReactDefaultPerf.start();
        }
      }
    }
    module.exports = {inject: inject};
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/lib/React", ["npm:react@0.12.2/lib/DOMPropertyOperations", "npm:react@0.12.2/lib/EventPluginUtils", "npm:react@0.12.2/lib/ReactChildren", "npm:react@0.12.2/lib/ReactComponent", "npm:react@0.12.2/lib/ReactCompositeComponent", "npm:react@0.12.2/lib/ReactContext", "npm:react@0.12.2/lib/ReactCurrentOwner", "npm:react@0.12.2/lib/ReactElement", "npm:react@0.12.2/lib/ReactElementValidator", "npm:react@0.12.2/lib/ReactDOM", "npm:react@0.12.2/lib/ReactDOMComponent", "npm:react@0.12.2/lib/ReactDefaultInjection", "npm:react@0.12.2/lib/ReactInstanceHandles", "npm:react@0.12.2/lib/ReactLegacyElement", "npm:react@0.12.2/lib/ReactMount", "npm:react@0.12.2/lib/ReactMultiChild", "npm:react@0.12.2/lib/ReactPerf", "npm:react@0.12.2/lib/ReactPropTypes", "npm:react@0.12.2/lib/ReactServerRendering", "npm:react@0.12.2/lib/ReactTextComponent", "npm:react@0.12.2/lib/Object.assign", "npm:react@0.12.2/lib/deprecated", "npm:react@0.12.2/lib/onlyChild", "npm:react@0.12.2/lib/ExecutionEnvironment", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var DOMPropertyOperations = require("npm:react@0.12.2/lib/DOMPropertyOperations");
    var EventPluginUtils = require("npm:react@0.12.2/lib/EventPluginUtils");
    var ReactChildren = require("npm:react@0.12.2/lib/ReactChildren");
    var ReactComponent = require("npm:react@0.12.2/lib/ReactComponent");
    var ReactCompositeComponent = require("npm:react@0.12.2/lib/ReactCompositeComponent");
    var ReactContext = require("npm:react@0.12.2/lib/ReactContext");
    var ReactCurrentOwner = require("npm:react@0.12.2/lib/ReactCurrentOwner");
    var ReactElement = require("npm:react@0.12.2/lib/ReactElement");
    var ReactElementValidator = require("npm:react@0.12.2/lib/ReactElementValidator");
    var ReactDOM = require("npm:react@0.12.2/lib/ReactDOM");
    var ReactDOMComponent = require("npm:react@0.12.2/lib/ReactDOMComponent");
    var ReactDefaultInjection = require("npm:react@0.12.2/lib/ReactDefaultInjection");
    var ReactInstanceHandles = require("npm:react@0.12.2/lib/ReactInstanceHandles");
    var ReactLegacyElement = require("npm:react@0.12.2/lib/ReactLegacyElement");
    var ReactMount = require("npm:react@0.12.2/lib/ReactMount");
    var ReactMultiChild = require("npm:react@0.12.2/lib/ReactMultiChild");
    var ReactPerf = require("npm:react@0.12.2/lib/ReactPerf");
    var ReactPropTypes = require("npm:react@0.12.2/lib/ReactPropTypes");
    var ReactServerRendering = require("npm:react@0.12.2/lib/ReactServerRendering");
    var ReactTextComponent = require("npm:react@0.12.2/lib/ReactTextComponent");
    var assign = require("npm:react@0.12.2/lib/Object.assign");
    var deprecated = require("npm:react@0.12.2/lib/deprecated");
    var onlyChild = require("npm:react@0.12.2/lib/onlyChild");
    ReactDefaultInjection.inject();
    var createElement = ReactElement.createElement;
    var createFactory = ReactElement.createFactory;
    if ("production" !== process.env.NODE_ENV) {
      createElement = ReactElementValidator.createElement;
      createFactory = ReactElementValidator.createFactory;
    }
    createElement = ReactLegacyElement.wrapCreateElement(createElement);
    createFactory = ReactLegacyElement.wrapCreateFactory(createFactory);
    var render = ReactPerf.measure('React', 'render', ReactMount.render);
    var React = {
      Children: {
        map: ReactChildren.map,
        forEach: ReactChildren.forEach,
        count: ReactChildren.count,
        only: onlyChild
      },
      DOM: ReactDOM,
      PropTypes: ReactPropTypes,
      initializeTouchEvents: function(shouldUseTouch) {
        EventPluginUtils.useTouchEvents = shouldUseTouch;
      },
      createClass: ReactCompositeComponent.createClass,
      createElement: createElement,
      createFactory: createFactory,
      constructAndRenderComponent: ReactMount.constructAndRenderComponent,
      constructAndRenderComponentByID: ReactMount.constructAndRenderComponentByID,
      render: render,
      renderToString: ReactServerRendering.renderToString,
      renderToStaticMarkup: ReactServerRendering.renderToStaticMarkup,
      unmountComponentAtNode: ReactMount.unmountComponentAtNode,
      isValidClass: ReactLegacyElement.isValidClass,
      isValidElement: ReactElement.isValidElement,
      withContext: ReactContext.withContext,
      __spread: assign,
      renderComponent: deprecated('React', 'renderComponent', 'render', this, render),
      renderComponentToString: deprecated('React', 'renderComponentToString', 'renderToString', this, ReactServerRendering.renderToString),
      renderComponentToStaticMarkup: deprecated('React', 'renderComponentToStaticMarkup', 'renderToStaticMarkup', this, ReactServerRendering.renderToStaticMarkup),
      isValidComponent: deprecated('React', 'isValidComponent', 'isValidElement', this, ReactElement.isValidElement)
    };
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
        Component: ReactComponent,
        CurrentOwner: ReactCurrentOwner,
        DOMComponent: ReactDOMComponent,
        DOMPropertyOperations: DOMPropertyOperations,
        InstanceHandles: ReactInstanceHandles,
        Mount: ReactMount,
        MultiChild: ReactMultiChild,
        TextComponent: ReactTextComponent
      });
    }
    if ("production" !== process.env.NODE_ENV) {
      var ExecutionEnvironment = require("npm:react@0.12.2/lib/ExecutionEnvironment");
      if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
        if (navigator.userAgent.indexOf('Chrome') > -1) {
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
            console.debug('Download the React DevTools for a better development experience: ' + 'http://fb.me/react-devtools');
          }
        }
        var expectedFeatures = [Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.split, String.prototype.trim, Object.create, Object.freeze];
        for (var i = 0; i < expectedFeatures.length; i++) {
          if (!expectedFeatures[i]) {
            console.error('One or more ES5 shim/shams expected by React are not available: ' + 'http://fb.me/react-warning-polyfills');
            break;
          }
        }
      }
    }
    React.version = '0.12.2';
    module.exports = React;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2/react", ["npm:react@0.12.2/lib/React"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:react@0.12.2/lib/React");
  global.define = __define;
  return module.exports;
});



System.register("npm:react@0.12.2", ["npm:react@0.12.2/react"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:react@0.12.2/react");
  global.define = __define;
  return module.exports;
});



System.register("javascripts/app-view", ["npm:react@0.12.2", "javascripts/info-pane", "javascripts/link-view", "javascripts/node-well-view", "javascripts/node-edit-view", "javascripts/link-edit-view", "javascripts/status-menu-view", "javascripts/models/link-manager", "npm:lodash@3.3.1", "npm:loglevel@1.2.0", "javascripts/vendor/touchpunch"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var React = require("npm:react@0.12.2");
  var InfoPane = require("javascripts/info-pane");
  var LinkView = require("javascripts/link-view");
  var NodeWell = require("javascripts/node-well-view");
  var NodeEditView = require("javascripts/node-edit-view");
  var LinkEditView = require("javascripts/link-edit-view");
  var StatusMenu = require("javascripts/status-menu-view");
  var LinkManager = require("javascripts/models/link-manager");
  var _ = require("npm:lodash@3.3.1");
  var log = require("npm:loglevel@1.2.0");
  var $ = require("javascripts/vendor/touchpunch");
  log.setLevel(log.levels.TRACE);
  var AppView = React.createClass({
    displayName: "AppView",
    getInitialState: function() {
      var state = {
        selectedNode: null,
        selectedConnection: null
      };
      return state;
    },
    componentWillUpdate: function() {},
    componentDidUpdate: function() {
      log.info("Did Update: AppView ");
    },
    setupDeleteKeyHandler: function(linkManager) {
      var deleteFunction = linkManager.deleteSelected.bind(linkManager);
      $(document).on("keyup", function(e) {
        if (e.which === 8 && !$(e.target).is("input, textarea")) {
          e.preventDefault();
          deleteFunction();
        }
      });
    },
    componentDidMount: function() {
      var linkManager = this.props.linkManager;
      var data = this.props.data;
      this.setupDeleteKeyHandler(linkManager);
      linkManager.addSelectionListener(function(selections) {
        var selectedNode = selections.node;
        var selectedConnection = selections.connection;
        this.setState({selectedNode: selectedNode});
        this.setState({selectedConnection: selectedConnection});
        log.info("updated selections: + selections");
      }.bind(this));
      if (data && data.length > 0) {
        linkManager.loadData(JSON.parse(data));
      } else {
        linkManager.loadDataFromUrl(this.props.url);
      }
    },
    getData: function() {
      var linkManager = this.props.linkManager;
      return linkManager.toJsonString();
    },
    render: function() {
      var linkManager = this.props.linkManager;
      var selectedNode = this.state.selectedNode;
      var selectedConnection = this.state.selectedConnection;
      var onNodeChanged = function(node, title, image) {
        linkManager.changeNode(title, image);
      }.bind(this);
      var onLinkChanged = function(link, title, color, deleted) {
        linkManager.changeLink(title, color, deleted);
      };
      var getData = this.getData.bind(this);
      return (React.createElement("div", {className: "app"}, React.createElement(StatusMenu, {getData: getData}), React.createElement(LinkView, {linkManager: linkManager}), React.createElement("div", {className: "bottomTools"}, React.createElement(NodeWell, null), React.createElement(NodeEditView, {
        node: selectedNode,
        onNodeChanged: onNodeChanged
      }), React.createElement(LinkEditView, {
        link: selectedConnection,
        onLinkChanged: onLinkChanged
      }))));
    }
  });
  var linkManager = LinkManager.instance('building-models');
  var url = "serialized.json";
  function getParameterByName(name) {
    name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
    var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"),
        results = regex.exec(location.search);
    return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
  }
  jsPlumb.bind("ready", function() {
    var data = getParameterByName('data');
    React.render(React.createElement(AppView, {
      url: url,
      linkManager: linkManager,
      data: data
    }), $('#app')[0]);
  });
  module.exports = AppView;
  global.define = __define;
  return module.exports;
});



(function() {
  var loader = System;
  var hasOwnProperty = loader.global.hasOwnProperty;
  var moduleGlobals = {};
  var curGlobalObj;
  var ignoredGlobalProps;
  if (typeof indexOf == 'undefined')
    indexOf = Array.prototype.indexOf;
  System.set("@@global-helpers", System.newModule({
    prepareGlobal: function(moduleName, deps) {
      for (var i = 0; i < deps.length; i++) {
        var moduleGlobal = moduleGlobals[deps[i]];
        if (moduleGlobal)
          for (var m in moduleGlobal)
            loader.global[m] = moduleGlobal[m];
      }
      curGlobalObj = {};
      ignoredGlobalProps = ["indexedDB", "sessionStorage", "localStorage", "clipboardData", "frames", "webkitStorageInfo"];
      for (var g in loader.global) {
        if (indexOf.call(ignoredGlobalProps, g) != -1) { continue; }
        if (!hasOwnProperty || loader.global.hasOwnProperty(g)) {
          try {
            curGlobalObj[g] = loader.global[g];
          } catch (e) {
            ignoredGlobalProps.push(g);
          }
        }
      }
    },
    retrieveGlobal: function(moduleName, exportName, init) {
      var singleGlobal;
      var multipleExports;
      var exports = {};
      if (init) {
        var depModules = [];
        for (var i = 0; i < deps.length; i++)
          depModules.push(require(deps[i]));
        singleGlobal = init.apply(loader.global, depModules);
      }
      else if (exportName) {
        var firstPart = exportName.split(".")[0];
        singleGlobal = eval.call(loader.global, exportName);
        exports[firstPart] = loader.global[firstPart];
      }
      else {
        for (var g in loader.global) {
          if (indexOf.call(ignoredGlobalProps, g) != -1)
            continue;
          if ((!hasOwnProperty || loader.global.hasOwnProperty(g)) && g != loader.global && curGlobalObj[g] != loader.global[g]) {
            exports[g] = loader.global[g];
            if (singleGlobal) {
              if (singleGlobal !== loader.global[g])
                multipleExports = true;
            }
            else if (singleGlobal !== false) {
              singleGlobal = loader.global[g];
            }
          }
        }
      }
      moduleGlobals[moduleName] = exports;
      return multipleExports ? exports : singleGlobal;
    }
  }));
})();

});
//# sourceMappingURL=app.js.map