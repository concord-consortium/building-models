### PBI-2: Simulation Control via API

#### Problem Statement

SageModeler currently requires the user to click the “Run” button to execute a simulation. External tools need the ability to programmatically start a simulation (and possibly configure it) to integrate SageModeler into automated workflows or combined activities. This PBI delivers the capability to trigger model simulations through the API and be notified when simulations start and finish. The main challenge is ensuring that starting a simulation via code behaves exactly as a user-initiated run: the simulation should run to completion with the same timing and produce the same data (populating CODAP data context). We also must handle attempts to run a simulation when one is already running (concurrency control) and provide feedback events for simulation status.

#### User Stories

* *As a plugin developer*, I want to initiate the SageModeler model’s simulation run via an API call (optionally specifying parameters like duration or step size) so that I can automate experiments and gather results without manual user action.  
* *As a plugin developer*, I want to know when a simulation has started and completed via the API (see PBI-3 for events) so that I can perform actions at those milestones (e.g., retrieve output data when done).  
* *As a plugin developer*, I need the API to prevent or signal if a simulation cannot be started (for example, if one is already in progress) to avoid conflicting operations.

#### Technical Approach & Architecture

We will expose a **`runSimulation` command** in the API. The PRD suggests using a `call` action or similar (since simulation isn’t CRUD on an entity). We will likely implement it as `action:"call", resource:"simulation"` or perhaps as `action:"update", resource:"simulation"` – but “call” fits a procedure. This command may accept optional parameters (e.g., number of timesteps, or duration). The SageModeler code has a SimulationStore that manages running the simulation. In particular, it defines `SimulationActions.runSimulation` (synchronous action) and an `onRunSimulation` handler in SimulationStore that calls a private `_runSimulation()`. To start a simulation programmatically, we will invoke the same mechanism the UI uses: dispatch the Reflux action `SimulationActions.runSimulation`.

Specifically, the UI run button triggers either `SimulationActions.expandSimulationPanel` or directly `SimulationActions.runSimulation` depending on context. The safest method is to call `SimulationActions.runSimulation()` which the store listens to (synchronously) and triggers `_runSimulation()`. `_runSimulation` sets `modelIsRunning=true`, iterates the model’s computation for the configured duration, records data to CODAP, and then triggers `SimulationActions.simulationEnded` when done. Also, it triggers `SimulationActions.simulationStarted` at the beginning (not explicitly visible in snippet, but likely done when expanding panel or setting up).

So our API handler will essentially call the same code path. We can achieve this by either:

* Importing `SimulationActions` and calling `SimulationActions.runSimulation()` directly. This will kick off the process within the same event loop tick (since runSimulation is sync as defined). However, doing so means our API call handler is initiating simulation in-process. We must be mindful that simulation (if it's time-based) might not block the thread (it could use asynchronous timing or yield via setTimeouts if dynamic simulation is chosen). Actually, SageModeler supports two simulation modes: static (one-step calculation, for CLD, which is instantaneous) and time-based (multiple steps over time if stocks/flows). The code suggests static vs time-based differences. In static mode, runSimulation might complete near instantly. In time-based, it may schedule frames (maybe using `setTimeout` for each step). In either case, they signal completion via `SimulationActions.simulationEnded` at end.  
* Alternatively, we could simulate a click via `CodapConnect` or something, but easier is to call the actions.

We'll call `SimulationActions.runSimulation()` to start. Optionally, if user provided parameters (like a different duration or step count), we can set those before running:

* SimulationStore has actions like `SimulationActions.setDuration` to set number of steps, `SimulationActions.setStepUnits` etc.. If `message.values` includes parameters (like `duration` steps or a time unit), we will dispatch those actions prior to run. For example, if `values.duration` is provided as a number of steps, call `SimulationActions.setDuration(duration)`. If `values.timeUnit` is provided (say "month" vs "year"), call `SimulationActions.setStepUnits(unit)`. We'll have to interpret what optional parameters we want to support. The PRD mentions "optional parameters" but not specifics. Potentially, parameters could be simulation length (duration), and toggling recording or not, but likely just duration. We'll implement at least `duration`.  
* If none provided, simulation runs with whatever settings are currently in the model (which might have a default duration from model settings).

We must also implement a **busy flag** to avoid running a new simulation if one is already in progress. The PRD explicitly calls for a "Busy-flag prevents concurrent mutations" meaning if simulation running, block other commands. Our PBI-6 covers concurrency broadly. For simulation specifically:

* If simulation is currently running (we can check `SimulationStore.settings.modelIsRunning` or maintain our own flag that we set true on run start and false on end event), then if another run command comes, we should return an error or at least a rejection ("Simulation already in progress"). We'll implement that here or as part of busy-flag in PBI-6. Likely in PBI-6 we introduce a global busy flag for the entire API. So here, we'll ensure to set/unset it.  
* The simulation store actually has `modelIsRunning` state. We can query `SimulationStore.settings.modelIsRunning` (if accessible) to know if running. Or simply track if a `runSimulation` has been requested and not completed (set a flag in our API handler context). Probably better to rely on SimulationStore, but it might not expose a simple getter unless we access its internals. Alternatively, our event handling for simulation events (in PBI-3 tasks) can toggle a flag in the SageAPI when simulation starts and ends. We'll coordinate with that: e.g., when simulationStarted event is caught, set busy=true; when simulationEnded event caught, set busy=false. In absence of events, we could perhaps hook `SimulationActions.simulationStarted.listen()` here, but easier to integrate with event broadcasting system.  
* For now, we’ll do a quick check: if our own `sageApi` module has a `simulationRunning` flag and it's true, respond with error "Simulation already running". We'll set that flag when we dispatch run and clear it either via event or a timeout. Actually, the simulation could take some (short) time; better to rely on events to clear it. We can integrate with PBI-3 event where simulation events are emitted. So assume that’s in place by the time concurrency is fully implemented.

Finally, the command returns immediately with an acknowledgment (the simulation will be running asynchronously). PRD says each incoming command returns ACK within 200ms, so we do return success straight away after triggering run, not waiting for completion. The plugin will rely on the `simulationCompleted` event to know it’s done.

#### Acceptance Criteria

* **Start Simulation via API**: Sending a `runSimulation` request through the API causes the SageModeler simulation to begin. For example, an API message like `{action:"call", resource:"simulation"}` (with optional params) should result in SageModeler behaving as if the user pressed "Run": the simulation runs using the model’s current parameters. The response to this command is returned immediately (within a few hundred ms) indicating success (not waiting for full simulation to finish). SageModeler then emits a `simulationStarted` event at the start and a `simulationCompleted` event when done (per PBI-3).  
* **Parameter Handling**: If the API request includes parameters like `duration` (number of time units or steps), `timeStep` (size of each step) or others, the simulation uses these settings. E.g., if `duration: 50` is provided, the simulation runs for 50 steps (overriding the model’s default duration). These parameters mirror SageModeler’s UI controls (duration slider, time unit selector). If invalid values are given (e.g., negative duration), the API returns an error response explaining the issue and does not start a simulation.  
* **No Concurrent Runs**: The API will not initiate a second simulation if one is already running. If a `runSimulation` command is received while a simulation is in progress, the API responds with `success:false` and an error (e.g., "Simulation already in progress") and ignores the request. The ongoing simulation continues unaffected.  
* **Consistent Outcomes**: A simulation started via API produces the same outcome/data as one started via the UI. For instance, CODAP’s data table is populated with the same results. After the API-initiated run completes, the model’s state (any final values or experiment number increments) is updated just as with a manual run.  
* **Busy Feedback**: During an ongoing simulation (triggered by API or UI), other API commands that would modify the model (e.g., adding nodes) are blocked (this is covered by the global busy flag in PBI-6, but specifically, additional `runSimulation` calls are blocked as above).

#### Related Tasks

* **Task 2-1:** Implement Run Simulation API Command (including parameter parsing and busy state) *(No other tasks in PBI-2; simulation events are covered in PBI-3, busy flag in PBI-6.)*