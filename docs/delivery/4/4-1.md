#### Task 4-1: Implement Message Listener and Dispatcher

##### Description

Set up the `window.addEventListener("message", ...)` in the SageModeler iframe to listen for external API requests. Dispatch incoming messages to the appropriate internal functions based on the action and resource specified.

##### Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
| :---- | :---- | :---- | :---- | :---- | :---- |
| 2025-06-22 17:44:00 | Created | N/A | Proposed | Task drafted (PBI-4 core) | Chad |

##### Requirements

* Attach an event listener on `window` for `"message"` events.  
    
* In the callback, filter events:  
    
  * If `event.source !== window.parent`, ignore (not from CODAP host).  
  * If `!event.data` or `!event.data.sageApi`, ignore (not an API message).


* Parse the message structure:  
    
  * Expect fields: `action` (string), `resource` (string), `values` (object optional), `requestId` (string optional).  
      
  * Determine the intended operation:  
      
    * For `action: "create"` with resource starts with `"nodes"` or `"links"`, call node or link creation.  
        
      * Possibly resource could be exactly `"nodes"` or `"links"` for adding new, or include an id which doesn't make sense for create (create uses plural without id).

      

    * For `action: "update"` or `"delete"` on `"nodes/{id}"` or `"links/{id}"`, parse id and call update or delete accordingly.  
        
    * For `action: "get", resource:"model"`, call getModel.  
        
    * For `action: "update", resource:"model"`, call loadModel (for model import).  
        
    * For `action: "call", resource:"simulation"`, call runSimulation.

    

  * If resource patterns are different (like maybe they could use singular forms "node" etc., but we can assume plural naming).  
      
  * Possibly use a mapping: e.g.,  
      
    * `("create","nodes") -> handleCreateNode`  
    * `("update","nodes/{id}") -> handleUpdateNode`  
    * `("delete","nodes/{id}") -> handleDeleteNode`  
    * `("create","links") -> handleCreateLink`  
    * etc.

    

  * Use string operations or regex to extract {id} if present (like if resource matches /^nodes/(.+)$/ then RegExp.$1 is id).


* Unknown combinations:  
    
  * If action is not one of known, or resource is not recognized pattern, we should prepare an error response (like "Unknown command").


* For known mapping, prepare to call the corresponding function (which we have in our tasks).  
    
* We'll likely have references to these handler functions (we can define them in our module or they might be methods in tasks).  
    
  * E.g., we might have a function `handleCreateNode(message)` from Task 1-1. Actually, in tasks above, we wrote them conceptually, but in code we might implement them either as separate functions or inline in this dispatch. Possibly separate for clarity.  
  * To implement, we might incorporate them directly in this module as internal functions for each PBI, which we have effectively described. Let's assume we've implemented them above (like in code we would have `function createNode(values) { ... }` etc. We'll use those).


* Once identified, delegate:  
    
  * Possibly wrap the call in `try { ... } catch(e) { ... }`.  
      
  * For each function, it likely returns an object or nothing. We have designed them to either throw or capture error to return as well. We should unify how handlers signal outcome:  
      
    * In tasks, we had them building responses or data. Perhaps we should design each handler to return an object of format { success: bool, data?:..., error?:... } so we can easily use that.  
        
    * Or they could throw on error which we catch.  
        
    * But from our tasks above, e.g., Task 1-1 might directly post responses or such. Actually, we ended each with building response and presumably sending it right away? Wait, in tasks, at the end of each, we described response sending, but likely we ended them at an earlier stage. However, in our integrated code, we wouldn't have sent a response in the handler itself because we centralize response sending here.  
        
    * So maybe we should adapt: have handlers perform the operation and then either:  
        
      * Return some data (on success) or  
      * Throw an error or return a special object indicating error.

      

    * Example: `handleCreateNode` could try to add node and if success, return something like `{ id: newNodeId }` maybe to include in data (if we want).  
        
    * If error (like missing title), it could throw a new Error("Node title required") or return a { error: "..."} object. Throw is clearer for control flow.  
        
    * We'll implement handlers to throw exceptions for invalid scenarios (they already check and throw or we can throw).  
        
    * Then in dispatch, we catch and treat as error.  
        
    * Alternatively, we could have handlers themselves create and send responses. But better to centralize response formatting and sending here for consistency (plus to ensure requestId and success unified).  
        
    * So we should refactor tasks above accordingly: ensure handlers don't post message themselves (except events are separate concept), just do model changes and return needed info.  
        
    * Many tasks above ended with "Construct response and send". That sending will now be done here, so we adjust: the handler can return any result needed for response data.  
        
    * Specifically:  
        
      * Create node could return maybe the created node's id or object; we might not strictly need to return anything for create other than success (maybe new node id is nice to confirm, but plugin might get it via events anyway).  
      * Update or delete node: maybe no needed return (maybe just confirm success).  
      * getModel: returns the model object.  
      * loadModel: could return something (we thought maybe nodeCount, but not required).  
      * runSimulation: maybe return duration as we considered or nothing.  
      * If no output needed, they could just return undefined (we'll interpret that as success with no data).  
      * They will throw if something goes wrong (like duplicate name etc. or busy).

      

    * We'll implement accordingly.


* After calling handler:  
    
  * If it returns without throwing:  
      
    * Compose success response: success:true, data: \[if handler returned something, put it here; if no return, data can be {} or we might omit data field\].

    

  * If it threw an Error or we got an object marking error:  
      
    * Compose error response: success:false, data: { error: error.message }.

    

  * Use the requestId from the original message if present (if not present, we can still send a response but requestId might be undefined; maybe still include it as undefined? Or skip it. Probably include it only if provided).


* Send the response via postMessage.  
    
* Then break (no further processing for that message).  
    
* This covers one message. The listener will continue for future messages.

##### Testing

* This is central; our unit tests of each handler indirectly tested parts, but here we test the integration:  
    
  * Simulate receiving a message event:  
      
    * We can directly call our message event handler function with a dummy event object containing data fields. E.g., simulate `event = { source: window.parent, data: { sageApi:true, action:"create", resource:"nodes", values:{ title:"X"}, requestId:"123"} }` and ensure:  
        
      * It calls handleCreateNode, which does the operation.  
      * It then sends a response message (we can spy on postMessage to capture output).  
      * The output should have requestId "123", success:true, maybe data with new node id (if we decided to include id).

      

    * Simulate an invalid message:  
        
      * event with missing resource or unknown action. We expect either no response or an error response. We should decide:  
          
        * It's likely better to send an error response ("Unknown command") because the plugin set sageApi:true expecting something, so silence might be confusing. Yes, send error response for unknown.

        

      * So test e.g., action:"foo" unknown \=\> respond error.  
          
      * Wrong format: e.g., create nodes but no values or no title in values \=\> our handler should throw "Node title is required", which we catch and respond error.  
          
      * Not sageApi message \=\> should be ignored (we can simulate and ensure no response).

      

    * Simulate concurrency:  
        
      * e.g., set simulationRunningFlag true (simulate busy) and send a create node command: \=\> The dispatcher should catch busy and respond error "Simulation in progress" (or similar).  
      * Test that read command isn't blocked: if busy and we send getModel, we should allow it and get success (assuming our busy check only blocks writes, we must implement accordingly).

      

    * If possible, simulate origin check: call handler with event.source being some dummy (not window.parent). Then it should not call any handler or send a response. That might be tricky to verify because how to know if no response? We could spy on postMessage and ensure not called. Do that: before calling, set spy on window.parent.postMessage (or rather on our local window? Actually, we call window.parent.postMessage. We need to intercept that. Possibly we can monkey patch window.parent.postMessage to a spy function for test).  
        
      * But window.parent in test environment might be a fake object. Alternatively, our broadcastEvent and response sending uses window.parent... we can spy on that function by replacing it in global context in test. Possibly doable.  
      - Or simpler: instruct that check and assume manual review that code is in place.

      

    * Multi-step scenario:  
        
      * e.g., send create node \-\> get immediate response and presumably event system will later broadcast nodeAdded. The plugin in real life sees both. Not test directly needed here (since events tested separately).

    

  * Integration: likely not adding new beyond what our integrated tests would confirm.


* We should also test one scenario with requestId:  
    
  * If requestId missing, our code should still send a response but without requestId (or we might generate one? Usually not, it says requestId is for correlation, if not given, we might not include it).  
  * Let's choose: if requestId not present in incoming, we'll omit it in response. Or could generate a random just for reference. But likely simpler to omit.  
  * It's corner because spec expects a requestId in requests from plugin if they want correlation, plugin should always send one. If they don't, not our fault; we can still respond, but correlation is moot. We'll still send a response with no requestId (or maybe we could include none, but leaving out the field might be best).  
  * So test: send a message with no requestId and see response has no requestId property.  
  * Another test: if plugin sends requestId but we cannot parse message (like unknown command), we should still echo requestId in error response so plugin knows which request failed.  
  * Our code should ensure to include requestId in any response if it was present in request, error or success.  
  * So test unknown action with requestId "abc" yields response with requestId "abc", success:false error "Unknown action".

##### Files Modified

* `src/code/sage-api.ts` â€“ Implement the `window.addEventListener("message", onMessage)` in the module initialization. Within `onMessage`, implement logic as described.  
    
* Possibly incorporate `ajv`:  
    
  * If time, define JSON schemas for each command:  
      
    * We could have an overarching schema using oneOf for each action type and resource pattern. That might be too heavy. Alternatively, manually check fields.  
    * Given time, likely we do manual checks (like if (action=="create" && resource=="nodes") ensure values.title is string).

    

  * So not heavily use `ajv`, though having it wouldn't hurt. PRD suggests it, but for brevity, we might skip formal schemas and just ensure correctness via our own conditions.


* This encompasses tasks 4-2, 4-3, 4-4 effectively in one code block with conditional logic.