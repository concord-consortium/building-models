#### Task 3-5: Implement Event Throttle (10 Hz limit) \[*Optional/Planned*\]

##### Description

Introduce a mechanism to throttle event broadcasts if changes occur too frequently, to satisfy performance requirements (no more than \~10 events per second). In practice, this primarily concerns rapid `nodeUpdated` events (e.g., slider moves) or potential future simulation progress events.

##### Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
| :---- | :---- | :---- | :---- | :---- | :---- |
| 2025-06-22 17:43:00 | Created | N/A | Proposed | Task drafted (PBI-3, throttling) | Chad |

##### Requirements

* Ensure that the frequency of events does not exceed about 10 per second during bursts of changes.  
    
* The throttle should ideally skip intermediate redundant events but ensure the final state is still broadcast.  
    
* Do not throttle low-frequency or isolated events (we only throttle when events are coming in a continuous stream).  
    
* Implementation could use a timestamp check or a short delay buffer:  
    
  * E.g., if an event is about to be broadcast and the last event of the same type was within 100ms, hold off and possibly replace the pending one with the newest value until 100ms has passed.


* Focus on `nodeUpdated` primarily, as that's the likely high-frequency candidate (slider scrubbing). Possibly also `simulationProgress` events if implemented (not currently).  
    
* The throttle should not significantly delay discrete actions (like adding/removing nodes which are usually singular).  
    
* Document the throttle behavior so plugin developers know that extremely rapid changes might not yield an event for every single intermediate value.

##### Implementation Plan

*(We will outline but given time constraints and that it's optional, we may not fully implement if not needed.)*

1. One approach: In `broadcastEvent`, maintain a map of last event times per event type (or just a single lastEventTime if we throttle globally).  
     
2. For event types that can be frequent (`nodeUpdated` particularly), check timestamp:  
     
   * If `Date.now() - lastNodeUpdateEventTime < 100ms`, then instead of immediately posting, we could:  
       
     * Cancel/delay the posting. Perhaps set a `pendingNodeUpdate` flag to true.  
     * Store the data (the latest node update data).  
     * Set a `setTimeout` for 100ms (minus elapsed if any) to actually send it and clear the pending flag.  
     * If more updates come in the meantime, replace the stored data with the new one and reset the timeout.

     

   * This effectively coalesces multiple updates into one at the tail of a burst.

   

3. Implement for `nodeUpdated` events (and possibly similarly for `linkUpdated` if we foresee rapid toggling – but toggling is usually slow manual action, not continuous. So not needed).  
     
4. If applying globally for any event type, can do simpler: if any event comes \< 100ms after last event, delay it by to achieve 100ms spacing. But that could reorder events of different types undesirably.  
     
   * Better to specifically target `nodeUpdated`.

   

5. If implemented, test by simulating 10 slider moves in quick succession and verifying that maybe \~2-3 events come out instead of 10, and final value is captured.  
     
6. Ensure that at the end of a burst, the final update is not lost.  
     
7. Since throttle adds complexity and was not explicitly asked to be coded given our time, we might document this plan and leave hooks (like maybe code comment or a basic check in broadcastEvent that could be expanded).  
     
8. For now, if time is short, we may skip coding throttle and simply mention that by design we avoid heavy events. Or implement a simplified check and drop intermediate events (less ideal but easier).  
     
   * Perhaps not implementing throttle fully now is acceptable as we noted in acceptance that typical usage is fine.

##### Verification

* If implemented, test by programmatically invoking broadcastEvent for nodeUpdated in rapid succession and verifying it compresses output.  
* Confirm final event still occurs with final data.  
* If not implementing fully, ensure documentation states that currently events fire per change and typical usage doesn’t saturate beyond \~10 Hz.

##### Files Modified

* `src/code/sage-api.ts` – Possibly add logic in `broadcastEvent` or within GraphChanged processing to accumulate or drop frequent events. Possibly mark as TODO if skipping now.

*(Given the length and focus, we may not fully implement this in code for this answer, just plan it. We'll note it as future improvement in dev notes, which is acceptable.)*