#### Task 3-2: Implement Node Events Broadcasting

##### Description

Utilize the core event mechanism to specifically handle node-related events: broadcasting events when nodes are added, removed, or updated. This task focuses on constructing the correct event data for node changes and invoking `broadcastEvent` for each relevant scenario.

##### Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
| :---- | :---- | :---- | :---- | :---- | :---- |
| 2025-06-22 17:40:00 | Created | N/A | Proposed | Task drafted (PBI-3, nodes) | Chad |

##### Requirements

* **Node Added**: When a new node is detected in the diff (present in current state, not in previous), create a `nodeAdded` event. Event data should include:  
    
  * `id` of the new node.  
  * Key properties like `title` (name) and `initialValue` (starting value).  
  * Possibly other relevant fields: if the node has a type or category, include it if accessible; if the node is an accumulator/stock, that might be indicated in the data (maybe via a property like `isAccumulator:true`). But we can skip unless needed for external usage.  
  * `source:"SageModeler"` (added by broadcastEvent).


* **Node Removed**: When a node is missing in current state (present in prev), broadcast `nodeRemoved` with data:  
    
  * `id` of the removed node.  
  * We can also include the node’s title (from prev snapshot) for reference if desired. Not strictly necessary, but it might be useful for logging. Perhaps include `title` as well (since we have it in prevNodes).  
  * `source:"SageModeler"`.


* **Node Updated**: When an existing node’s tracked properties change:  
    
  * Prepare a `nodeUpdated` event. Data:  
      
    * `id` of the node.  
    * Include fields that changed (and optionally other stable fields if we want to provide full new state). For simplicity, we might include at least the updated fields. But maybe easiest: include the same fields as we do for nodeAdded (id, title, initialValue, etc.) representing the node’s current state after update. This way the plugin has the full current info.  
    * If we want to highlight what changed, we might not differentiate in data; plugin can compare with what it had if needed. It's fine to just send the new state.  
    * `source:"SageModeler"`.


* Ensure events are emitted according to ordering decided in Task 3-1 (node adds before link adds, node removes after link removes, etc.).  
    
* Use the `broadcastEvent` utility to send out the events.  
    
* Testing for correctness of data (especially for updated events: ensure we capture the new values).

##### Implementation Plan

1. **Diff logic integration**: Within the GraphChanged listener (from Task 3-1), after computing differences, for each node difference:  
     
   * If new node: construct `data = { id: node.id, title: node.title, initialValue: node.initialValue }`. (If node object has those directly, use them. If needed, node may be an object with data property in GraphStore; but probably `node.title` and `node.data.initialValue` if separate. GraphStore Node likely has `title` and `initialValue` properties in code since they appear in GraphStore.changeNode logic. So we can access directly.)  
       
   * Call `broadcastEvent("nodeAdded", data)`.  
       
   * If removed node: retrieve its info from `prevNodes` map (which we stored as maybe {title, initialValue}). Construct `data = { id: removedId }`. Could add `title: prev.title` for clarity (some consumers might appreciate knowing which node removed, but ID might suffice if they map ID to name on their side).  
       
   * Call `broadcastEvent("nodeRemoved", data)`.  
       
   * If updated node: get its new properties from `currNodes`. We know which fields changed by comparing. If multiple fields (like both name and initial changed), we still just send one `nodeUpdated`. Data:  
       
     * We can either include only changed fields or full set. Leaning to full, e.g., `{ id, title: newTitle, initialValue: newInitial }`.  
     * Possibly including old values isn't needed (maybe the plugin doesn't need them).  
     * So do `data = { id, title: curr.title, initialValue: curr.initialValue }`.

     

   * Call `broadcastEvent("nodeUpdated", data)`.

   

2. Ensure to only do this for nodes whose relevant property changed. We can track if `title` changed or `initialValue` changed (we compare those specifically in diff).  
     
   * If only one changed, still we include both current values in event (so plugin has context).  
       
   * If none of the properties we care about changed (e.g., user moved the node's position, which we don't track, so our diff sees no change in title or initial), then we will not erroneously emit an update (which is good).  
       
   * If in future we track some other node data (like maybe we could track if a node's "units" changed or if it toggled from normal to accumulator type). For now, skip.  
       
   * Possibly track `isAccumulator` as well because converting a node to accumulator (through UI) might be considered a significant model change. Actually yes, if user sets a node as "collector" in UI, that changes model behavior. It probably triggers GraphStore.changeNode with isAccumulator property changed. We did not track that property, so our diff wouldn't catch it, so no event. That might be a gap. Perhaps we should track `isAccumulator` from Node data because it's a binary property that significantly changes how node behaves.  
       
     * It's an advanced feature but likely used. Let's incorporate:  
         
       * In `prevNodes` store `isAccumulator` if available, and check it for updates.  
       * Similarly `isFlowVariable` maybe, but that usually gets auto-changed if link relation is plus/minus to accumulator. We can track it as well if easily accessible.  
       * Let's check Node fields from GraphStore.changeNode original: it deals with `isAccumulator` and `isFlowVariable`.  
       * We'll track `isAccumulator` and `isFlowVariable` as well in snapshots and consider them in diff for nodeUpdated.  
       * If either toggles, event triggers, and we include them in event data (so plugin sees the new true/false).

       

     * This way, plugin knows if node turned into a stock/accumulator or turned back to normal. Good.

     

   * Add those to broadcast data as well if present.

   

3. These event broadcasts will naturally follow ordering as implemented in GraphChanged diff handling in task 3-1. (We will group as decided there).  
     
4. **Testing**:  
     
   * Covered partly in Task 3-1 tests. Specifically verify node events content:  
       
     * nodeAdded events have correct name and initial.  
     * nodeRemoved events have correct id (and possibly name if we include it).  
     * nodeUpdated events have new values (and no old values).  
     * Also test an `isAccumulator` toggle scenario: if possible, simulate by direct GraphStore call or UI: e.g., after adding a node, manually call GraphStore.changeNode({isAccumulator:true}, node) to simulate making it a stock. That triggers graphChanged, our diff sees isAccumulator from false-\>true, so nodeUpdated event with isAccumulator true. Check event data includes `isAccumulator:true`.  
     * If node had a numeric property change (initialValue), ensure event shows the new value.

   

5. Documentation: finalize that we include these fields and plugins can rely on them.

##### Files Modified

* `src/code/sage-api.ts` – In GraphChanged listener, implement node diff portion as above, using `broadcastEvent`. Possibly update initial snapshot to include these node fields.  
* Ensure we imported anything needed (but likely not needed beyond GraphStore which we have).  
* (If Node class or GraphStore provides a method to get these fields easily, but we can get from Node instances, use those).