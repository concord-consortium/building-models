#### Task 3-1: Implement Core Event Dispatch Mechanism

##### Description

Set up the foundational event listening and broadcasting system within SageModeler. This task creates the infrastructure for capturing internal model changes and posting corresponding messages. It involves establishing listeners on relevant SageModeler actions/stores and creating a generic `broadcastEvent` utility to send event messages to CODAP.

##### Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
| :---- | :---- | :---- | :---- | :---- | :---- |
| 2025-06-22 17:39:00 | Created | N/A | Proposed | Task drafted (PBI-3, core) | Chad |

##### Requirements

* Initialize an internal state snapshot of the current model (nodes and links) to enable change detection.  
    
* Attach listeners to key Reflux actions:  
    
  * `GraphActions.graphChanged` – triggers when any change to model structure or node properties occurs.  
  * `SimulationActions.runSimulation` – triggers when a simulation starts.  
  * `SimulationActions.simulationEnded` – triggers when simulation ends.


* Implement a function `broadcastEvent(eventName, dataObj)` that wraps `window.parent.postMessage({...}, "*")` with the required format (`sageApi:true, type:"event", event:eventName, data:dataObj`). This utility will be used by tasks 3-2 through 3-4 to actually send events.  
    
* Ensure `dataObj` is augmented with `source: "SageModeler"` for all events.  
    
* The mechanism should allow multiple events to be sent in quick succession (e.g., nodeRemoved and linkRemoved events back-to-back) without losing messages.  
    
* Ensure that event broadcasting is only enabled once the API is fully initialized (e.g., after model load). If needed, trigger an initial snapshot of the model after the first model load so subsequent differences are computed correctly.  
    
* Put in place scaffolding for throttling: e.g., a simple timestamp check in `broadcastEvent` to skip or delay events if they are too frequent (though this may be refined in Task 3-5).

##### Implementation Plan

1. **State Snapshot**: Create data structures `prevNodes` and `prevLinks` (e.g., as Maps: `prevNodes = new Map()` mapping nodeId-\>nodeProps, `prevLinks = new Map()` mapping linkId-\>linkProps).  
     
   * On initialization (e.g., when `sage-api` module sets up events, likely right after it attaches the message listener), populate these from `GraphStore`'s current model: iterate `GraphStore.getNodes()` and `GraphStore.getLinks()` to fill maps. Node props to store: at least `title` (name) and `initialValue` (and if we consider `isAccumulator` or others, possibly store those if needed). Link props: `source`, `target`, `relation` (polarity ID or formula).  
   * This captures the baseline model state. If no model is loaded yet, these will be empty maps (and will be updated when a model loads via GraphActions events).

   

2. **GraphChanged Listener**: Use `GraphActions.graphChanged.listen(graphState => {...})`. When triggered:  
     
   * Obtain new state snapshots. The `graphState` param likely contains `nodes` and `links` arrays with current state (GraphMixin uses it to update UI). If available, use that instead of calling GraphStore again. GraphState might have `.nodes` and `.links` lists of Node/Link objects or plain objects. Possibly easier to just call GraphStore.getNodes() and getLinks() directly to avoid format confusion. That is fine.  
       
   * Compute differences:  
       
     * Create new maps `currNodes` and `currLinks` from current state.  
         
     * Determine node differences:  
         
       * For each node in `currNodes`:  
           
         * If not present in `prevNodes`, that's a new node \-\> prepare a `nodeAdded` event.  
         * If present in `prevNodes`, compare props: if `title` changed or `initialValue` changed (or any other property we decide to track): prepare a `nodeUpdated` event.

         

       * For each node in `prevNodes`:  
           
         * If not present in `currNodes`, that node was removed \-\> prepare a `nodeRemoved` event.

       

     * Determine link differences similarly:  
         
       * New link (in curr not in prev) \-\> `linkAdded` event.  
       * Existing link changed (present in both but relation changed) \-\> `linkUpdated` event.  
       * Removed link (in prev not in curr) \-\> `linkRemoved` event.

       

     * (We should consider that if a node was removed, GraphStore likely already removed its links, so we will have linkRemoved events separate. The diff will catch them as well.)

     

   * Order events logically: We will gather link events and node events in separate arrays. If a node removal and link removals happened together, by diff the linkRemovals will appear and nodeRemoval will appear. We will send all `linkRemoved` events first, then the `nodeRemoved`. Similarly for additions: if a node was added along with a link (like user creates a node by connecting a link? Actually, that doesn't happen – links can't exist without nodes, so linkAdded always after nodeAdd; our diff might catch nodeAdded and linkAdded same cycle e.g., if user draws a link from an existing node to a new node in one action? Possibly the UI might create new node with link in one go. If so, GraphChanged event might reflect both new node and new link simultaneously. We should then send nodeAdded first, then linkAdded. It's wise to always handle nodes first for additions, links first for deletions. Actually, opposite for additions: new node should come before new link that depends on it (so plugin can add node then add link referencing it). For deletions: remove link first then node. So: \- For "added" events: do nodeAdded events first, then linkAdded. \- For "removed": do linkRemoved events first, then nodeRemoved. \- For updates, order between nodeUpdated and linkUpdated probably doesn't matter much, as they are independent typically. They can be sent in any order or in the sequence we find changes. Maybe group by type for consistency but not critical. Possibly send node updates then link updates or vice versa. There's no dependency because an updated link and updated node usually are separate. We can just handle in order we process them, or group by category for clarity. Let's group by nodes vs links for consistency: \+ Maybe do all node events (added/updated) together (except removal which we do after link removals), and link events (added/updated) together. But mixing adds/updates is fine to combine as one group. \- Actually, let's clarify final approach: \+ Compute lists: `nodeAdds`, `nodeUpdates`, `nodeRemoves`, `linkAdds`, `linkUpdates`, `linkRemoves`. \+ If any linkRemoves exist, broadcast those first. \+ Then broadcast nodeRemoves. \+ Then broadcast nodeAdds (so that if links were also added referencing those, the nodes exist by then – though if a linkAdd came with a nodeAdd, yes, nodeAdd should come first). \+ Then broadcast linkAdds. \+ Then broadcast nodeUpdates and linkUpdates (either could be interleaved, but maybe do nodeUpdates then linkUpdates). \+ This ordering ensures structural dependencies are respected.  
       
   * Use `broadcastEvent` to actually send each prepared event, with appropriate data objects.  
       
   * After sending all events for this change, update `prevNodes = currNodes` and `prevLinks = currLinks` to update snapshot.

   

3. **Simulation Run Listener**: `SimulationActions.runSimulation.listen(() => {...})`. In callback:  
     
   * Call `broadcastEvent("simulationStarted", { source:"SageModeler" })`.  
   * Also possibly set a `sageApi.simulationRunningFlag = true` here (though we already do in Task 2-1, but if user triggered simulation via UI, our API run handler wasn't invoked to set flag, so we should also set it here to cover UI-case. Yes, if simulation started via UI, this listener will fire and we can mark flag true now).

   

4. **Simulation Ended Listener**: `SimulationActions.simulationEnded.listen(() => {...})`. In callback:  
     
   * Call `broadcastEvent("simulationCompleted", { source:"SageModeler" })`.  
   * Clear `sageApi.simulationRunningFlag = false` (and possibly `sageApi.busy=false` if used globally) as simulation is done. This helps Task 2-1's busy check and any other gating.  
   * (If we wanted to include any result info, we'd gather it here. E.g., we could count total cases added to data. But that requires hooking into CODAP or counting Node.frames. Possibly out of scope. We'll skip or just include an empty data besides source.)

   

5. **Throttle Mechanism** (optional):  
     
   * Implement a simple guard in `broadcastEvent`: keep a static `lastEventTime`. Before sending a new event, if `Date.now() - lastEventTime < minInterval` (say 100ms), either drop or delay the event. We may just drop intermediate events (which can cause lost info) or accumulate and send latest after a delay. This is complex to do properly for state diffs. Possibly skip actual throttle code now but leave structure to add if needed. We will note it but not implement in detail for now because our events are not extremely high frequency by design.  
   * If we skip throttle now, we meet acceptance by argument that simulation tick events are not sent, and UI changes seldom exceed 10 Hz. If needed, a future revision can throttle `nodeUpdated` events if slider is dragged. We'll document accordingly.

   

6. Integrate these listeners in the `sage-api` initialization flow (they should be set up when the plugin loads). Ensure they're not set up multiple times inadvertently (only once).  
     
7. Test the overall system after implementing tasks 3-2 to 3-4, as those tasks will use this mechanism.

##### Verification

* **Unit Test**: Simulate changes without actual UI:  
    
  * We can manually call our `onGraphChanged` function with custom current vs prev states to test diff logic. Or easier, simulate via our API tasks:  
      
    * Use Task 1-1 (create node) to add a node via API. That call will trigger GraphStore.addNode \-\> GraphActions.graphChanged \-\> our listener. Check that our event broadcast function was called with a `nodeAdded` event and correct data. In a unit test environment, we can spy on `window.parent.postMessage` or on our `broadcastEvent` to capture the output event.  
    * Similarly, simulate node update: call Task 1-2 (update node) to change a node's name. That triggers graphChanged \-\> our diff \-\> should produce nodeUpdated event. Verify content.  
    * Simulate remove: call Task 1-3 (delete node) on that node. Should yield linkRemoved (if any link exists) then nodeRemoved. If no links for that node (only one node), just nodeRemoved. Verify.  
    * For links: we can simulate by adding two nodes and then using Task 1-4 (create link) API to add a link. That triggers events for linkAdded (and maybe none for nodes because nodes were already there). Verify linkAdded event content (should have correct source and target IDs).  
    * Update link: using Task 1-5 (update link, e.g., flip polarity) triggers linkUpdated event. Verify data.  
    * Remove link: Task 1-6 (delete link) triggers linkRemoved event.

    

  * We should verify that events come in expected order. For example, when Task 1-3 deletes a node that has a link:  
      
    * If we create node A, node B, link A-B, then call API to delete node A: That will remove link A-B and node A. Our event system should emit linkRemoved (for link A-B) then nodeRemoved (for node A). We can simulate that scenario and check the sequence of `postMessage` calls (maybe by intercepting or logging them in order).  
    * Similarly, adding a node and a link in one go might not happen via separate API calls (only user could do that, e.g. drop new node onto an existing node to auto-link, if such UI exists). We might test add node then add link quickly and see events: should be nodeAdded then linkAdded. However, since those are separate actions, they naturally will come separate GraphChanged events in sequence, not in one combined event. So maybe not need to combine in one trigger. If user draws new node by link, we'd have one GraphChanged with both. Hard to simulate via API easily. We trust our diff to handle combined scenario as code design.

    

  * Test simulation events:  
      
    * Simulate starting simulation via API (Task 2-1). That should have triggered SimulationActions.runSimulation (our listener), and we expect a simulationStarted event to have been broadcast. Similarly, simulationCompleted event broadcast at end. We can simulate a quick static run:  
        
      * Immediately after calling runSimulation API, the simulation may complete if static. Our onSimEnd will fire nearly instantly. So possibly our test should wait a tick (or just verify both events happened in succession). We can intercept broadcastEvent calls and ensure one was "simulationStarted" and one "simulationCompleted". Possibly out-of-order due to synchronous nature? Actually, if static, simulationCompleted might fire before our runSimulation listen callback even executes (if Reflux processing synchronous actions in order: store runs simulation, triggers simulationEnded, then after that triggers the simulationEnded action's listen, then triggers our runSimulation's listen maybe – need to consider Reflux order: it typically triggers store then triggers action’s listen handlers. If so, in static scenario, our runSimulation.listen might actually run *after* simulation ended action had fired. This is tricky. We might in static case get simulationCompleted event with no preceding started from our system. We should evaluate:  
          
        * The runSimulation Reflux action triggers synchronous store code (which in static might call SimulationActions.simulationEnded during it). But how does Reflux handle an action triggering another action within the store? Possibly SimulationActions.simulationEnded will be triggered after runSimulation is fully done and will invoke its listens. Our simulationEnded.listen will fire then, maybe even before runSimulation.listen finished or maybe after. Hard to fully predict.  
        * But likely, by the end, both events will have been sent, maybe even in reversed order. We might see simulationCompleted posted, then simulationStarted posted if our code isn't carefully ordering them. Potentially a flaw in static scenario. But static simulation is so quick that a plugin might not care the ordering difference (they might see started and completed almost simultaneously).  
        * If needed, we might enforce that we broadcast started before running simulation in our API handler (Task 2-1 could do broadcast started itself to ensure order for static case). But we avoided that to not duplicate if UI triggered. Possibly accept that in static runs the events might appear nearly simultaneously, ordering not guaranteed. That's minor.

        

      * For testing, perhaps we simulate a dynamic run (with asynchronous steps) by configuring a time-based model with \>1 step. Without CODAP, not easy, but maybe simulation-store can be tricked if an accumulator is present. Possibly skip in unit context.

      

    * We can still verify that at least one simulationStarted and one simulationCompleted event happen for an API triggered run.  
        
    * Also simulate a user-initiated run: we can mimic by directly calling SimulationActions.runSimulation (like store’s function) to simulate UI press, or simply call our onSimRun and onSimEnd manually to ensure they broadcast. But actual effect is tough in unit environment. But our integration will cover UI scenario.

    

  * Test throttle (if implemented, maybe not in this iteration). If not implemented, ensure documentation covers it.


* **Integration Test**:  
    
  * Run SageModeler in CODAP, open a second plugin (like a logger plugin or a custom test plugin) that listens to `window.addEventListener("message", ...)` for event messages.  
      
  * Perform actions in SageModeler UI: e.g., add a node (via palette drag), remove a node, rename a node, add a link, remove link, run simulation, etc. Check that for each action, the listening plugin receives the correct event message with expected event name and data. Confirm content:  
      
    * Node addition event has correct id and name.  
    * Node removal event has correct id.  
    * Link events have correct endpoints and relation.  
    * Updates reflect new names/polarities, etc.

    

  * Particularly test a combined scenario: remove a node that has links \=\> plugin should get linkRemoved and nodeRemoved events (in that order) close together. Or add a node and then a link quickly \=\> should get nodeAdded event then separate linkAdded event (likely triggered separately as user has to do two actions anyway).  
      
  * Test simulation events: start a simulation from UI (click run) \=\> plugin gets simulationStarted then simulationCompleted after it finishes. If simulation is dynamic (like an accumulator model that runs say 10 steps taking \~1 second total), verify simulationStarted arrives immediately and simulationCompleted after roughly the run is done.  
      
  * If possible, measure frequency: e.g., drag node slider rapidly and see event frequency (just to ensure it's not insane; it might be many but probably under 10 per second due to UI limitations anyway).  
      
  * Ensure no extraneous events: e.g., moving a node on canvas (position change) likely triggers GraphActions.graphChanged because node coordinates changed? Actually GraphStore.moveNode triggers updateListeners as well. That would cause our diff to detect maybe no property changes we track (since we are not tracking position). So we would not emit a nodeUpdated because we didn't track position. That’s fine (we intentionally ignore purely positional changes as they don't affect model logic). So ensure that dragging node position does **not** trigger an event from us. If it does inadvertently, that means we mistakenly counted something as change (but we don't track x,y so it should appear identical in our tracked props and thus not emit event – perfect).  
      
  * Confirm all events include `source:"SageModeler"` in data.  
      
  * Confirm ordering in complex changes as previously.  
      
  * If throttle isn't implemented, note if any scenario felt spammy. Likely fine.  
      
  * The listening plugin should be able to update its representation of the model using these events alone (we could attempt to reconstruct model in logger plugin by applying events and see if it matches actual – but that’s beyond simple testing; conceptually it should).

##### Files Modified

* `src/code/sage-api.ts` – This is central to event wiring. We'll add the event listeners (`GraphActions.graphChanged.listen`, etc.) and define `broadcastEvent`. Possibly in a sub-section or at module top after other handlers are defined.  
* We may need to import `GraphActions` from `../actions/graph-actions` (assuming it exports the created actions, similar to how SimulationActions likely does).  
* Similarly import `SimulationActions` from simulation store if not already (if needed).  
* Possibly import or define any helpers (like if `TimeUnits` needed for reading link relation formula to name mapping if needed, but not likely needed to broadcast, we can broadcast internal id or formula).  
* No changes to GraphStore code; just reading from it.  
* If any global objects (like `window.parent`) not accessible in test environment, adjust but presumably fine in real run.  
* Add a property or within `sage-api` to hold `prevNodes` and `prevLinks` (or closure variables in event-handling context).