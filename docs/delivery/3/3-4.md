#### Task 3-4: Implement Simulation Start/Complete Events Broadcasting

##### Description

Finalize the event broadcasting system by handling simulation events. This task uses the listeners set up in Task 3-1 for `SimulationActions.runSimulation` and `SimulationActions.simulationEnded` to broadcast `simulationStarted` and `simulationCompleted` events.

##### Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
| :---- | :---- | :---- | :---- | :---- | :---- |
| 2025-06-22 17:42:00 | Created | N/A | Proposed | Task drafted (PBI-3, simulation) | Chad |

##### Requirements

* When `SimulationActions.runSimulation` triggers (meaning a simulation run began), send out a `simulationStarted` event:  
    
  * Data should include `source:"SageModeler"`. We might also include an identifier for the run if available (could be experiment number or run count). However, it's not strictly needed. We'll omit additional fields for now.


* When `SimulationActions.simulationEnded` triggers, send a `simulationCompleted` event:  
    
  * Data: `source:"SageModeler"`. If we can easily include any summary, we might include e.g. `success:true`. Typically, if ended event fired, it means it finished successfully (the API doesn’t have a concept of simulation failure except maybe if model was empty, but then it wouldn't start).  
  * We could include number of steps run (if easily known). Possibly use `GraphStore` or `SimulationStore` to retrieve last run duration. For example, SimulationStore.settings.duration is the total steps configured, and if static simulation ended after 1 step, but dynamic uses that. We can include `duration: N` if we want to indicate how many steps were executed (which is basically the configured duration).  
  * Or experiment number as an incremental run count. Maybe not needed.  
  * We'll likely just send source and maybe a success true flag.


* These events are broadcast to all plugins (including the one that possibly triggered the simulation).  
    
* After broadcasting `simulationCompleted`, ensure to clear the busy flags:  
    
  * `sageApi.simulationRunningFlag = false`.  
  * (If we have a general `sageApi.busy`, set false if we had set it).


* Ensure that if multiple simulation runs happen, events come in correct pairs. The runSimulation listen could potentially fire multiple times if user triggers runs quickly (though UI disables run button until done). Should be fine; start events correspond to each start, end to each end in correct order (since one must end before next can start due to busy logic).  
    
* The events should be triggered for both API-initiated and UI-initiated runs (the listens catch both).  
    
* Already tackled ordering: presumably a simulationCompleted event will come after its simulationStarted event. Except potentially static run scenario as discussed. But in general, over a timeline, we won't see Completed before Started for the same run aside from immediate sequence issues (which hopefully our design mitigates by triggering started event in runSimulation.listen even for UI triggers, albeit static run might complete before that listen runs, but let's hope Reflux processes actions in sequence).  
    
* If out-of-order occurs in static case, not much we can do without hooking deeper (like manually broadcasting started earlier in API code).  
    
* We consider that acceptable given minimal impact.

##### Implementation Plan

1. In the `SimulationActions.runSimulation.listen` callback (set up in Task 3-1), simply call:  
     
   * `broadcastEvent("simulationStarted", { source:"SageModeler" })`.  
   * Set `sageApi.simulationRunningFlag = true`.  
   * (We might have already set simulationRunningFlag in API run handler if via API, but if UI triggered, now we do it here).

   

2. In the `SimulationActions.simulationEnded.listen` callback:  
     
   * `broadcastEvent("simulationCompleted", { source:"SageModeler" })`.  
   * Possibly add `success:true` in data if we want (could do to explicitly mark success. It’s somewhat redundant since completed implies success, but harmless).  
   * Set `sageApi.simulationRunningFlag = false`.  
   * Also if we integrated a global busy flag, set that false here too.

   

3. Confirm these are only attached once. (Wrap in initialization logic to avoid duplicates if needed).  
     
4. **Testing**:  
     
   * Unit test: Simulate these listeners by:  
       
     * Directly invoking `onSimRun()` callback function in isolation and verifying it calls broadcastEvent with simulationStarted.  
     * Or easier: spy on broadcastEvent as before, then trigger a simulation by either calling runSimulation via API (which triggers them) or manually emit Reflux actions.  
     * In unit environment, we might trigger the Reflux actions by doing `SimulationActions.runSimulation()` from code – but that will also attempt to run simulation logic. Possibly we can do it if we intercept early enough or if model is trivial. Alternatively, call our `handleRunSimulation` which calls SimulationActions.runSimulation. That will cause our onSimRun listener to fire, sending event. We capture it as done in earlier tasks verifying events were called.  
     * For simulationCompleted, we need simulation ended action to fire. Possibly simulate by calling SimulationActions.simulationEnded() manually after starting simulation. Or call handleRunSimulation and if static, it will within same tick call simulationEnded through store – our listener should catch it, broadcasting completed event (maybe before started event in static case, which our test might catch). If test sees started and completed events both invoked, that's success (regardless of minor ordering).  
     * We could also directly call onSimEnd for unit testing to ensure it does what expected (calls broadcastEvent).  
     * Check that simulationRunningFlag toggles properly (initial false, becomes true on started, false on completed).

     

   * Integration test:  
       
     * Already partly described in PBI-3 analysis: run a sim via UI and via API, watch events in another plugin. Ensure 'simulationStarted' arrives quickly after run triggered and 'simulationCompleted' after done. Confirm no extra data besides source perhaps (depending on what we include).  
     * Possibly run multiple times to ensure events each time.  
     * Ensure busy logic prevented a second run from overlapping (tested in PBI-2 integration).  
     * Accept the known nuance that with static simulation, maybe started and completed come almost together (the plugin might receive both essentially at same time).

##### Files Modified

* `src/code/sage-api.ts` – Already set up listeners in Task 3-1, just ensure their callbacks do the above.  
* Possibly include `success:true` in completed event if we think it's useful (not needed, but we might do it just to mirror typical patterns; or we leave it out).  
* Nothing else new.