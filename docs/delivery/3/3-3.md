#### Task 3-3: Implement Link Events Broadcasting

##### Description

Extend the event mechanism to handle link events. This task handles broadcasting `linkAdded`, `linkRemoved`, and `linkUpdated` events with appropriate details whenever links are created, deleted, or changed.

##### Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
| :---- | :---- | :---- | :---- | :---- | :---- |
| 2025-06-22 17:41:00 | Created | N/A | Proposed | Task drafted (PBI-3, links) | Chad |

##### Requirements

* **Link Added**: When a new link is detected (in current state but not previous):  
    
  * Broadcast `linkAdded` event. Data should include:  
      
    * `id` of the link.  
    * `source` node id and `target` node id (which nodes it connects).  
    * `relation` describing the link’s relationship/polarity. Ideally a simple sign or label: we can use something like `"+"` or `"-"` or words `"increase"/"decrease"`. The PRD doesn’t specify exact format. It might be best to use the same terminology as SageModeler UI (which uses "increases" / "decreases"). The internal Link relation might have an id ("increase" or "decrease"). We can broadcast that string. Alternatively could send numeric \+1/-1, but string is clearer. Let’s send e.g. `"relation": "increase"` or `"decrease"`. (If other relation types exist like "a lot", but those only apply within certain contexts, out of scope maybe. We'll at least handle increase/decrease and any simple relations).  
    * `source:"SageModeler"`.


* **Link Removed**: When a link is gone from current state (present in prev):  
    
  * Broadcast `linkRemoved` with data:  
      
    * `id` of link.  
    * Optionally `source` and `target` of that link (from prev snapshot) for context. Likely helpful, because if plugin wants to update UI, it might need to know which connection was removed. We have that info in prev snapshot, so include `source` and `target`.  
    * `source:"SageModeler"`.


* **Link Updated**: When an existing link’s relation changes (e.g., user toggled polarity):  
    
  * Broadcast `linkUpdated`. Data:  
      
    * `id` of link.  
    * New `relation` value (e.g. changed from "increase" to "decrease").  
    * Possibly `source` and `target` as well for completeness, though those didn't change. Including them is okay for context.  
    * `source:"SageModeler"`.


* Ensure that, as decided, link removal events are broadcast before node removal events if they occur together (the GraphChanged handling in Task 3-1 will ensure this ordering).  
    
* Use `broadcastEvent` to send messages.  
    
* Validate that relation values we provide are understandable. Using "increase"/"decrease" strings should be fine. (We can get it from internal RelationFactory id or possibly from Link object’s relation property if it has an `id` field. E.g., Link.relation.id might be "increase". We saw in RelationFactory static objects have `id: "increase"`. GraphStore likely stores link.relation as one of those objects. If a link's `relation.id` is accessible, perfect. If not, maybe we compare magnitude or formulaFrag. But probably `link.relation` has an id or text property. We can try to get `link.relation.id`. We'll do that if possible. Alternatively, GraphStore’s relation might not be easily accessible as property if `link` is not a model but a plain object in JSON, depending on GraphStore’s output. But GraphStore.linkKeys holds Link instances, so in GraphStore context we can get link \= GraphStore.linkKeys\[linkId\] maybe. Or the `currLinks` we gather might be from GraphStore.getLinks() returning actual Link instances (if GraphStore is Reflux store, perhaps getLinks returns an array of Link model objects). It likely does. Then we can do `link.relation` on that instance. It might be a Relationship object or one of RelationFactory's static objects. If it's static object, it has `id`. So use that.  
    
  * If for some reason we can't get id easily but we can get `relation.magnitude` (1 or \-1), we could map \+1-\>"increase", \-1-\>"decrease". But better use id if available. We'll attempt link.relation.id or link.relation.text (some property).  
  * We'll verify in tests if needed by known outcomes or by reading `link.title` maybe (no, link likely has no title, just relationship).


* Consider other relation types: If a link is an "added to" (flow into accumulator), relation.id might be "added". We could broadcast "added" string. External plugins might not know what that means (they likely only expect plus or minus because external API was mainly about CLD, not flows). But we will still broadcast any relation type if changed. It's up to plugin to interpret or ignore advanced types. At least providing the raw id is safest. So yes, just always provide `relation: <id string>`.

##### Implementation Plan

1. In GraphChanged diff (task 3-1), for each link difference:  
     
   * If new link: prepare data:  
       
     * `id = link.id` (or link.key).  
         
     * `source = link.sourceNode` (if link object has .sourceNode property containing id or reference, likely link.sourceNode maybe a Node or key. GraphStore likely sets link.sourceNode and link.targetNode references. If those are Node objects, we need their id \- Node has .id or .key. Possibly link object might store the keys as properties too if imported from JSON, e.g., `link.source` or something. Let's find clue: GraphStore.importLink likely sets `link.id = link.key = provided key`, link.sourceNode \= Node instance, link.targetNode \= Node. We can do `link.sourceNode.id` and `link.targetNode.id`. If link returned from GraphStore.getLinks is a plain object (like from .toExport?), then maybe not actual Node. But since GraphStore is in memory, getLinks probably collects actual Link instances or objects with .source \= "nodeKey".  
         
       * Actually GraphStore.getLinks is likely implemented to return an array of Link model objects (the GraphStore.linkKeys map values).  
       * GraphStore Link class (if any) might have e.g. `.source` method or `.sourceNode` property.  
       * If not sure, as fallback, we have stored in `currLinks` map what we want: in `prevLinks` and `currLinks`, we can store source and target as id strings from when we built them. Yes, in snapshot we definitely stored link id, source id, target id, relation id. So just use our `currLinks` map's info. That is simpler: `currLinkProps = currLinks.get(linkId)` from our new map, which contains e.g. `{ source: "nodeA", target: "nodeB", relation: "increase" }` (we will ensure to store relation as id string, not object).  
       * So do that: when building currLinks, store relation as string id already, e.g., `relation = link.relation.id` or determine sign then map to string. So then we have exactly what to output.

       

     * Then `relation = currLinkProps.relation` (like "increase" or "decrease").  
         
     * Data \= { id, source, target, relation }.  
         
     * `broadcastEvent("linkAdded", data)`.

     

   * If removed link: get its info from `prevLinks` map (since now it's gone).  
       
     * `prevLinkProps = prevLinks.get(linkId)` which has { source, target, relation } from before.  
     * Data: { id, source, target } (we might omit relation because if link is gone, polarity not that important, but could include for completeness. Probably not needed for removal because if it's removed, plugin just needs to drop the connection, source/target helps identify which connection was removed though).  
     * Actually, including source & target is useful to exactly identify which two nodes were disconnected. Without that, plugin only knows link id was removed – plugin could track id-\>source mapping itself, but nice to have it in event so plugin can directly identify the nodes that lost a connection.  
     * So include source & target.  
     * `broadcastEvent("linkRemoved", data)`.

     

   * If updated link: e.g., relation changed:  
       
     * Use `currLinkProps` and `prevLinkProps` for that link.  
     * Data: { id, source: curr.source, target: curr.target, relation: curr.relation } (assuming source/target didn't change – they wouldn't except if the link was somehow reconnected to different nodes which UI doesn't do).  
     * `broadcastEvent("linkUpdated", data)`.

   

2. This will be done in the GraphChanged diff loop as per grouping logic:  
     
   * We'll likely collect link events lists separate and then call broadcast accordingly as in task 3-1 plan (linkRemoves first, then linkAdds, linkUpdates either combined with adds or separate after? Possibly after adds, but actually link updates can be treated similarly to adds in terms of no dependency. Might as well send updates after adds or before adds? Probably doesn't matter because updates refer to existing links unaffected by new ones typically. We can send updates either after adds or before adds. Minor significance. We can group updates with adds or send them right after adds maybe.)  
   * Simpler: do removals, then node removals, then node adds, then link adds, then node updates, then link updates. That segregates nicely. Or do all updates after all adds. This ensures structure established (adds) before updates (some updates could be property changes on things that were just added? Unlikely in same cycle – not impossible though if user quickly toggled a link’s polarity right as they create it? They would have to create link then quickly toggle before next model tick – probably triggers separate GraphChanged events anyway).  
   * We'll stick to that ordering.

   

3. **Testing**:  
     
   * Already partly in tasks 3-1 and 3-2. Specifically verify link events:  
       
     * linkAdded event after API or UI creates a link has correct source and target IDs (should match actual node ids – test using known node id names).  
     * linkRemoved event after link deletion includes correct source/target of that link from before deletion.  
     * linkUpdated event after flipping link sign yields relation changed in event data. E.g., initial "increase", event shows "decrease".  
     * Order relative to node events in combined scenarios as tested earlier.

     

   * Also test that if a link is updated, `source` and `target` remain same in event (just to see if we kept them – we did for completeness, plugin can ignore them for update or use them).

   

4. Confirm relation naming: if link.relation.id returns "increase" or "decrease", event shows those. If it's a flow type like "added", event shows "added". That might not be super meaningful to external if they aren't expecting flows. But including it doesn't harm; advanced plugin might use it, or ignore if unknown. It's fine.

##### Files Modified

* `src/code/sage-api.ts` – Extend GraphChanged diff section for links similar to nodes. Ensure to gather relation as needed (like retrieving static relation id).  
    
* Possibly import `RelationFactory` or use link object’s relation property as is to determine id. If no direct id, could map formula or magnitude:  
    
  * Alternatively, relation might have a `magnitude` property 1/-1 for inc/dec. If so, we could use that: \+1 \-\> "increase", \-1 \-\> "decrease". If relation.id not easily accessible.  
  * But since we have code \[50†L35-L43\], likely link.relation.id exists. We'll attempt that first.


* Update snapshot building: in prevLinks and currLinks maps, store relation as already a string id for simplicity in comparison. If relation changes, we compare string vs string. Yes.  
    
* Implementation as above.