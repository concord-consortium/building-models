#### Task 1-2: Implement Update Node API Command

##### Description

Enable modifying an existing node's properties via the external API. This task handles messages with `action:"update"` targeting a specific node (e.g., `"resource":"nodes/123"`). It allows a plugin to change attributes such as the node's title (name), initial value, units, etc., replicating what a user might do in the UI (e.g., renaming a node or adjusting a parameter).

##### Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
| :---- | :---- | :---- | :---- | :---- | :---- |
| 2025-06-22 17:31:00 | Created | N/A | Proposed | Task drafted (PBI-1) | Chad |
| 2025-01-25 22:35:00 | Status Update | Proposed | InProgress | Starting implementation | AI Agent |
| 2025-01-25 22:45:00 | Status Update | InProgress | Review | Implementation completed, ready for testing | AI Agent |
| 2025-01-25 22:50:00 | Status Update | Review | Done | Task verified working, including position updates | AI Agent |

##### Requirements

* Parse and recognize an incoming message with `action: "update"` and `resource: "nodes/{id}"`. The `{id}` will be the identifier of the target node to update (as assigned by SageModeler, e.g., a UUID or numeric key string). The `values` object will contain one or more fields to change (e.g., `title`, `initialValue`, etc.).  
    
* Validate the request: ensure the resource path contains a valid node ID. Check that the node exists in the current model (GraphStore) by that ID. If not, respond with an error (`"Node not found"`).  
    
* Validate the provided values: e.g., if changing `title`, it should not be empty; if changing numeric fields (initial value, min/max), ensure they are numbers and within any logical bounds if applicable. If any value is invalid, respond with an error and do not alter the node.  
    
* Use **GraphStore** to apply the update. Options:  
    
  * If multiple fields are provided, prepare a `data` object and call `GraphStore.changeNode(data, node)` (GraphStore's `changeNode` can apply a batch of changes to a node). This method handles internal adjustments (and triggers UI updates through `updateListeners`).  
  * For a single field, `GraphStore.changeNodeProperty(property, value, node)` could be used; but using `changeNode` with an object is more general.  
  * Use `GraphStore.nodeKeys` or `GraphStore.getNodes()` to retrieve the Node instance by ID (GraphStore might not have a direct `getNodeById` but we can find it by key match or maintain a map of `id->Node`). Actually, GraphStore uses `node.key` as ID and has `nodeKeys` map. We can do `const node = GraphStore.nodeKeys[id]`.  
  * Call `GraphStore.changeNode({ ...fields... }, node, { logEvent:true })`. Using `logEvent:true` will log the change (e.g., for CODAP's undo/redo or analytics) similar to UI operations. GraphStore's changeNode is undo-managed; since this is an external change, we might consider `skipUndoRedo` – however, GraphStore doesn't expose skip for changeNode easily. It uses the undoRedoManager internally. It likely won't harm to let it record an undo step (though if user hits Undo in UI, maybe it could revert an API change – which might be acceptable). This is an open design choice: for now, we can allow it to be undoable by the user if they press Undo in SageModeler.


* After updating, ensure the Node's properties in GraphStore have changed accordingly. The UI should reflect the change immediately (GraphStore triggers graphChanged event which re-renders the node).  
    
* Construct a response: on success, `success:true` and perhaps include the node's updated data (id and the updated fields at minimum). On failure (node not found or invalid input), `success:false` with error message.  
    
* The operation should not create or delete anything (that's handled by other commands). If changing a node's property triggers other model changes (e.g., toggling a node from regular to accumulator might auto-remove some links as in GraphStore's logic), our handler should still report success and the changes will be reflected via events. (We should be mindful that GraphStore.changeNode already encapsulates such logic for consistency).

##### Implementation Plan

1. **Handler Logic**: In `sage-api.ts`, add recognition for an update on nodes. If a message's `resource` matches the pattern `"nodes/{id}"` (likely we will parse the resource string by splitting at `/`), and `action === "update"`, route it to `handleUpdateNode(message, nodeId)`.  
     
2. **Find Target Node**: Extract the `{id}` part from the resource string (e.g., `"nodes/ABC-123"` \-\> nodeId \= "ABC-123"). Access the node: e.g. `const node = GraphStore.nodeKeys[nodeId]` (GraphStore.nodeKeys is a map of keys to Node instances). If not found, return an error response (`"error": "Node with id ... not found"`).  
     
3. **Prepare Update Data**: Take the `message.values` object – this could have fields like `title`, `initialValue`, etc. Possibly the client uses the same field names as the internal Node model. Ensure these fields correspond to Node properties. (We might refer to `Node.fields` or documentation; likely `title`, `initialValue`, `min`, `max`, `units`, etc. correspond). Remove any fields that are not allowed to be changed via API (for instance, `id` or computed properties should not be in values).  
     
4. **Apply Changes**: Use GraphStore. If multiple fields, do: `GraphStore.changeNode(values, node, { logEvent:true })`. GraphStore will handle changing the node and sending out any needed events (GraphActions.graphChanged will fire, updating UI). If GraphStore requires using its undo manager, it will do so internally. We just call it and catch any exception.  
     
   * Note: GraphStore.changeNode returns an array (one entry per node changed, since it can batch multiple nodes). We can ignore the return or ensure it completed by lack of exception.  
   * By using `logEvent:true`, internal logging happens (like logging "variable name changed" etc.) and CODAP may be notified of some changes (like if the title changed, GraphStore calls CodapConnect.sendRenameAttribute to keep data context in sync). That's good – it means our API-triggered rename will also rename the CODAP data column.

   

5. **Construct Response**: If the update succeeded, create a response object with `success:true`. We can include the node's id and the updated fields in `data`. For completeness, perhaps include the full node object (or at least the changed fields and their new values). E.g., `{ id: "ABC-123", title: "NewName", initialValue: 10 }`. If certain fields weren't provided by the client but changed indirectly (for example, changing a node's type might remove some links; those link removals will be separately broadcast as events), we don't need to list that in this response – this response is specifically for the node update command itself.  
     
6. **Error Handling**: If GraphStore throws an error or if we detected invalid input, catch it. For instance, GraphStore might throw if a title is duplicate and can't be resolved (though it usually auto-fixes duplicates by appending a number). If we prefer to enforce uniqueness strictly, we could pre-check using `GraphStore.isUniqueTitle(newTitle)` and decide to error if false. However, current UI behavior is to auto-rename, so the API will likely follow that (not error on duplicates, just accept the auto-adjusted name). We can simply rely on GraphStore. In any case, handle any thrown error by forming `success:false` with a message.  
     
7. **Testing Changes**: After calling changeNode, verify that `node.title` etc. have the new values. This ensures the model is updated. (In code, we might log something in debug mode, or simply trust GraphStore).  
     
8. **Respond**: Use the common mechanism to send the response to the parent frame.  
     
9. **Testing**: Similar to create, but now ensure an existing node is required.

##### Verification

* **Unit Test**: Simulate a node update. First, in the test setup, create a node in GraphStore (either via the previous create command or directly via GraphStore for test). Get its id. Then craft a message: `{sageApi:true, action:"update", resource:"nodes/<id>", values:{ title:"RenamedNode", initialValue:42 }, requestId:"req-2"}`. Pass it to the handler. Assert that:  
    
  * Response is `success:true` and `data.id == <id>`, and perhaps `data.title == "RenamedNode"`.  
  * GraphStore.nodeKeys\[\].title is now "RenamedNode", and initialValue is 42\.  
  * The count of nodes remains the same (no new node, just updated).  
  * If the node was renamed, check that if CODAP integration is active, the corresponding data attribute got renamed (this is hard to verify in unit test without CODAP, but GraphStore does call CodapConnect.sendRenameAttribute under the hood – we might spy on that if CodapConnect can be stubbed).


* **Invalid ID Test**: Call update for a made-up node ID. Expect `success:false` and error "not found". Ensure no change in model.  
    
* **Partial Update Test**: If only one field is provided (e.g., just `{"title":"X"}`), ensure only that field changes and others stay same. Also test updating numeric fields: e.g., set a node's initial value from 5 to 10; verify that in GraphStore the value updated and no other side effect.  
    
* **Edge Cases**: Change that triggers internal reconfiguration: e.g., SageModeler might treat converting a node to an accumulator differently. If such a property is exposed (say `isAccumulator:true` in values), GraphStore.changeNode will remove certain links automatically. Verify that: the response is success, the node's property updated, and any affected links were removed (those removals should trigger events, which is PBI-3's concern, but ensure no error in the update itself).  
    
* **Integration**: Through a plugin or test harness, send an update message to rename a node and verify the UI node text changes. Also verify the response arrives. Possibly, after renaming multiple times, check that Undo in SageModeler UI can step through those changes (if we allowed undo recording).

##### Files Modified

* `src/code/sage-api.ts` – Add `handleUpdateNode` function and integrate it into the dispatcher. Likely add logic in the message listener to parse and extract the node ID from resource (e.g., using a regex or split to detect pattern "nodes/").  
* No changes expected in GraphStore or Node classes – use existing API. (If Node class has fields we need to map, ensure we use correct key names. E.g., Node might have `node.title`, `node.initialValue` properties; values should match those names.)  
* (If not already done in Task 1-1) Ensure we have a way to lookup nodes by ID. GraphStore's internal map `nodeKeys` can be used if accessible. If not, we might add a GraphStore method `getNode(key)` for convenience – but given the codebase, directly accessing `GraphStore.nodeKeys` is acceptable since it's an attribute on the singleton. So likely no new file needed for that.

##### Implementation Completion

**Key Technical Solutions:**
1. **Position Handling**: Discovered that `x` and `y` fields are not in `Node.fields` array, so `GraphStore.changeNode()` ignores them. Implemented separate position handling using `GraphStore.moveNode()` with calculated deltas.
2. **Node ID Consistency**: Fixed issue where `importedNode.id` didn't match the key used for storage. Now return `importedNode.key` for consistent API responses.
3. **Comprehensive Validation**: Added type checking for all field types (string, number, boolean) with appropriate error messages.
4. **Enhanced Testing**: Created dual-mode test interface allowing both creation and updating with the same form fields.

**Verification Results:**
- ✅ Update node properties (title, initialValue, min, max, etc.) working correctly
- ✅ Position updates (x, y coordinates) working correctly using moveNode() method  
- ✅ Comprehensive field validation with appropriate error messages
- ✅ Node lookup by ID working correctly
- ✅ Enhanced test interface with create/update modes
- ✅ Real-time logging and response monitoring

**Final Files Modified:**
* `src/code/sage-api.ts` – Added comprehensive `handleUpdateNode` function
* `dev/api-test.html` – Enhanced test interface with dual-mode functionality