#### Task 1-7: Implement Get Model (Export) API Command

##### Description

Implements an API command to retrieve the entire SageModeler model state as a JSON object. This allows external tools to inspect or save the current model. This corresponds to `action:"get", resource:"model"`. It supports returning either SageModeler’s native format or a standardized SD-JSON format (depending on parameters), addressing part of PBI-1 (basic export) and laying groundwork for PBI-5 (format support).

##### Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
| :---- | :---- | :---- | :---- | :---- | :---- |
| 2025-06-22 17:36:00 | Created | N/A | Proposed | Task drafted (PBI-1 & PBI-5) | Chad |

##### Requirements

* Recognize a request to get the model: `action:"get", resource:"model"`.  
* The request may include an optional `values.format` field indicating the desired format of the output (e.g., `"format": "sd-json"` for System Dynamics JSON format, or `"format": "native"`/ omitted for SageModeler’s own JSON).  
* If no format specified, default to SageModeler’s native JSON schema (the same structure used when saving a model in SageModeler).  
* To obtain the model in native format: use **GraphStore** serialization methods. GraphStore provides `serializeGraph(palette)` which returns a JS object describing the model. This object includes nodes, links, and model settings. We might need to pass the current palette (the set of node types); the palette can be obtained from `PaletteStore.palette` (GraphStore may require it). The `palette` can be found via `PaletteStore` or possibly stored in GraphStore’s state. Actually, GraphStore.serializeGraph takes a palette parameter. If we have access to `PaletteStore.palette` (the current palette configuration), we should supply it. If not, perhaps GraphStore or AppSettings has it. The simplest may be to call `GraphStore.serializeGraph(PaletteStore.palette)`. We have to import PaletteStore. Alternatively, GraphStore.getGraphState() gives nodes and links plus description, but not exactly full JSON format. We should use serializeGraph, as it likely matches the output of "Save Model".  
* The output of serializeGraph is an object that can be JSON-stringified if needed. But we will send it as a JavaScript object in our response `data`. (Our postMessage can handle objects which then get serialized). The receiving plugin can parse the JSON. We should ensure it’s plain data (GraphStore returns plain JS objects, yes).  
* If format is `"sd-json"`, we need to produce the model in SD-JSON format. This likely involves converting the SageModeler model structure to a different JSON structure (with keys like "variables", "links", etc. as used by SD-JSON). We will handle that in PBI-5, Task 5-1. For now, assume we will have a conversion utility function `toSdJson(modelObject)` implemented there. This task might call that if format is sd-json. If that function is not yet implemented (assuming tasks done sequentially, by the time we get here it might not be), we could stub or leave it for PBI-5. But since tasks are done in sequence PBI-5 comes later, perhaps here we simply prepare to call it. We may leave a TODO or if we implement tasks in linear order, by the time we do 5-1 we will update this code. For completeness, write this task as if we'll integrate it: i.e., check format, if "sd-json", call SageAPI.toSdJson(nativeModel) to get converted structure.  
* The response should contain the model JSON under `data`. We should be careful about size: if model has many nodes/links, the JSON could be large but still should be fine to send via postMessage. Possibly compressing or splitting is not necessary for typical use (models are not extremely big, usually \< 100 nodes). We'll send it as is.  
* Success criteria: always returns success (unless something very unexpected like serialization failed). There’s not much user error scenario except format unknown. So if `values.format` is provided and we do not support it (not "sd-json" or "native"), we can either default to native or return an error "Unsupported format". It's probably better to error to inform plugin of the mistake. Alternatively, treat unknown format as native to be forgiving. But clarity is better: we’ll error on unknown format.  
* This command is read-only, it doesn't alter the model.

##### Implementation Plan

1. When message `action:"get", resource:"model"` arrives, call `handleGetModel(message)`.  
2. Determine requested format: `const fmt = message.values?.format?.toLowerCase() || "native";`. Support "native" (meaning SageModeler JSON) and "sd-json". Possibly accept "sage" or "sage-json" synonyms, but not needed if we define clearly.  
3. If `fmt` is not "native" or "sd-json", respond with error: `"Unsupported format '${fmt}'"`.  
4. Fetch the model in native structure: use `const modelObj = GraphStore.serializeGraph(PaletteStore.palette)`. We need to import `PaletteStore` from "../stores/palette-store". PaletteStore likely has a static or exported instance we can use (maybe `PaletteStore.palette` or we might need `PaletteStoreClass` instance). Actually, looking at importer and other usage: In Importer, they do `new Importer(graphStore, settings, paletteStore)` meaning they had an instance of paletteStore. Possibly there's a singleton similar to GraphStore. If `PaletteStore` is a Reflux store, it might be imported as `PaletteStore` (like GraphStore is a singleton export). Checking GraphStore’s code, it uses `PaletteStore.findByUUID` and other static references, implying `PaletteStore` is a store instance. `PaletteStore.palette` might be what we need (the palette data structure with all node types). PaletteStore likely has an export. We might retrieve the palette of node types from `PaletteStore.palette`. If difficulty, note that `serializeGraph` might not need the actual palette in some cases except to omit images if palette has them. But PRD indicates we should provide it. We'll attempt to get it. Possibly we have to import { PaletteStore } from "../stores/palette-store". If it's a Reflux store, maybe it exports a PaletteStore similar to GraphStore export. If not accessible, we could call GraphStore.serializeGraph(undefined) which might still output everything (it may just include images then). It's minor – including images is not harmful. However, to follow best practice, we supply palette. We'll try to import palette.  
5. Once we have `modelObj`, if `fmt === "native"` (or no special format), we can directly put `modelObj` in response data.  
6. If `fmt === "sd-json"`, call our conversion function (which we plan to implement in Task 5-1). For now, assume existence of a function `toSdJson(nativeModelObj)` that returns the model in SD-JSON structure. We will implement it later and then integrate. For this task’s sake, maybe just outline that step. (If tasks were done strictly in order, by the time we implement 5-1, we would come back and connect it. In documentation here, we can mention calling it).  
7. Package the result: `response = { sageApi:true, type:"response", requestId:..., success:true, data: modelDataObj }`. The `modelDataObj` itself might be an object with keys like nodes, links, etc. That’s fine – it will be serialized when posted. Ensure no circular refs (GraphStore.serializeGraph returns plain JS without references, should be fine).  
8. Send the response.  
9. This should always succeed unless something very odd happens (we can catch any error from serializeGraph or conversion and return error if needed). But typically it’s straightforward.  
10. Since this is read-only, no side effect on model state.

##### Verification

* **Unit Test**: Build a simple model (maybe use tasks 1-1 through 1-4 to create a couple nodes and a link). Then call get model (no format specified). Check:  
    
  * Response `success:true` and `data` is an object with keys like `nodes`, `links`, `palette`, etc. (According to how serializeGraph structures it). Specifically, verify that the `nodes` array length matches how many nodes were in model, and each has expected properties (id, title, etc.), and `links` array has expected entries (source and target referencing node keys). The values should match what we put in the model.  
  * If certain fields like initial values or colors were set, ensure they appear correctly.  
  * The model JSON format should be essentially identical to what SageModeler would save (we could compare to GraphStore.toJsonString output). Possibly, we could call `GraphStore.toJsonString(palette)` and compare to JSON.stringify of our response data – they should match. That would be a strong validation that we captured everything.


* **Format parameter test**: If possible by the time of testing, after implementing SD-JSON conversion in PBI-5, test with `values:{ format:"sd-json" }`. Then check that output is in the expected SD-JSON structure (e.g., has top-level "variables" and "links" arrays, etc., and content matches the model). For now, we can outline but actual test might be done after PBI-5 tasks.  
    
* **Integration Test**: In a running app with a known model (like open a SageModeler example with some nodes and links), use a controller plugin to send a get model request. Verify that the response contains the full model JSON. Possibly compare it to exporting the model manually via UI (if SageModeler has an export function, e.g., via developer console `JSON.stringify(GraphStore.serializeGraph())`). They should match. If using SD-JSON format, one could cross-verify by feeding that JSON to an external tool or re-import to SageModeler (if we implement import accordingly). That might be done after implementing import. For now, at least ensure the JSON is well-formed and not empty.

##### Files Modified

* `src/code/sage-api.ts` – Implement `handleGetModel`. Import `PaletteStore` and also likely have to import or reference conversion utilities for SD-JSON (which will be in a later file, perhaps in `sage-api.ts` itself or a separate module in PBI-5). Might leave a TODO or placeholder that will be replaced in Task 5-1.  
* Possibly `src/code/utils/sd-conversion.ts` (to be created in PBI-5) – not created in this task, but will be used.  
* Note: Ensure that large objects can be posted – they can, as long as they’re serializable.