#### Task 1-3: Implement Delete Node API Command

##### Description

Provide the ability to remove an existing node (and any of its connected links) via the API. This corresponds to a `delete` action on a node resource (e.g. `action:"delete", resource:"nodes/{id}"`). Removing a node in SageModeler through the API should mirror the user deleting a node in the UI: the node disappears, any links attached to it are removed, and the data context in CODAP is updated (the corresponding data attribute and its values should be deleted).

##### Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
| :---- | :---- | :---- | :---- | :---- | :---- |
| 2025-06-22 17:32:00 | Created | N/A | Proposed | Task drafted (PBI-1) | Chad |

##### Requirements

* Identify a `delete` request for a node: `action:"delete"` with `resource:"nodes/{id}"`. Extract the node ID.  
    
* Validate: ensure a node with that ID exists. If not, return an error response.  
    
* Use **GraphStore** to remove the node. GraphStore provides `removeNode(nodeKey)` or similar. Specifically, `GraphStore.removeNode(nodeId)` is defined, which will remove the node and internally call `_graphUpdated` and update listeners. GraphStore also likely removes any links connected to that node in the process (the code likely calls `removeLinksForNode(node)` inside removeNode or related functions). We should verify GraphStore’s behavior:  
    
  * Indeed, GraphStore `_removeNode` might call `removeLinksForNode(node)` to clean up relations. Also, if `logEvent:true`, it logs "variable deleted". We might want to set logEvent to true for consistency.  
  * Use `GraphStore.removeNode(nodeId, { logEvent:true })`.


* When a node is deleted, all its links are removed. This should trigger separate events (nodeRemoved, linkRemoved for each link) which will be handled in PBI-3. For the purpose of this command, we just perform the deletion.  
    
* If the node is linked to CODAP’s data, GraphStore should handle deletion of its data context attribute via CodapConnect. Checking GraphStore: in `_removeNode`, if `logEvent` it logs, and in undo logic they had CodapConnect calls for delete as well (like `sendDeleteAttribute(node)`). We should confirm:  
    
  * \[33†L1-L4\] suggests `CodapConnect.instance()._createMissingDataAttributes()` for add and likely `deleteDataAttributeIfEmpty` for deletion is somewhere. Indeed, \[33†L13-L17\] shows `CodapConnect.instance().deleteDataAttributeIfEmpty(node)` on node deletion. This implies our call to removeNode with proper options will trigger removal of the variable from CODAP if no other nodes use that data attribute.


* Construct response: on success, `success:true`. We may not have much data to return – the node is gone, so perhaps just `{ id: <deletedId> }` to acknowledge which node was deleted. (Optional: could include a message or count of links removed, but not necessary). If failure (no such node), `success:false` with an error.  
    
* Ensure atomic: if node doesn’t exist or some unexpected issue, nothing should change. GraphStore.removeNode will simply do nothing if node not found (or we check upfront).

##### Implementation Plan

1. Add handling in `sage-api.ts` for `action:"delete", resource` matching `"nodes/{id}"`. Call `handleDeleteNode(nodeId)`.  
2. In `handleDeleteNode`, lookup the node by ID (similar to update: use `GraphStore.nodeKeys[id]` or equivalent). If not found, return an error response (`"Node not found"`).  
3. If found, call `GraphStore.removeNode(nodeId, { logEvent:true })`. This will remove the node from `nodeKeys` and trigger all necessary cleanup. Under the hood, GraphStore will likely: remove links (via `_removeLink`) for that node, update internal state, and call `updateListeners()` which updates UI. It will also log the deletion event for analytics. We should wrap this in try/catch if GraphStore might throw (unlikely, but just in case).  
4. After removal, confirm success (if no exception). Form the response object: `{ sageApi:true, type:"response", requestId:..., success:true, data:{ id: nodeId } }` (or even data could be `{}` since nothing to return, but including the id is a courtesy confirmation).  
5. Edge case: If node had links, GraphStore should have removed them. We don't individually call removeLink here – GraphStore does it. We trust that because in UI, deleting a node automatically deletes attached links. For verification, one could check that `GraphStore.getLinks()` no longer contains links that had that node as source or target. But that’s more for testing.  
6. If any error occurred (again, probably none unless nodeId existed but something internal failed), catch and send `success:false`.  
7. **Testing**: We'll test after building events too, but here ensure the node is gone and no orphan state remains.

##### Verification

* **Unit Test**: Create or ensure a node exists (like using Task 1-1 or GraphStore directly). Also attach a link to it (to test link removal; create another node and link them via GraphStore for setup). Then send a delete-node message for that node’s id. Assert:  
    
  * Response `success:true`.  
  * `GraphStore.nodeKeys` no longer has that id (node removed).  
  * Any links that were connected to that node are removed from `GraphStore.linkKeys` as well.  
  * The total node count decreased by 1, link count decreased accordingly.  
  * If possible, verify that `CodapConnect.deleteDataAttributeIfEmpty` was called (if we stub CodapConnect). Or check that GraphStore’s data context state updated (this is tough without CODAP, but we rely on GraphStore behavior).


* **Delete Nonexistent**: Try deleting a random ID (or an ID that was just deleted). Expect `success:false` and no changes to model.  
    
* **Integration Test**: In a running SageModeler, programmatically add a node (via UI or prior API call), then send a delete message. Confirm the node disappears from the UI canvas. Also open CODAP’s table: the column for that node’s data should be gone (provided no other nodes share that data context column). Verify the plugin receives the delete response.  
    
* **Concurrent**: Not exactly concurrency, but ensure that if two delete commands come rapidly for the same node, the second will error (first one removed it, second should “not find”). This is fine – just an edge-case behavior note.

##### Files Modified

* `src/code/sage-api.ts` – Implement `handleDeleteNode`. Possibly add a helper to parse resource strings (if not already done in Task 1-2).  
* No changes to GraphStore or others anticipated; we rely on existing removal logic.  
* (No new integration point; uses same message listener set up earlier.)