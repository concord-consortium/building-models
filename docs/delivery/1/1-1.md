#### Task 1-1: Implement Create Node API Command

##### Description

Implement the ability to create a new node in the SageModeler model via an external API request. This task covers parsing a `"action": "create", "resource": "nodes"` message, creating the node with given attributes, updating the model state (GraphStore), and returning a response. It addresses part of PBI-1 by enabling programmatic addition of nodes to the model.

##### Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
| :---- | :---- | :---- | :---- | :---- | :---- |
| 2025-06-22 17:30:00 | Created | N/A | Proposed | Task drafted (PBI-1) | Chad |
| 2025-01-25 15:45:00 | Status Update | Proposed | InProgress | Started implementation | AI Agent |
| 2025-01-25 16:30:00 | Status Update | InProgress | Done | Task completed successfully | AI Agent |

##### Requirements

* Parse incoming message for creating a node: ensure `action == "create"` and `resource == "nodes"`. The `values` object should contain necessary node data (at minimum, a title/name; possibly initial value, units, etc.).  
* Validate input: node must have a non-empty title. If certain fields are missing, use reasonable defaults (GraphStore/Node model may provide defaults for unspecified properties).  
* Use **GraphStore** to create the node: call `GraphStore.importNode()` to construct a Node object from provided data, then `GraphStore.addNode()` to insert it. Ensure a unique ID is generated (GraphStore will handle key generation).  
* If `values` contains an `id` (it typically should not for new nodes), ignore or override it – the ID should be generated internally to avoid conflicts.  
* After adding the node, the model’s nodes list should include the new node, and the UI should update (GraphStore triggers a graphChanged event). If running inside CODAP, ensure a corresponding data context attribute is created for the new node (GraphStore handles this via CodapConnect if `logEvent` option is true).  
* Formulate a **response message** with `type:"response"`, copying the incoming `requestId`, `success:true`, and a `data` object containing at least the new node’s `id` and any key properties (title, etc.).  
* If creation fails (e.g., invalid input), respond with `success:false` and an error description (`data.error`). Do not add any node in that case.  
* The operation should be atomic – if any error occurs, no partial changes.

##### Implementation Plan

1. **Extend Sage API Handler**: In the `sage-api.ts` module, add logic to handle create-node requests. For example, when a message arrives, if `action === "create"` and `resource === "nodes"`, call a dedicated function `handleCreateNode(message)`.  
     
2. **Input Validation**: Inside `handleCreateNode`, read the `values` from the message. Check that `values.title` (or `name`) is provided and is a non-empty string. If not, construct an error response (`"error": "Node title is required"` or similar). Also validate numeric fields if any (e.g., initialValue should be a number if present).  
     
3. **Create Node via GraphStore**: Prepare a node specification for GraphStore. GraphStore expects a Node instance or uses Importer. Simplest approach: use `GraphStore.addNode(new Node(data))`. However, since GraphStore has an `importNode(nodeSpec)` that returns a Node object from a plain spec, we can use that for consistency. For example:  
     
   * Call `const newNode = GraphStore.importNode({ data: { title: ..., initialValue: ..., ... } });`  
   * Then call `GraphStore.addNode(newNode, { skipUndoRedo: true, logEvent: true });`. Using `logEvent:true` will ensure CODAP integration (it calls `_createMissingDataAttributes()` internally). `skipUndoRedo:true` avoids adding this action to the user's undo stack (since it's an external programmatic change).  
   * GraphStore will assign a unique key/ID to the node (as `node.id` and `node.key`). Capture that ID.

   

4. **Update Model State**: The GraphStore.addNode call will mutate the global model state. It triggers internal listeners so the UI updates (the new node appears). Verify that after this call, `GraphStore.getNodes()` includes the new node.  
     
5. **Construct Response**: Create a response object `{ sageApi:true, type:"response", requestId: <same>, success:true, data: { id: newNode.id, title: newNode.title, ... } }`. Include any properties of the new node that might be useful (at least its id and name; possibly initial value or type if relevant).  
     
6. **Error Handling**: Wrap the creation steps in a try/catch. If GraphStore throws an error or any check fails, catch it. Form an error response with `success:false`. For example, if `GraphStore.addNode` fails due to duplicate name (though GraphStore’s `ensureUniqueTitle` will auto-rename by default), you might intercept that if needed. In general, likely errors: missing required field, invalid field type. Use a descriptive error message.  
     
7. **Send Response**: Use `window.parent.postMessage(responseMsg, "*")` to send the response back up to CODAP (which will relay it to the origin plugin). (We will have set up the message posting mechanism separately, but ensure this function uses the common send/response utility.)  
     
8. **Testing**: After implementation, simulate a message locally by calling the handler with a test message object. Also, if possible, run SageModeler inside CODAP or a test harness plugin: post a message to SageModeler’s iframe to create a node and verify that (a) the response is received with success and an ID, (b) the SageModeler UI shows the new node, and (c) `GraphStore.getNodes()` length increased by 1\.

##### Verification

* **Unit Test**: Develop a Jest unit test for `handleCreateNode`. Provide a sample message object, e.g. `{sageApi:true, action:"create", resource:"nodes", values:{title:"TestNode", initialValue:5}, requestId:"123"}`. Invoke the handler and assert that:  
    
  * The response object has `success:true` and contains an `id` in data.  
  * A new node with title "TestNode" now exists in `GraphStore.getNodes()` (find by matching title or ID).  
  * The new node’s initialValue is set to 5 (or default if not provided).  
  * No other nodes are affected.


* **Integration Test**: Using a headless DOM or in-browser test (Cypress), simulate a plugin sending a postMessage to SageModeler’s iframe. After the message, check that the SageModeler UI has a new node with the given name. Also verify that SageModeler responded with the correct JSON message (this can be done by intercepting the postMessage events or by a stub plugin capturing the response).  
    
* **Error Cases**: Test that sending a create-node with no title yields a `success:false` response and no node is added. Test that an extremely long title or other unusual input is handled (e.g., truncated or accepted) similarly to how the UI would handle it.  
    
* **CODAP Data Check**: If running in CODAP, verify that CODAP’s data context got a new attribute for the new node (e.g., open the CODAP table to see a new column named after the node). This ensures our use of `logEvent:true` and GraphStore integration with CodapConnect succeeded. (This is more of an end-to-end verification.)

##### Files Modified

* `src/code/ **sage-api.ts**` – Primary module to implement. Add a function `handleCreateNode` and integrate it into the main message-dispatch logic. This is a new file introduced for the API if not existing, housing all API command handlers.  
* `src/code/models/ **graph-store.ts**` – (No direct modifications for this task, but we will use its API.) Ensure it is imported in `sage-api.ts`. If needed, slight modifications could be made to GraphStore (e.g., exposing certain utilities or preventing automatic renaming of nodes if we prefer to enforce uniqueness via error – but likely not needed).  
* (Potentially) `src/code/ **main.tsx` or equivalent initialization\*\* – Ensure that `sage-api.ts` is loaded and the message listener is attached. For example, in the SageModeler startup code, call something like `SageAPI.initialize()` which adds `window.addEventListener("message", ...)`. This integration might be added once (not per command), but it’s mentioned here to highlight that create-node depends on that setup.