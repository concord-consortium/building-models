#### Task 1-5: Implement Update Link API Command

##### Description

Allow external API clients to modify an existing link's properties. In practice, the main property to update for a link is its relationship type (polarity or strength). This corresponds to a user changing a link from "increase" to "decrease" or vice versa (or other relationship types in advanced use cases). We map this to an `action:"update"` on a `resource:"links/{id}"`.

The API must accept and return both a `relationVector` ("increase", "decrease", "vary") and a `relationScalar` ("aboutTheSame", "aLittle", "aLot", "moreAndMore", "lessAndLess").
When `relationVector` is "vary", the API must accept and return a `customData` field for the user-drawn relationship.

##### Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
| :---- | :---- | :---- | :---- | :---- | :---- |
| 2025-06-22 17:34:00 | Created | N/A | Proposed | Task drafted (PBI-1) | Chad |
| 2025-06-24 01:45:00 | Status Change | Proposed | InProgress | Implementation started | ai-agent |
| 2025-06-24 02:10:00 | Status Change | InProgress | Done | Task completed: API link update, undo/redo, and test interface verified. Fixed iframe postMessage target bug. | ai-agent |

##### Requirements

* Recognize an update request targeting a link: `action:"update"` and `resource:"links/{linkId}"`.  
* Validate link existence: check that a link with that ID exists in the model (GraphStore.linkKeys or similar). If not, return error.  
* Parse values: likely the only relevant field is `relation` (to change the type of the link). Possibly color or label could be changed too (SageModeler might allow labeling links or styling, but not sure if relevant to API). For now, focus on `relation`. If no supported fields are provided, respond with error "No updatable fields provided".  
* Validate relation value: ensure it's an allowed type (similar to create link).  
* Apply change: Use **GraphStore** to update the link. GraphStore provides a `changeLink(link, changes)` method. We can retrieve the Link object (e.g., `const link = GraphStore.linkKeys[linkId]`). Then construct `changes` object, e.g., `{ relation: RelationFactory[relType] }` corresponding to new type. Call `GraphStore.changeLink(link, changes)`. This method wraps an undoable command to change the link relationship, and also handles some special logic (like if changing relation to an "added" or "subtracted" on a normal node, it might convert the source node to a flow variable automatically). Using `logEvent:true` is built-in to changeLink: it logs "relationship changed". Actually, in GraphStore.changeLink implementation above, they directly call `_logLinkEvent`. There's no explicit options parameter in changeLink signature (no options param there in the definition we saw), but internally they call `this._logLinkEvent("relationship changed", ...)` as part of the execute and undo steps with initial and final state. So logging is automatic.  
* GraphStore.changeLink will trigger GraphStore.changeNode in some cases (if converting a normal link to an accumulator link requires the source node to become a flow variable, it calls changeNode with isFlowVariable true). But it manages that internally. We should simply call it and trust its logic.  
* After calling changeLink, the link's relation should be updated. The UI arrow sign will flip direction if polarity changed (GraphStore's updateListeners triggers re-render).  
* Construct response: `success:true` and perhaps return the link id and new relation (e.g., `data:{ id: linkId, relation: "decrease" }`).  
* Errors: if link not found \-\> error; if relation type invalid \-\> error; if trying an unsupported change (maybe SageModeler might not allow certain changes? Typically any qualitative link can switch between increase/decrease freely, so probably fine).
* All API request fields (including relationVector, relationScalar, customData) must be serializable. If a request fails to reach the API, check for serialization issues as identified in Task 1-4.

##### Implementation Plan

1. In message handler, on `action:"update"` with `resource:"links/{id}"`, route to `handleUpdateLink(linkId, message.values)`.  
2. Retrieve Link object: `const link = GraphStore.linkKeys[linkId]` (or via GraphStore.getLinks().find). If not present, return error.  
3. Validate input values: if `values.relation` provided, process it. If not, or if no recognized fields, return error "No valid fields to update". (We might extend in future if link color or label is an option, but not in scope now).  
4. Determine new relation type string from `values.relation`. Validate it's "increase"/"decrease" (or allowed). If invalid, error "Unsupported relation".  
5. Prepare changes object: e.g. `const newRelation = RelationFactory[relType]` (as in create). Then `const changes = { relation: newRelation };`.  
6. Call `GraphStore.changeLink(link, changes)`. This will execute the change. It does not have an options parameter for log, but internal logic logs and batches undo. Wrap in try/catch in case something goes wrong (though unlikely).  
7. On success, build response success.  
8. Edge-case: If the link's relation doesn't actually change (e.g., plugin sets it to the same value it already has), GraphStore.changeLink might do minimal (maybe still logs but nothing changes). We can decide that's still a success or we could detect and short-circuit. It's fine to just call it and return success (idempotent set).  
9. Test special scenario: If the link connects to an accumulator and they try to set `relation:"added"` (if we considered allowing that), GraphStore will convert the source node to a flow. That could remove some other links (GraphStore's code does that in changeLink undo/redo). This is a complex scenario. For now, perhaps restrict relation changes to "increase"/"decrease". If someone tried "added" or "subtracted" (flow relations) via API, GraphStore might actually handle it (as seen). It might actually do the conversion. We won't explicitly support it here, but our function could allow any string and GraphStore will handle accordingly. It's fine.  
* If GraphStore.changeLink triggers a node conversion, that will generate node update and link deletion events, which will be covered by event broadcasting PBI-3. The response to this call is still success, focusing only on the link changed.  
* If something fails (e.g., link object missing relation property?), catch exception and error out.
* Validate and construct the correct Relationship object from the provided fields.
* If `relationVector` is "vary", handle and store the customData appropriately.
* Ensure all request fields are serializable before sending the update request (see Task 1-4 for serialization issue and fix).

##### Verification

* **Unit Test**: First create a link (via Task 1-4 or GraphStore). Then call update-link to flip its relation. E.g., original "increase", send update to "decrease". Check:  
    
  * Response success and link id.  
      
  * The link in GraphStore (GraphStore.linkKeys\[id\].relation or similar) now has the new relation. Possibly check via relation id or the effect on connected nodes. If the link was "increase" originally and now "decrease", maybe the link object's relation's `magnitude` goes from 1 to \-1. We can verify that if accessible. Or we rely on an event or GraphStore logs. But since we trust GraphStore, we can simply confirm that if we run a simulation (if possible in test) the effect flips sign. That might be beyond unit test. Instead, perhaps examine that GraphStore's internal representation changed:  
      
    * Could use GraphStore.getLinks() (if returns Link objects with a property .relation.id), or call link.toExport() to see if relation id changed.

    

  * Perhaps easiest: GraphStore's internal logging might log "relationship changed" events. Not directly verifiable here, but the absence of thrown error and maybe check the GraphStore's data structure if any for link count (should remain same count).

* **Invalid Cases**: Update a nonexistent link \-\> error. Update with invalid relation string \-\> error.  
    
* **Integration**: Create a link in UI (say from A to B with increases). Then through plugin call update-link to "decrease". Verify UI arrow now shows a minus sign (or red color, indicating negative relation). Also the response message indicates success. Possibly check that the underlying simulation yields different results (if one had time – e.g., negative link would invert effect – but that's beyond scope of integration test typically).  
    
* If possible, test an advanced scenario: link connecting to an accumulator. Not straightforward without a full model. We might skip that interactive test; rely on unit logic.

* **Relation Fields**: Test update of links with all combinations of `relationVector` and `relationScalar`.
* **Custom/Vary**: Test update of a link with `relationVector` set to "vary" and a valid `customData` payload, and verify correct storage and retrieval.
* **Undo/Redo Stack**: After updating a link via the API, verify that the action appears in the undo/redo stack and can be undone/redone, matching user-facing behavior (as in Task 1-4).

- Verified link update via API and test interface, including all relationVector and relationScalar options, and customData for 'vary'.
- Confirmed all actions are recorded in the undo/redo stack.
- Debugged and resolved a bug where update requests were sent to the wrong window; fixed by targeting iframe.contentWindow in the test interface.

##### Files Modified

* `src/code/sage-api.ts` – Add `handleUpdateLink`.  
* Possibly import `RelationFactory` if not already, and ensure relation objects available.  
* No changes in GraphStore or Link class; just using GraphStore.changeLink.