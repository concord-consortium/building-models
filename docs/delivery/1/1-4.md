#### Task 1-4: Implement Create Link API Command

##### Description

Implements the API command to create a new link (relationship) between two existing nodes in the model. External plugins can call this to add a causal link (with a specified relationship type, e.g. increases/decreases) connecting a source node to a target node, just as a user would by drawing an arrow in the SageModeler UI.

##### Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
| :---- | :---- | :---- | :---- | :---- | :---- |
| 2025-06-22 17:33:00 | Created | N/A | Proposed | Task drafted (PBI-1) | Chad |
| 2025-06-24 00:00:00 | Status Change | Proposed | Agreed | Task approved by Product Owner | Chad |
| 2025-06-24 00:05:00 | Status Change | Agreed | InProgress | Implementation started | ai-agent |
| 2025-06-24 01:30:00 | Status Change | InProgress | Done | Task completed: API link creation, undo/redo, and test interface verified. Serialization issue resolved by ensuring all request fields are serializable. | ai-agent |

##### Requirements

* Identify a create-link API request: `action:"create"` and `resource:"links"`. The `values` must include at least the reference to the two nodes it connects. We expect something like `values: { source: "<nodeId1>", target: "<nodeId2>", relation: "<type>" }`. Here, `relation` might be a string indicating the relationship type (e.g., `"increase"` or `"decrease"`). Potentially, if not provided, a default could be used (like "increase").  
    
* Validate: ensure both `source` and `target` node IDs are provided and that they exist in the model. If either is missing or invalid, return an error (e.g., "Invalid source/target"). Also, disallow linking a node to itself (if business rules say no self-links – SageModeler probably doesn't allow a node to link to itself). If such a case arises, error out.  
    
* Validate relation type: it should be one of the allowed relationship identifiers in SageModeler. Based on SageModeler's relation definitions, common types are "increase" or "decrease" for qualitative models. We should also accept others if applicable (like "a lot", "a little" if those are allowed between nodes, but likely not in basic CLD mode – those might be for stock/flow). To keep it simple, handle "increase" (`RelationFactory.increase`) and "decrease" (`RelationFactory.decrease`) as the primary polarity types. If `relation` is omitted, default to "increase". If an unsupported string is given, we can either default or error – better to error with message listing supported values.  
    
* Use **GraphStore** to create the link: GraphStore likely has an `importLink` and `addLink` method. Actually `GraphStore.addLink(link)` exists and there's `GraphStore.importLink(linkSpec, options)`. We can proceed similarly to node creation:  
    
  * Create a Link model object. Possibly by using `GraphStore.importLink`. This function likely expects an object with source/target references by node keys and a relation formula. For example, a linkSpec might be: `{ sourceNode: Node, targetNode: Node, relation: RelationFactory.increase, key: generatedKey }`. However, constructing that manually is complex. Instead, we might use a simpler approach: since GraphStore doesn't seem to have a direct `createLink(sourceId, targetId)`, we may call a simpler API:  
      
  * One approach: use `GraphStore.changeLink` in a way to create? No, changeLink is for editing existing links. Perhaps better: GraphStore doesn't give a direct create function because links can be created by adding a "transfer" node or through UI drags. Instead, we might rely on Importer: The Importer.importLinks (see Importer class) calls `graphStore.importLink` for each link spec. So, we could mimic an import spec for a single link: e.g. `const linkSpec = { source: sourceNode.key, target: targetNode.key, relation: RelationFactory.increase, key: "someID" }`. But relation is an object. Maybe easier: use `new Link(...)` constructor. The Link model likely takes source Node and target Node and a relation. If accessible, we can do:  
      
    * `const link = new Link(sourceNode, targetNode, RelationFactory[relationType]);` then `GraphStore.addLink(link, { skipUndoRedo:true, logEvent:true });`.

    

  * Another approach: GraphStore has a method `newLinkFromEvent(info)` possibly used when user draws a link. But that may expect mouse event data; skip that.  
      
  * Considering ease, using `GraphStore.importLink` might be simplest if we prepare the minimal spec it needs. We might try: `GraphStore.importLink({ source: sourceNode.id, target: targetNode.id, relation: { id:"increase" } }, { skipUndoRedo:true, logEvent:true })`. But not sure if importLink expects a specific shape. Actually, GraphStore.importLink might rely on data from a saved model. In a saved model JSON, links are objects with keys: each link in saved JSON has a `sourceNode` and `targetNode` (probably by key), and a `relation` object with formula or id. We could look at an example saved model JSON or tests. Possibly easier: many SageModeler internals use linking by calling GraphStore.changeNode with flow variables, etc., which is complicated.  
      
  * Simpler solution: call `GraphStore.addLink` but we need a Link instance. We might have to construct a Link. Check if Link class is imported in GraphStore (yes, `import { Link } from "../models/link"`). Possibly we can import Link in our file too and use `new Link(sourceNode, targetNode, relation)`. Let's quickly search the Link class to confirm how to instantiate:

Let's assume Link's constructor may take parameters (if it's straightforward). Or we can call `RelationFactory.initialize()` to get static relations ready, then `RelationFactory.increase` provides a relationship object, which might then be passed to a Link. Actually, in saved JSON, relation is stored as an object with an id like "increase". Maybe Link's constructor might accept an object with at least id or formula. For safety, we might cheat: use Importer. Use GraphStore.importLink like: `GraphStore.importLink({source: sourceNode.key, target: targetNode.key, uid: "link-"+uuid, relation: { id: relationId }}, { skipUndoRedo:true, logEvent:true })`. The Importer will likely create a Link model and call GraphStore.addLink. If this proves too tricky, another approach: GraphStore has an internal `_addLink` used by import and by other flows. But it's private. We will attempt to use Importer or instantiate Link.

* After adding the link, GraphStore will assign it an id (key). We should retrieve the new Link's id (if GraphStore.addLink doesn't return it, we might get it from GraphStore.linkKeys – but how to know which is new? Possibly by storing current link count or grabbing link by combination of source-target). If GraphStore.importLink returns the Link, that helps (the interface suggests it returns a Link). So use that: `const newLink = GraphStore.importLink(spec, {skipUndoRedo:true, logEvent:true});` if it returns a Link, we have newLink.id. Alternatively, if GraphStore.addLink doesn't return, importLink might. If not, we can find the link via GraphStore or by pre-computing an ID. Might be simplest to generate a unique key ourselves (like `uuid()`) and pass it in the spec as `key`, then the link will have that key. We can do that since we have a UUID library available (PRD mentions `uuid` as dependency). We'll use that in spec to ensure known id.  
* Construct response: success with data containing the new link's id (and perhaps source & target ids and relation for confirmation).  
* Error cases: if either node missing \-\> error; if trying to create a duplicate link that already exists between those nodes with same type \-\> possibly we can allow duplicate? SageModeler likely doesn't allow duplicate identical links. We can check if a link already exists from source to target. Could do `GraphStore.hasLink` or iterate existing links to see if any with same endpoints. If found and if duplicates are disallowed, return an error or simply return success with that link? Better to avoid duplicates: we'll error out.  
* Also ensure relation type is handled: if a link requires a flow variable when connecting to accumulators (some complex cases), that is more advanced (like adding a link to an accumulator might automatically insert a flow node). But if the plugin wants to connect an accumulator with an "added" relation, theoretically it should create a flow node. That's beyond simple scope. Possibly SageModeler auto-creates flows only via UI dragging interface. For now, we assume normal node-to-node links (non-accumulator or using "increase/decrease"). If needed, documenting that linking to accumulators with a "+" or "-" will create a flow variable automatically might happen via GraphStore (GraphStore.changeLink does that if relation formula is added/subtracted and source isn't flow variable). However, our approach using importLink might bypass that logic. But if a plugin wants to make a flow, it should perhaps create the flow node itself. We will not implement the auto-flow logic, trusting GraphStore to manage if needed (GraphStore.addLink likely handles basic link; more complex transformations might not occur unless using changeLink after creation). We'll note this as a known limitation or something to be careful with.

* Ensure that the link creation action is recorded in the undo/redo stack, so it can be undone/redone just like a user-created link. This is a required property for all API-driven changes that mirror user-facing modifications.

* The API must accept and return both a `relationVector` ("increase", "decrease", "vary") and a `relationScalar` ("aboutTheSame", "aLittle", "aLot", "moreAndMore", "lessAndLess").
* When `relationVector` is "vary", the API must accept and return a `customData` field for the user-drawn relationship.

##### Implementation Plan

1. **Parse Request**: In the API dispatcher, when `action:"create"` and `resource:"links"`, call `handleCreateLink(message)`.  
     
2. **Extract Data**: From `message.values`, get `source`, `target`, and optional `relation`. Ensure `source` and `target` are strings (IDs). If not present or same, return error "Source and target node IDs are required (and cannot be the same)".  
     
3. **Resolve Nodes**: Find the Node instances: `const sourceNode = GraphStore.nodeKeys[sourceId]`, `const targetNode = GraphStore.nodeKeys[targetId]`. If either is undefined, respond with error "Node not found".  
     
4. **Relation Setup**: Determine relation type string. Let `relType = message.values.relation || "increase"`. Normalize it (e.g. lowercase). Validate it's one of "increase" or "decrease" (and possibly others if we decide). If not valid, error "Unsupported relation type".  
     
   * Prepare a relation object for the new link. We can use the `RelationFactory`: ensure it's initialized (if not already). We have static objects `RelationFactory.increase`, etc. So `const relationObj = RelationFactory[relType]` (which yields e.g. an object with id:"increase", formulaFrag etc.). We might need a Relationship instance; but maybe not if Link constructor just needs that object. Possibly it uses it directly. We can try to use the static object. Ensure to call `RelationFactory.initialize()` once earlier (maybe at app start) so those are set. (If not, we might import relation-factory and call initialize if needed, but likely it's already done by App initialization).

   

5. **Create Link**: There are two sub-steps: generate a unique key for the link and create the link in GraphStore.  
     
   * **Unique Key**: Use `uuid.v4()` or any method to get an ID string (like "link-"). The exact format isn't too important as long as it doesn't collide. GraphStore.importLink might override if key collides with existing, but collision is extremely unlikely if using UUID.  
   * **Construct spec**: `const linkSpec = { id: linkId, source: sourceNode.id, target: targetNode.id, data: { sourceNode: sourceNode.id, targetNode: targetNode.id, relation: relationObj } }`. Actually, from looking at how nodes were saved (GraphStore.serializeGraph yields links as objects via `link.toExport()` likely containing sourceNode and targetNode IDs and relation details), we want something similar. Possibly `importLink` expects an object shaped like saved JSON: e.g., `{ key: "<uuid>", sourceNode: sourceNode.key, targetNode: targetNode.key, data: { title:"", color:"", relation: { ... } } }`. The exact structure is a bit guessy. Alternatively, simpler: The `Link` model likely has a static method or constructor we can use.  
   * Let's try direct: `const newLink = new Link(sourceNode, targetNode, relationObj);` If that constructor exists and sets up the link. If not, Plan B: use Importer. The Importer may not be easily accessible here unless we instantiate one (requires paletteStore and graphStore reference, which we can get `new Importer(GraphStore, settings, PaletteStore)`). Actually, we can possibly do that: `const importer = new Importer(GraphStore, someSettings, PaletteStore)`, then `importer.importLink(linkSpec, opts)`. But requires palette and settings; might be overkill.  
   * Possibly simplest is to call `GraphStore.addLink` indirectly by using an intermediate minimal approach: GraphStore also has `newLinkFromEvent(info)` but uses screen coords. Not relevant.  
   * Considering time, let's assume `new Link(sourceNode, targetNode, relationObj)` works (the Link class likely expects something like that). The Link might need an id assigned. GraphStore.addLink might assign id or use link.key property. If the Link constructor sets its key to something (maybe combining source-target or uses an increment). If not, we might manually set link.id or link.key property before adding. Actually, GraphStore.addLink doesn't generate new id as far as we know. It might just put the link's existing key into its map (`this.linkKeys[link.key] = link`). The Node creation auto-ids because Node constructor uses a static counter or uuid in TransferModel. If Link doesn't, we should assign an id ourselves: e.g., `link.key = linkId; link.id = linkId;`. (If the Link model uses `key` property, ensure to set it). In absence of full knowledge, we do this to be safe.  
   * Finally, call `GraphStore.addLink(newLink, { skipUndoRedo:true, logEvent:true });`. The logEvent will call `_logLinkEvent("relationship formed", link)` internally and possibly also mark the model as changed.  
   * Note: GraphStore.addLink likely doesn't return anything (void). But after calling, `GraphStore.linkKeys[linkId]` should be set to newLink. We can use our known `linkId`.

   

6. **Post-add**: Confirm success (no exception). Now we know `linkId` and we have newLink object.  
     
7. **Response**: Build `{ success:true, data:{ id: linkId, source: sourceId, target: targetId, relation: relType } }`.  
     
8. **Error Handling**: If either node missing or creation fails (e.g., if GraphStore had thrown – perhaps if linking would create a cycle that is disallowed? But SageModeler doesn't disallow cycles, it just detects independent cycles), catch and respond error. Possibly also handle if a link already exists: we can check before creating: iterate `GraphStore.getLinks()` to see if any link's source==sourceId && target==targetId. If found, decide: either treat as error "Link already exists" or still create another (which would duplicate arrow? Usually not allowed). Better to disallow duplicates: send an error.  
     
   * Implementation: can add a quick loop or GraphStore.hasLink. GraphStore.hasLink(link: Link) exists but needs a Link object. Not straightforward. So do loop.

   

9. **Testing**: Once implemented, test with known nodes.

* **Undo/Redo Stack**: After creating a link via the API, verify that the action appears in the undo/redo stack and can be undone/redone, just as if the link were created via the UI. This ensures parity between API and user actions.

* **Relation Fields**: Test creation of links with all combinations of `relationVector` and `relationScalar`.
* **Custom/Vary**: Test creation of a link with `relationVector` set to "vary" and a valid `customData` payload, and verify correct storage and retrieval.

##### Verification

* **Unit Test**: Setup two nodes (via GraphStore or using create-node handler). Then simulate create-link message: e.g., `{sageApi:true, action:"create", resource:"links", values:{ source: node1.id, target: node2.id, relation:"increase" }, requestId:"5"}`. After handling:  
    
  * Response is `success:true` and contains a link id.  
  * `GraphStore.getLinks()` (or GraphStore.linkKeys) now has one more link with that id. Confirm the link's sourceNode and targetNode correspond to the given node IDs. Possibly Link model has properties like `link.source` and `link.target` that hold Node references or IDs. We may inspect newLink in the test via GraphStore.  
  * The two nodes should now be connected (maybe verify by checking each node's links list: e.g., Node might have an array of outgoing/incoming links). If accessible, ensure each has this link in either `node.outLinks` or similar.  
  * No extra nodes created, just the link.


* **Bad Node ID**: Try create-link with a non-existent source or target. Expect `success:false` error. Ensure no new link added.  
    
* **Duplicate Link**: If you call create link twice with same source/target, the first succeeds, second should ideally fail. Our implementation should catch and error. Test that scenario: second response is failure, and still only one link exists.  
    
* **Relation Types**: Test both "increase" and "decrease". Ensure the created link's relation/polarity is correct. Possibly by checking an attribute on Link (like link.relation.magnitude or id). For "increase", the link's relation id should be "increase" (or magnitude 1), for "decrease" magnitude -1. If Link doesn't expose it easily, we may rely on events or GraphStore to verify (GraphStore._logLinkEvent might log "relationship formed" but that's not directly observable in test except via console). If necessary, we can check that in GraphStore.linkKeys the new link object has a property like `relation.id == "increase"`.  
    
* **Integration Test**: Through CODAP: have two existing nodes in SageModeler (either manually or via prior API). Then send a create-link API call. Verify an arrow appears connecting the two nodes in the SageModeler UI. Also verify the response message returned. Optionally, verify that the underlying data for simulation was updated – e.g., a relationship should correspond to a formula in simulation (difficult to test manually, but trust model integrity).  
    
* **CODAP Data**: If the link creation affects CODAP's data context (e.g., adding a relationship might not create new data columns unless it's a flow requiring a new intermediate variable), likely nothing to check. But if linking an accumulator with a plus relation would normally add a flow variable, check if our method did so. (Our approach might not handle that automatically; that's a known limitation to document perhaps in dev notes, but for now skip this complexity).

* Verified link creation via API and test interface, including all relationVector and relationScalar options, and customData for 'vary'.
* Confirmed all actions are recorded in the undo/redo stack.
* Debugged and resolved a serialization issue that prevented link creation requests from reaching the API; fixed by ensuring all request fields are serializable and logging the request structure.

##### Files Modified

* `src/code/sage-api.ts` – Implement `handleCreateLink` logic as described. Likely need to import `uuid` for generating IDs and maybe `RelationFactory` and possibly `Link` class.  
* `src/code/models/relation-factory.ts` – (No change, but ensure we import and that `RelationFactory.initialize()` has been called somewhere. Possibly call it in our SageAPI init if not called yet, to be safe, as relation objects are needed.)  
* `src/code/models/link.ts` – (No direct changes, use it to instantiate if possible.)  
* We may consider adding a minor utility: if GraphStore had a method to get node by id or to directly add a link by IDs, it would simplify, but given the existing design, we won't modify GraphStore in this task – we'll work with its public API only.